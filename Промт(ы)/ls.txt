package com.kefir.logistics.launcher_service.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotEmpty;
import java.util.Map;

@Component
@ConfigurationProperties(prefix = "launcher")
@Validated
public class ApplicationProperties {

    @NotEmpty
    private String baseDir = "../";

    @NotEmpty
    private String logsDir = "./logs";

    @Min(1000)
    private int startupDelayMs = 5000;

    @Min(5)
    private int healthCheckTimeoutSec = 30;

    private boolean autoRestart = true;

    private Map<String, ServiceConfig> services;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    public ApplicationProperties() {
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getBaseDir() {
        return baseDir;
    }

    public void setBaseDir(String baseDir) {
        this.baseDir = baseDir;
    }

    public String getLogsDir() {
        return logsDir;
    }

    public void setLogsDir(String logsDir) {
        this.logsDir = logsDir;
    }

    public int getStartupDelayMs() {
        return startupDelayMs;
    }

    public void setStartupDelayMs(int startupDelayMs) {
        this.startupDelayMs = startupDelayMs;
    }

    public int getHealthCheckTimeoutSec() {
        return healthCheckTimeoutSec;
    }

    public void setHealthCheckTimeoutSec(int healthCheckTimeoutSec) {
        this.healthCheckTimeoutSec = healthCheckTimeoutSec;
    }

    public boolean isAutoRestart() {
        return autoRestart;
    }

    public void setAutoRestart(boolean autoRestart) {
        this.autoRestart = autoRestart;
    }

    public Map<String, ServiceConfig> getServices() {
        return services;
    }

    public void setServices(Map<String, ServiceConfig> services) {
        this.services = services;
    }

    public ServiceConfig getServiceConfig(String serviceId) {
        return services != null ? services.get(serviceId) : null;
    }

    public static class ServiceConfig {

        private String id;

        @NotEmpty
        private String directory;

        @Min(1024)
        private int port;

        @NotEmpty
        private String displayName;

        private String healthEndpoint = "/actuator/health";

        public ServiceConfig() {
        }

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getDirectory() {
            return directory;
        }

        public void setDirectory(String directory) {
            this.directory = directory;
        }

        public int getPort() {
            return port;
        }

        public void setPort(int port) {
            this.port = port;
        }

        public String getDisplayName() {
            return displayName;
        }

        public void setDisplayName(String displayName) {
            this.displayName = displayName;
        }

        public String getHealthEndpoint() {
            return healthEndpoint;
        }

        public void setHealthEndpoint(String healthEndpoint) {
            this.healthEndpoint = healthEndpoint;
        }

        @Override
        public String toString() {
            return String.format("ServiceConfig{id='%s', directory='%s', port=%d, displayName='%s'}",
                    id, directory, port, displayName);
        }
    }

    @Override
    public String toString() {
        return String.format("ApplicationProperties{baseDir='%s', logsDir='%s', servicesCount=%d}",
                baseDir, logsDir, services != null ? services.size() : 0);
    }
}package com.kefir.logistics.launcher_service.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import java.util.concurrent.Executor;

@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);           // –û—Å–Ω–æ–≤–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤
        executor.setMaxPoolSize(50);            // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤
        executor.setQueueCapacity(100);         // –†–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏ –∑–∞–¥–∞—á
        executor.setThreadNamePrefix("LauncherAsync-");
        executor.initialize();
        return executor;
    }
}package com.kefir.logistics.launcher_service.config;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class SpringApplicationContextHolder implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext context) {
        applicationContext = context;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}package com.kefir.logistics.launcher_service.config;

public class SwaggerConfig {
}
package com.kefir.logistics.launcher_service.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins(
                        "http://localhost:3000",    // React —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
                        "http://localhost:8080",    // API Gateway
                        "http://localhost:8081",    // User Service
                        "http://localhost:8090",    // Saga Service
                        "http://localhost:8097",    // Auth Service
                        "http://localhost:8099",    // ‚Üê –î–û–ë–ê–í–õ–ï–ù–û: –°–∞–º Launcher-service
                        "http://127.0.0.1:8099"     // ‚Üê –î–û–ë–ê–í–õ–ï–ù–û: –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∞–¥—Ä–µ—Å
                )
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.config.ApplicationProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/config")
public class ConfigController {

    @Autowired
    private ApplicationProperties appProperties;

    @GetMapping("/info")
    public Map<String, Object> getConfigInfo() {
        Map<String, Object> response = new HashMap<>();

        response.put("status", "OK");
        response.put("service", "Launcher Service Config");

        if (appProperties != null) {
            response.put("baseDir", appProperties.getBaseDir());
            response.put("logsDir", appProperties.getLogsDir());
            response.put("startupDelayMs", appProperties.getStartupDelayMs());
            response.put("healthCheckTimeoutSec", appProperties.getHealthCheckTimeoutSec());
            response.put("autoRestart", appProperties.isAutoRestart());

            if (appProperties.getServices() != null) {
                response.put("servicesCount", appProperties.getServices().size());
                response.put("services", appProperties.getServices());
            } else {
                response.put("servicesCount", 0);
                response.put("services", "No services configured");
            }
        } else {
            response.put("error", "ApplicationProperties not autowired");
        }

        response.put("timestamp", System.currentTimeMillis());

        return response;
    }

    @GetMapping("/check")
    public Map<String, String> checkConfig() {
        Map<String, String> response = new HashMap<>();

        if (appProperties == null) {
            response.put("status", "ERROR");
            response.put("message", "Configuration not loaded");
        } else if (appProperties.getServices() == null || appProperties.getServices().isEmpty()) {
            response.put("status", "WARNING");
            response.put("message", "Configuration loaded but no services defined");
        } else {
            response.put("status", "OK");
            response.put("message", "Configuration loaded successfully");
            response.put("servicesCount", String.valueOf(appProperties.getServices().size()));
        }

        return response;
    }

    @GetMapping("/ping")
    public Map<String, String> ping() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "pong");
        response.put("service", "launcher-service");
        response.put("time", java.time.LocalDateTime.now().toString());
        return response;
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.model.dto.DemoScenarioDTO;
import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.service.DemoScenarioService;
import com.kefir.logistics.launcher_service.service.ServiceOrchestrator;
import com.kefir.logistics.launcher_service.util.PowerShellHelper;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.*;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import jakarta.annotation.PreDestroy;
import jakarta.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

/**
 * –ì–ª–∞–≤–Ω—ã–π –∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è–º–∏ KEFIR.
 * –ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç –º–∏—Å—Å–∏—é –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è: –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –æ—à–∏–±–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ –µ—ë —Ä–µ—à–µ–Ω–∏—è.
 * –ü—Ä–∞–≤–∏–ª–æ: —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —ç–∫–∑–µ–º–ø–ª—è—Ä –∫–∞–∂–¥–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞. –ï—Å–ª–∏ –∑–∞–ø—É—â–µ–Ω - –Ω–µ —Ç—Ä–æ–≥–∞–µ–º –ø–æ—Ä—Ç—ã.
 */
@RestController
@RequestMapping("/api/v1/demo")
@Tag(name = "Demo Scenarios", description = "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è–º–∏ KEFIR")
@EnableScheduling
public class DemoController {
    private static final Logger logger = LoggerFactory.getLogger(DemoController.class);

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    @Autowired
    private DemoScenarioService demoScenarioService;

    @Autowired
    private PowerShellHelper powerShellHelper;

    @Value("${app.demo.startup.check:true}")
    private boolean startupCheckEnabled;

    @Value("${app.demo.autoStartScenario:none}")
    private String autoStartScenario;

    @Value("${app.reports.directory:./reports}")
    private String reportsDirectory;

    // –ü–æ—Ä—Ç—ã KEFIR —Å–æ–≥–ª–∞—Å–Ω–æ –º–∏—Å—Å–∏–∏
    private static final Map<String, Integer> KEFIR_SERVICES = new LinkedHashMap<String, Integer>() {{
        put("Launcher Service", 8099);       // –°–∞–º –ª–∞—É–Ω—á–µ—Ä
        put("API Gateway", 8080);           // API Gateway
        put("Authentication Service", 8097); // Auth
        put("User Management Service", 8081); // User
        put("Warehouse Service", 8082);      // Sklad - –∫–ª—é—á–µ–≤–æ–π –¥–ª—è –º–∏—Å—Å–∏–∏
        put("Shopping Cart Service", 8083);  // Backet - –Ω–∞—á–∞–ª–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
        put("Office Management Service", 8085); // Office - —Å–≤—è–∑—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º
        put("Collector Service", 8086);      // Collector - –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç –æ—à–∏–±–∫—É
        put("Delivery Service", 8088);       // Delivery
        put("Transaction Saga Service", 8090); // Saga - —Ä–µ—à–µ–Ω–∏–µ (–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ï–ù)
    }};

    // –¢—Ä–µ–∫–µ—Ä –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∏ –∏—Ö PID
    private final Map<Integer, ServiceProcessInfo> runningProcesses = new ConcurrentHashMap<>();
    private final Map<String, ServiceInfo> serviceInfos = new ConcurrentHashMap<>();

    // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    private final AtomicInteger totalTransactions = new AtomicInteger(0);
    private final AtomicInteger failedTransactions = new AtomicInteger(0);
    private final AtomicInteger killedExternalProcesses = new AtomicInteger(0);
    private final LocalDateTime startTime = LocalDateTime.now();

    // –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(4);
    private final RestTemplate restTemplate;

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–ª–∞—Å—Å—ã
    private static class ServiceProcessInfo {
        int port;
        String serviceName;
        String pid;
        Process process;
        LocalDateTime startTime;
        boolean isManaged; // –£–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ª–∏ –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º

        ServiceProcessInfo(int port, String serviceName, String pid, boolean isManaged) {
            this.port = port;
            this.serviceName = serviceName;
            this.pid = pid;
            this.isManaged = isManaged;
            this.startTime = LocalDateTime.now();
        }
    }

    private static class ServiceInfo {
        String name;
        int port;
        boolean isRunning;
        boolean isHealthy;
        boolean isManaged;
        LocalDateTime lastChecked;

        ServiceInfo(String name, int port, boolean isManaged) {
            this.name = name;
            this.port = port;
            this.isManaged = isManaged;
            this.isRunning = false;
            this.isHealthy = false;
            this.lastChecked = LocalDateTime.now();
        }
    }

    public DemoController(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder
                .setConnectTimeout(Duration.ofSeconds(10))
                .setReadTimeout(Duration.ofSeconds(30))
                .build();

        logger.info("DemoController initialized with mission: Demonstrate transaction error and solution");
    }

    @PostConstruct
    public void init() {
        logger.info("üöÄ Initializing DemoController for KEFIR mission...");

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ—Ä–≤–∏—Å–∞—Ö
        initializeServiceInfos();

        // –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤
        createDirectories();

        // –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–µ–º–æ –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ
        if (!"none".equalsIgnoreCase(autoStartScenario)) {
            logger.info("üìã –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è: {}", autoStartScenario);
            scheduleAutoStart(autoStartScenario, 10000);
        }

        // –ó–∞–ø—É—Å–∫ —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
        if (startupCheckEnabled) {
            startBackgroundTasks();
        }

        logger.info("‚úÖ DemoController initialized");
        logger.info("   Mission: Demonstrate transaction error ‚Üí Solution via Saga");
        logger.info("   Key Ports: Saga(8090), Warehouse(8082), Cart(8083), Collector(8086)");
    }

    @PreDestroy
    public void cleanup() {
        logger.info("üßπ Shutting down DemoController...");

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ù–ï —É–ø—Ä–∞–≤–ª—è–µ–º—ã–µ –ø—Ä–æ—Ü–µ—Å—Å—ã
        stopNonManagedProcesses();

        // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }

        logger.info("‚úÖ DemoController shutdown complete");
    }

    // ============ –î–ï–ú–û-–°–¶–ï–ù–ê–†–ò–ò –î–õ–Ø –ú–ò–°–°–ò–ò ============

    @PostMapping("/mission/demonstrate-problem")
    @Operation(summary = "–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–±–ª–µ–º—ã –∏–∑ –º–∏—Å—Å–∏–∏: –Ω–µ–ø–æ–ª–Ω—ã–π –∑–∞–∫–∞–∑")
    public ResponseEntity<Map<String, Object>> demonstrateMissionProblem() {
        logger.info("‚ö†Ô∏è –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ü–†–û–ë–õ–ï–ú–´ –ò–ó –ú–ò–°–°–ò–ò");

        Map<String, Object> result = new LinkedHashMap<>();
        result.put("mission", "–ü—É–Ω–∫—Ç 1.1-1.2: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –æ—à–∏–±–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏");
        result.put("operationId", "MISSION_PROBLEM_" + System.currentTimeMillis());
        result.put("startTime", LocalDateTime.now());

        try {
            // –®–∞–≥ 1: –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å–µ—Ä–≤–∏—Å–æ–≤
            logger.info("1. üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —Å–µ—Ä–≤–∏—Å–æ–≤...");
            boolean servicesReady = checkMissionServicesReady();
            if (!servicesReady) {
                return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
                        .body(Map.of(
                                "error", "–ù–µ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –º–∏—Å—Å–∏–∏ –≥–æ—Ç–æ–≤—ã",
                                "requiredServices", getRequiredMissionServices(),
                                "timestamp", LocalDateTime.now()
                        ));
            }

            // –®–∞–≥ 2: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–±–ª–µ–º—ã
            logger.info("2. üé¨ –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è –ø—Ä–æ–±–ª–µ–º—ã...");
            List<String> problemSteps = createProblemScenario();
            result.put("problemSteps", problemSteps);

            // –®–∞–≥ 3: –ê–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–π
            logger.info("3. üìä –ê–Ω–∞–ª–∏–∑ –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏–π...");
            Map<String, Object> consequences = analyzeConsequences();
            result.put("consequences", consequences);

            // –®–∞–≥ 4: –ò—Ç–æ–≥–∏
            result.put("status", "PROBLEM_DEMONSTRATED");
            result.put("endTime", LocalDateTime.now());
            result.put("conclusion", "–ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –ø—Ä–∏–≤–æ–¥–∏—Ç –∫ –Ω–µ–ø–æ–ª–Ω–æ–π –¥–æ—Å—Ç–∞–≤–∫–µ –∏ —É–≤–µ–ª–∏—á–µ–Ω–∏—é –≤—Ä–µ–º–µ–Ω–∏ –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ 4 —Ä–∞–∑–∞");

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ –∏–∑ –º–∏—Å—Å–∏–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞");
            logger.info("   –°—É—Ç—å: –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è —á–∞—Å—Ç–∏—á–Ω–æ ‚Üí –∫–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç –Ω–µ–ø–æ–ª–Ω—ã–π –∑–∞–∫–∞–∑ ‚Üí –¥–æ—Å—Ç–∞–≤–∫–∞ 1 —á–∞—Å –≤–º–µ—Å—Ç–æ 15 –º–∏–Ω");

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ø—Ä–æ–±–ª–µ–º—ã: {}", e.getMessage(), e);

            result.put("status", "FAILED");
            result.put("error", e.getMessage());
            result.put("endTime", LocalDateTime.now());

            failedTransactions.incrementAndGet();

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    @PostMapping("/mission/demonstrate-solution")
    @Operation(summary = "–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏—è –∏–∑ –º–∏—Å—Å–∏–∏: –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏")
    public ResponseEntity<Map<String, Object>> demonstrateMissionSolution() {
        logger.info("üí° –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–ï–®–ï–ù–ò–Ø –ò–ó –ú–ò–°–°–ò–ò");

        // –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –ü–†–û–í–ï–†–ö–ê: Saga –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–µ–Ω
        boolean sagaAvailable = isPortOpen(8090);
        if (!sagaAvailable) {
            Map<String, Object> error = new LinkedHashMap<>();
            error.put("error", "Transaction Saga Service –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω");
            error.put("mission", "–ü—É–Ω–∫—Ç 2: –†–µ—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –ø–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏");
            error.put("critical", true);
            error.put("port", 8090);
            error.put("recommendation", "–ó–∞–ø—É—Å—Ç–∏—Ç–µ Transaction Saga Service –Ω–∞ –ø–æ—Ä—Ç—É 8090 –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–µ—à–µ–Ω–∏—è");
            error.put("command", "cd TransactionSaga && mvn spring-boot:run -Dserver.port=8090");

            return ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE).body(error);
        }

        Map<String, Object> result = new LinkedHashMap<>();
        result.put("mission", "–ü—É–Ω–∫—Ç 2: –†–µ—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ –ø–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏");
        result.put("operationId", "MISSION_SOLUTION_" + System.currentTimeMillis());
        result.put("startTime", LocalDateTime.now());
        result.put("sagaAvailable", true);
        result.put("sagaPort", 8090);

        try {
            // –®–∞–≥ 1: –§–∏–ª–æ—Å–æ—Ñ–∏—è —Ä–µ—à–µ–Ω–∏—è
            logger.info("1. üß† –§–∏–ª–æ—Å–æ—Ñ–∏—è —Ä–µ—à–µ–Ω–∏—è...");
            Map<String, Object> philosophy = getSolutionPhilosophy();
            result.put("philosophy", philosophy);

            // –®–∞–≥ 2: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏—è
            logger.info("2. üé¨ –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏—è...");
            List<String> solutionSteps = createSolutionScenario();
            result.put("solutionSteps", solutionSteps);

            // –®–∞–≥ 3: –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞
            logger.info("3. ‚úÖ –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ –ø–æ–¥—Ö–æ–¥–∞...");
            Map<String, Object> benefits = getSolutionBenefits();
            result.put("benefits", benefits);

            // –®–∞–≥ 4: –°—Ä–∞–≤–Ω–µ–Ω–∏–µ
            logger.info("4. üìä –°—Ä–∞–≤–Ω–µ–Ω–∏–µ –ø–æ–¥—Ö–æ–¥–æ–≤...");
            Map<String, Object> comparison = createSolutionComparison();
            result.put("comparison", comparison);

            // –®–∞–≥ 5: –ò—Ç–æ–≥–∏
            result.put("status", "SOLUTION_DEMONSTRATED");
            result.put("endTime", LocalDateTime.now());
            result.put("keyMessage", "–ü—Ä–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –æ—à–∏–±–∫–∞—Ö –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å, —á–µ–º –ø—ã—Ç–∞—Ç—å—Å—è –µ–≥–æ –ø–æ—á–∏–Ω–∏—Ç—å");
            result.put("missionAccomplished", true);

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –†–µ—à–µ–Ω–∏–µ –∏–∑ –º–∏—Å—Å–∏–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ");
            logger.info("   –°—É—Ç—å: –ü–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ ‚Üí –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö —Ç–æ–≤–∞—Ä–æ–≤ ‚Üí –¥–æ—Å—Ç–∞–≤–∫–∞ 15 –º–∏–Ω—É—Ç");
            logger.info("   –§–∏–ª–æ—Å–æ—Ñ–∏—è: '–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å' –≤–º–µ—Å—Ç–æ '—á–∏–Ω–∏—Ç—å –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—É—é –æ—à–∏–±–∫—É'");

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–µ—à–µ–Ω–∏—è: {}", e.getMessage(), e);

            result.put("status", "FAILED");
            result.put("error", e.getMessage());
            result.put("endTime", LocalDateTime.now());

            failedTransactions.incrementAndGet();

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    @PostMapping("/mission/complete")
    @Operation(summary = "–ü–æ–ª–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏—Å—Å–∏–∏: –ø—Ä–æ–±–ª–µ–º–∞ + —Ä–µ—à–µ–Ω–∏–µ")
    public ResponseEntity<Map<String, Object>> completeMission() {
        logger.info("üéØ –ü–û–õ–ù–û–ï –í–´–ü–û–õ–ù–ï–ù–ò–ï –ú–ò–°–°–ò–ò –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø");

        Map<String, Object> result = new LinkedHashMap<>();
        result.put("mission", "KEFIR: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –æ—à–∏–±–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∏ –µ—ë —Ä–µ—à–µ–Ω–∏—è");
        result.put("operationId", "MISSION_COMPLETE_" + System.currentTimeMillis());
        result.put("startTime", LocalDateTime.now());

        try {
            // –ß–∞—Å—Ç—å 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞
            logger.info("üîß –ü–û–î–ì–û–¢–û–í–ö–ê –ö –í–´–ü–û–õ–ù–ï–ù–ò–Æ –ú–ò–°–°–ò–ò");

            // 1. –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
            logger.info("1. üßπ –û—Å–≤–æ–±–æ–∂–¥–∞—é –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...");
            releaseExternalPortsForMission();

            // 2. –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
            logger.info("2. üöÄ –ó–∞–ø—É—Å–∫–∞—é —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –º–∏—Å—Å–∏–∏...");
            startMissionServices();

            // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ Saga –¥–æ—Å—Ç—É–ø–µ–Ω (–ö–†–ò–¢–ò–ß–ï–°–ö–ò)
            logger.info("3. üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Transaction Saga Service...");
            boolean sagaReady = verifySagaForMission();
            if (!sagaReady) {
                throw new RuntimeException("Transaction Saga Service –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ú–∏—Å—Å–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞!");
            }

            // 4. –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
            logger.info("4. ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–µ—Ä–≤–∏—Å–æ–≤...");
            Thread.sleep(10000);

            // –ß–∞—Å—Ç—å 2: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–æ–±–ª–µ–º—ã
            logger.info("‚ö†Ô∏è –ß–ê–°–¢–¨ 1: –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ü–†–û–ë–õ–ï–ú–´");
            ResponseEntity<Map<String, Object>> problemResponse = demonstrateMissionProblem();
            if (problemResponse.getStatusCode() != HttpStatus.OK) {
                throw new RuntimeException("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å –ø—Ä–æ–±–ª–µ–º—É: " +
                        problemResponse.getBody());
            }
            result.put("problem", problemResponse.getBody());

            // –ü–∞—É–∑–∞ –¥–ª—è –æ—Å–º—ã—Å–ª–µ–Ω–∏—è
            logger.info("‚è∏Ô∏è  –ü–∞—É–∑–∞ –¥–ª—è –æ—Å–º—ã—Å–ª–µ–Ω–∏—è –ø—Ä–æ–±–ª–µ–º—ã (5 —Å–µ–∫—É–Ω–¥)...");
            Thread.sleep(5000);

            // –ß–∞—Å—Ç—å 3: –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏—è
            logger.info("üí° –ß–ê–°–¢–¨ 2: –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –†–ï–®–ï–ù–ò–Ø");
            ResponseEntity<Map<String, Object>> solutionResponse = demonstrateMissionSolution();
            if (solutionResponse.getStatusCode() != HttpStatus.OK) {
                throw new RuntimeException("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–µ—à–µ–Ω–∏–µ: " +
                        solutionResponse.getBody());
            }
            result.put("solution", solutionResponse.getBody());

            // –ß–∞—Å—Ç—å 4: –ò—Ç–æ–≥–∏ –∏ –≤—ã–≤–æ–¥—ã
            logger.info("üìä –ß–ê–°–¢–¨ 3: –ò–¢–û–ì–ò –ò –í–´–í–û–î–´");
            Map<String, Object> conclusions = createMissionConclusions();
            result.put("conclusions", conclusions);

            // –§–∏–Ω–∞–ª—å–Ω—ã–π —Å—Ç–∞—Ç—É—Å
            result.put("status", "MISSION_COMPLETED");
            result.put("endTime", LocalDateTime.now());
            result.put("success", true);
            result.put("missionPoints", Arrays.asList(
                    "1.1 ‚úì –†–∞–∑—ã–≥—Ä–∞–Ω–∞ —Å–∏—Ç—É–∞—Ü–∏—è —Å –æ—à–∏–±–∫–æ–π —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏",
                    "1.2 ‚úì –ü—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω—ã –ø–æ—Å–ª–µ–¥—Å—Ç–≤–∏—è –Ω–µ–ø–æ–ª–Ω–æ–π –¥–æ—Å—Ç–∞–≤–∫–∏",
                    "2 ‚úì –ü—Ä–µ–¥–ª–æ–∂–µ–Ω–æ –∏ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–æ —Ä–µ—à–µ–Ω–∏–µ —á–µ—Ä–µ–∑ Saga"
            ));

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –ú–ò–°–°–ò–Ø –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø –í–´–ü–û–õ–ù–ï–ù–ê!");
            logger.info("   =========================================");
            logger.info("   –ü–†–û–ë–õ–ï–ú–ê: –ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏");
            logger.info("   –†–ï–®–ï–ù–ò–ï:  –ü–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ Saga");
            logger.info("   –†–ï–ó–£–õ–¨–¢–ê–¢: –î–æ—Å—Ç–∞–≤–∫–∞ 15 –º–∏–Ω –≤–º–µ—Å—Ç–æ 1 —á–∞—Å–∞");
            logger.info("   =========================================");

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            logger.error("‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê –í–´–ü–û–õ–ù–ï–ù–ò–Ø –ú–ò–°–°–ò–ò: {}", e.getMessage(), e);

            result.put("status", "MISSION_FAILED");
            result.put("endTime", LocalDateTime.now());
            result.put("error", e.getMessage());
            result.put("criticalIssue", "Transaction Saga Service –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω");
            result.put("recommendation", "–£–±–µ–¥–∏—Ç–µ—Å—å, —á—Ç–æ –ø–æ—Ä—Ç 8090 –æ—Ç–∫—Ä—ã—Ç –∏ Transaction Saga –∑–∞–ø—É—â–µ–Ω");

            failedTransactions.incrementAndGet();

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    // ============ –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–û–†–¢–ê–ú–ò (PowerShell –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω) ============

    @PostMapping("/ports/smart-release")
    @Operation(summary = "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤")
    public ResponseEntity<Map<String, Object>> smartReleasePorts() {
        logger.info("üß† –ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–û–ï –û–°–í–û–ë–û–ñ–î–ï–ù–ò–ï –ü–û–†–¢–û–í");

        Map<String, Object> result = new LinkedHashMap<>();
        List<String> actions = new ArrayList<>();

        int managedCount = 0;
        int releasedCount = 0;
        int alreadyFreeCount = 0;

        try {
            for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
                String serviceName = entry.getKey();
                int port = entry.getValue();

                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ª–∞—É–Ω—á–µ—Ä
                if ("Launcher Service".equals(serviceName)) {
                    actions.add("‚úÖ " + serviceName + " (–ø–æ—Ä—Ç " + port + "): —ç—Ç–æ –ª–∞—É–Ω—á–µ—Ä, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º");
                    managedCount++;
                    continue;
                }

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ—Ä—Ç –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
                boolean isManaged = isPortManagedByOrchestrator(port);

                if (isManaged) {
                    // –ü–æ—Ä—Ç —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º - –ù–ï –¢–†–û–ì–ê–ï–ú
                    actions.add("‚úÖ " + serviceName + " (–ø–æ—Ä—Ç " + port + "): —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º, –Ω–µ —Ç—Ä–æ–≥–∞–µ–º");
                    managedCount++;
                } else {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–Ω—è—Ç –ª–∏ –ø–æ—Ä—Ç
                    boolean isOccupied = isPortOpen(port);

                    if (isOccupied) {
                        // –ó–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º - –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —á–µ—Ä–µ–∑ PowerShell
                        logger.info("‚ö†Ô∏è  {} (–ø–æ—Ä—Ç {}) –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º, –æ—Å–≤–æ–±–æ–∂–¥–∞—é...", serviceName, port);

                        boolean released = releasePortWithPowerShell(port);
                        if (released) {
                            actions.add("üîß " + serviceName + " (–ø–æ—Ä—Ç " + port + "): –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω –æ—Ç –≤–Ω–µ—à–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞");
                            releasedCount++;
                            killedExternalProcesses.incrementAndGet();
                            logger.info("‚úÖ –ü–æ—Ä—Ç {} –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω", port);
                        } else {
                            actions.add("‚ùå " + serviceName + " (–ø–æ—Ä—Ç " + port + "): –Ω–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å");
                            logger.warn("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {}", port);
                        }
                    } else {
                        // –ü–æ—Ä—Ç —Å–≤–æ–±–æ–¥–µ–Ω
                        actions.add("‚úÖ " + serviceName + " (–ø–æ—Ä—Ç " + port + "): —É–∂–µ —Å–≤–æ–±–æ–¥–µ–Ω");
                        alreadyFreeCount++;
                    }
                }
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            result.put("strategy", "–ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–µ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ: –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —Ç–æ–ª—å–∫–æ –≤–Ω–µ—à–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã");
            result.put("totalServices", KEFIR_SERVICES.size());
            result.put("managedServices", managedCount);
            result.put("releasedPorts", releasedCount);
            result.put("alreadyFreePorts", alreadyFreeCount);
            result.put("actions", actions);
            result.put("powerShellUsed", true);
            result.put("timestamp", LocalDateTime.now());

            logger.info("üìä –ò—Ç–æ–≥–∏: {}/{} —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è, {} –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–æ, {} —Å–≤–æ–±–æ–¥–Ω–æ",
                    managedCount, KEFIR_SERVICES.size(), releasedCount, alreadyFreeCount);

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–≥–æ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è –ø–æ—Ä—Ç–æ–≤: {}", e.getMessage(), e);

            result.put("error", e.getMessage());
            result.put("status", "FAILED");

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    @GetMapping("/ports/status")
    @Operation(summary = "–°—Ç–∞—Ç—É—Å –≤—Å–µ—Ö –ø–æ—Ä—Ç–æ–≤ KEFIR")
    public ResponseEntity<Map<String, Object>> getPortsStatus() {
        logger.info("üîç –ü–†–û–í–ï–†–ö–ê –°–¢–ê–¢–£–°–ê –í–°–ï–• –ü–û–†–¢–û–í KEFIR");

        Map<String, Object> result = new LinkedHashMap<>();
        Map<String, Map<String, Object>> portStatus = new LinkedHashMap<>();

        int managed = 0;
        int external = 0;
        int free = 0;

        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            String serviceName = entry.getKey();
            int port = entry.getValue();

            Map<String, Object> status = new LinkedHashMap<>();
            status.put("port", port);
            status.put("serviceName", serviceName);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ—Ä—Ç –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
            boolean isManaged = isPortManagedByOrchestrator(port);
            boolean isOccupied = isPortOpen(port);

            status.put("occupied", isOccupied);
            status.put("managed", isManaged);

            if (isManaged) {
                status.put("status", "MANAGED");
                status.put("action", "–ù–µ —Ç—Ä–æ–≥–∞—Ç—å (—É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º)");
                managed++;
            } else if (isOccupied) {
                status.put("status", "EXTERNAL");
                status.put("action", "–ú–æ–∂–Ω–æ –æ—Å–≤–æ–±–æ–¥–∏—Ç—å —á–µ—Ä–µ–∑ /ports/smart-release");
                external++;
            } else {
                status.put("status", "FREE");
                status.put("action", "–°–≤–æ–±–æ–¥–µ–Ω –¥–ª—è –∑–∞–ø—É—Å–∫–∞");
                free++;
            }

            portStatus.put(serviceName, status);
        }

        result.put("portStatus", portStatus);
        result.put("summary", Map.of(
                "total", KEFIR_SERVICES.size(),
                "managed", managed,
                "external", external,
                "free", free
        ));
        result.put("recommendation", getPortsRecommendation(managed, external, free));
        result.put("timestamp", LocalDateTime.now());

        return ResponseEntity.ok(result);
    }

    // ============ –°–ï–†–í–ò–°–´ –î–õ–Ø –ú–ò–°–°–ò–ò ============

    @PostMapping("/services/start-mission")
    @Operation(summary = "–ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏")
    public ResponseEntity<Map<String, Object>> startMissionServices() {
        logger.info("üöÄ –ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–û–í –î–õ–Ø –í–´–ü–û–õ–ù–ï–ù–ò–Ø –ú–ò–°–°–ò–ò");

        Map<String, Object> result = new LinkedHashMap<>();
        List<Map<String, Object>> serviceResults = new ArrayList<>();

        try {
            // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å–µ—Ä–≤–∏—Å—ã, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –¥–ª—è –º–∏—Å—Å–∏–∏
            List<com.kefir.logistics.launcher_service.model.enums.ServiceType> missionServices =
                    Arrays.asList(
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.COLLECTOR_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.OFFICE_SERVICE
                    );

            // –ó–∞–ø—É—Å–∫–∞–µ–º –∫–∞–∂–¥—ã–π —Å–µ—Ä–≤–∏—Å
            for (com.kefir.logistics.launcher_service.model.enums.ServiceType serviceType : missionServices) {
                Map<String, Object> serviceResult = new LinkedHashMap<>();
                serviceResult.put("service", serviceType.getDisplayName());
                serviceResult.put("port", serviceType.getDefaultPort());

                try {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω –ª–∏ —É–∂–µ
                    boolean isRunning = serviceOrchestrator.isServiceRunning(serviceType);
                    boolean isHealthy = serviceOrchestrator.isServiceHealthy(serviceType);

                    if (isRunning && isHealthy) {
                        serviceResult.put("status", "ALREADY_RUNNING");
                        serviceResult.put("message", "–°–µ—Ä–≤–∏—Å —É–∂–µ –∑–∞–ø—É—â–µ–Ω –∏ –∑–¥–æ—Ä–æ–≤");
                        serviceResult.put("action", "–ü—Ä–æ–ø—É—â–µ–Ω");
                        logger.info("‚úÖ {} —É–∂–µ –∑–∞–ø—É—â–µ–Ω", serviceType.getDisplayName());
                    } else if (isRunning && !isHealthy) {
                        // –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–∑–¥–æ—Ä–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å
                        serviceResult.put("status", "RESTARTING");
                        serviceResult.put("message", "–°–µ—Ä–≤–∏—Å –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –∑–¥–æ—Ä–æ–≤. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞—é...");

                        ServiceStatusDTO restartResult = serviceOrchestrator.restartService(serviceType);
                        serviceResult.put("result", restartResult.getState().toString());
                        serviceResult.put("action", "–ü–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω");

                        logger.info("üîÑ {} –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω", serviceType.getDisplayName());
                    } else {
                        // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å
                        serviceResult.put("status", "STARTING");
                        serviceResult.put("message", "–ó–∞–ø—É—Å–∫–∞—é —Å–µ—Ä–≤–∏—Å...");

                        ServiceStatusDTO startResult = serviceOrchestrator.startService(serviceType);
                        serviceResult.put("result", startResult.getState().toString());
                        serviceResult.put("action", "–ó–∞–ø—É—â–µ–Ω");

                        logger.info("üöÄ {} –∑–∞–ø—É—â–µ–Ω", serviceType.getDisplayName());
                    }

                } catch (Exception e) {
                    serviceResult.put("status", "FAILED");
                    serviceResult.put("error", e.getMessage());
                    serviceResult.put("action", "–û—à–∏–±–∫–∞");
                    logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ {}: {}", serviceType.getDisplayName(), e.getMessage());
                }

                serviceResults.add(serviceResult);

                // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—É—Å–∫–∞–º–∏
                if (!serviceType.equals(missionServices.get(missionServices.size() - 1))) {
                    Thread.sleep(3000);
                }
            }

            // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
            logger.info("‚è≥ –î–∞—é –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é —Å–µ—Ä–≤–∏—Å–æ–≤ (10 —Å–µ–∫—É–Ω–¥)...");
            Thread.sleep(10000);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            long successful = serviceResults.stream()
                    .filter(r -> "ALREADY_RUNNING".equals(r.get("status")) ||
                            "STARTING".equals(r.get("status")) ||
                            "RESTARTING".equals(r.get("status")))
                    .count();

            result.put("services", serviceResults);
            result.put("total", missionServices.size());
            result.put("successful", successful);
            result.put("missionReady", successful == missionServices.size());
            result.put("timestamp", LocalDateTime.now());
            result.put("nextStep", successful == missionServices.size() ?
                    "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /mission/complete –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏" :
                    "–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –∏ –∏—Å–ø—Ä–∞–≤—å—Ç–µ –æ—à–∏–±–∫–∏ –∑–∞–ø—É—Å–∫–∞");

            logger.info("üìä –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω: {}/{} —É—Å–ø–µ—à–Ω–æ",
                    successful, missionServices.size());

            return ResponseEntity.ok(result);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏: {}", e.getMessage(), e);

            result.put("error", e.getMessage());
            result.put("status", "FAILED");

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(result);
        }
    }

    @GetMapping("/services/mission-status")
    @Operation(summary = "–°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏")
    public ResponseEntity<Map<String, Object>> getMissionServicesStatus() {
        logger.info("üîç –°–¢–ê–¢–£–° –°–ï–†–í–ò–°–û–í –î–õ–Ø –ú–ò–°–°–ò–ò");

        Map<String, Object> result = new LinkedHashMap<>();
        Map<String, Map<String, Object>> servicesStatus = new LinkedHashMap<>();

        // –ö–ª—é—á–µ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –º–∏—Å—Å–∏–∏
        Map<String, Integer> missionServices = new LinkedHashMap<String, Integer>() {{
            put("Transaction Saga Service", 8090);
            put("Warehouse Service", 8082);
            put("Shopping Cart Service", 8083);
            put("Collector Service", 8086);
            put("Office Management Service", 8085);
        }};

        boolean allReady = true;
        List<String> notReady = new ArrayList<>();

        for (Map.Entry<String, Integer> entry : missionServices.entrySet()) {
            String serviceName = entry.getKey();
            int port = entry.getValue();

            Map<String, Object> status = new LinkedHashMap<>();
            status.put("port", port);
            status.put("serviceName", serviceName);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Ä—Ç
            boolean portOpen = isPortOpen(port);
            status.put("portOpen", portOpen);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ –µ—Å–ª–∏ –ø–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç
            if (portOpen) {
                try {
                    // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
                    String[] endpoints = {
                            "http://localhost:" + port + "/actuator/health",
                            "http://localhost:" + port + "/health",
                            "http://localhost:" + port + "/",
                            "http://localhost:" + port + "/api/health"
                    };

                    boolean healthy = false;
                    for (String endpoint : endpoints) {
                        try {
                            ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);
                            if (response.getStatusCode().is2xxSuccessful()) {
                                healthy = true;
                                break;
                            }
                        } catch (Exception e) {
                            // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º
                        }
                    }

                    status.put("healthy", healthy);
                    status.put("status", healthy ? "READY" : "RUNNING_BUT_UNHEALTHY");

                    if (!healthy) {
                        allReady = false;
                        notReady.add(serviceName + " (–∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç)");
                    }

                } catch (Exception e) {
                    status.put("healthy", false);
                    status.put("status", "RUNNING_BUT_ERROR");
                    allReady = false;
                    notReady.add(serviceName + " (–æ—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏)");
                }
            } else {
                status.put("healthy", false);
                status.put("status", "NOT_RUNNING");
                allReady = false;
                notReady.add(serviceName + " (–Ω–µ –∑–∞–ø—É—â–µ–Ω)");
            }

            servicesStatus.put(serviceName, status);
        }

        result.put("services", servicesStatus);
        result.put("allReady", allReady);
        result.put("notReady", notReady);
        result.put("missionPossible", isPortOpen(8090)); // Saga –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–µ–Ω
        result.put("timestamp", LocalDateTime.now());

        if (!isPortOpen(8090)) {
            result.put("critical", "Transaction Saga Service –Ω–µ –∑–∞–ø—É—â–µ–Ω (–ø–æ—Ä—Ç 8090)");
            result.put("recommendation", "–ë–µ–∑ Saga –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏—Å—Å–∏–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ. –ó–∞–ø—É—Å—Ç–∏—Ç–µ –µ–≥–æ –ø–µ—Ä–≤—ã–º.");
        } else if (!allReady) {
            result.put("recommendation", "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /services/start-mission –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");
        } else {
            result.put("recommendation", "–í—Å–µ —Å–µ—Ä–≤–∏—Å—ã –≥–æ—Ç–æ–≤—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /mission/complete –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏");
        }

        return ResponseEntity.ok(result);
    }

    // ============ –£–¢–ò–õ–ò–¢–ù–´–ï –ú–ï–¢–û–î–´ ============

    private void initializeServiceInfos() {
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ—Ä–≤–∏—Å–∞—Ö...");

        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            String serviceName = entry.getKey();
            int port = entry.getValue();

            boolean isManaged = !"Launcher Service".equals(serviceName);
            ServiceInfo info = new ServiceInfo(serviceName, port, isManaged);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ç–µ–∫—É—â–µ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
            info.isRunning = isPortOpen(port);
            info.lastChecked = LocalDateTime.now();

            serviceInfos.put(serviceName, info);

            if (info.isRunning) {
                logger.debug("   ‚úÖ {} (–ø–æ—Ä—Ç {}) –∑–∞–ø—É—â–µ–Ω", serviceName, port);
            }
        }

        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {} —Å–µ—Ä–≤–∏—Å–æ–≤", serviceInfos.size());
    }

    private void createDirectories() {
        try {
            Path reportDir = Paths.get(reportsDirectory);
            if (!Files.exists(reportDir)) {
                Files.createDirectories(reportDir);
                logger.info("–°–æ–∑–¥–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤: {}", reportDir.toAbsolutePath());
            }
        } catch (IOException e) {
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {}", e.getMessage());
        }
    }

    private void startBackgroundTasks() {
        // –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∫–ª—é—á–µ–≤—ã—Ö –ø–æ—Ä—Ç–æ–≤
        scheduler.scheduleAtFixedRate(() -> {
            try {
                monitorMissionPorts();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –ø–æ—Ä—Ç–æ–≤: {}", e.getMessage());
            }
        }, 1, 2, TimeUnit.MINUTES);

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è Saga
        scheduler.scheduleAtFixedRate(() -> {
            try {
                checkSagaHealth();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ Saga: {}", e.getMessage());
            }
        }, 30, 60, TimeUnit.SECONDS);

        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ—Ä–≤–∏—Å–∞—Ö
        scheduler.scheduleAtFixedRate(() -> {
            try {
                updateServiceInfos();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–µ—Ä–≤–∏—Å–∞—Ö: {}", e.getMessage());
            }
        }, 2, 5, TimeUnit.MINUTES);

        logger.info("üöÄ –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–∞ –∑–∞–ø—É—â–µ–Ω—ã");
    }

    private void scheduleAutoStart(String scenarioType, long delayMs) {
        scheduler.schedule(() -> {
            try {
                logger.info("‚è∞ –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è: {}", scenarioType);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã
                boolean sagaReady = isPortOpen(8090);
                if (!sagaReady) {
                    logger.warn("‚ùå Transaction Saga –Ω–µ –∑–∞–ø—É—â–µ–Ω. –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –æ—Ç–º–µ–Ω–µ–Ω.");
                    return;
                }

                // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π —Å—Ü–µ–Ω–∞—Ä–∏–π
                switch (scenarioType.toLowerCase()) {
                    case "mission":
                    case "complete":
                        completeMission();
                        break;
                    case "problem":
                        demonstrateMissionProblem();
                        break;
                    case "solution":
                        demonstrateMissionSolution();
                        break;
                    default:
                        logger.warn("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Ç–∏–ø —Å—Ü–µ–Ω–∞—Ä–∏—è –¥–ª—è –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–∞: {}", scenarioType);
                }

            } catch (Exception e) {
                logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–µ —Å—Ü–µ–Ω–∞—Ä–∏—è: {}", e.getMessage());
            }
        }, delayMs, TimeUnit.MILLISECONDS);
    }

    private void stopNonManagedProcesses() {
        logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –ù–ï —É–ø—Ä–∞–≤–ª—è–µ–º—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...");

        int stopped = 0;
        for (Map.Entry<Integer, ServiceProcessInfo> entry : runningProcesses.entrySet()) {
            ServiceProcessInfo info = entry.getValue();

            if (!info.isManaged) {
                try {
                    logger.info("–û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é {} (–ø–æ—Ä—Ç {}, PID: {})",
                            info.serviceName, info.port, info.pid);

                    if (info.process != null && info.process.isAlive()) {
                        info.process.destroy();
                        if (info.process.waitFor(3, TimeUnit.SECONDS)) {
                            stopped++;
                            logger.info("‚úÖ {} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", info.serviceName);
                        }
                    }
                } catch (Exception e) {
                    logger.warn("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å {}: {}", info.serviceName, e.getMessage());
                }
            }
        }

        runningProcesses.clear();
        logger.info("–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–æ {} –Ω–µ —É–ø—Ä–∞–≤–ª—è–µ–º—ã—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤", stopped);
    }

    private void releaseExternalPortsForMission() {
        logger.info("üßπ –û—Å–≤–æ–±–æ–∂–¥–∞—é –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏...");

        List<Integer> missionPorts = Arrays.asList(8090, 8082, 8083, 8086, 8085);

        for (Integer port : missionPorts) {
            String serviceName = getServiceNameByPort(port);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ—Ä—Ç –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
            boolean isManaged = isPortManagedByOrchestrator(port);

            if (!isManaged) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–Ω—è—Ç –ª–∏ –ø–æ—Ä—Ç
                boolean isOccupied = isPortOpen(port);

                if (isOccupied) {
                    logger.info("‚ö†Ô∏è  {} (–ø–æ—Ä—Ç {}) –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º, –æ—Å–≤–æ–±–æ–∂–¥–∞—é...", serviceName, port);
                    boolean released = releasePortWithPowerShell(port);

                    if (released) {
                        logger.info("‚úÖ –ü–æ—Ä—Ç {} –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω", port);
                        killedExternalProcesses.incrementAndGet();
                    } else {
                        logger.warn("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {}", port);
                    }
                }
            }
        }
    }

    private boolean checkMissionServicesReady() {
        int[] missionPorts = {8090, 8082, 8083, 8086, 8085};

        for (int port : missionPorts) {
            if (!isPortOpen(port)) {
                logger.warn("‚ùå –ü–æ—Ä—Ç {} –Ω–µ –æ—Ç–∫—Ä—ã—Ç", port);
                return false;
            }
        }

        return true;
    }

    private List<String> getRequiredMissionServices() {
        return Arrays.asList(
                "Transaction Saga Service (–ø–æ—Ä—Ç 8090) - –ö–†–ò–¢–ò–ß–ï–°–ö–ò",
                "Warehouse Service (–ø–æ—Ä—Ç 8082)",
                "Shopping Cart Service (–ø–æ—Ä—Ç 8083)",
                "Collector Service (–ø–æ—Ä—Ç 8086)",
                "Office Management Service (–ø–æ—Ä—Ç 8085)"
        );
    }

    private List<String> createProblemScenario() {
        List<String> steps = new ArrayList<>();

        steps.add("1. üì± –ö–ª–∏–µ–Ω—Ç –∑–∞–∫–∞–∑—ã–≤–∞–µ—Ç 5 —Ç–æ–≤–∞—Ä–æ–≤ —á–µ—Ä–µ–∑ –º–æ–±–∏–ª—å–Ω–æ–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ");
        steps.add("2. üí≥ –ü—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç –æ–ø–ª–∞—Ç–∞, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–∞—á–∏–Ω–∞–µ—Ç—Å—è –≤ Transaction Saga");
        steps.add("3. üè≠ –°–±–æ—Ä—â–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ —Å–æ–±—Ä–∞—Ç—å –∑–∞–∫–∞–∑ –Ω–∞ —Å–∫–ª–∞–¥–µ");
        steps.add("4. üì¶ –°–±–æ—Ä—â–∏–∫ —Å–∫–∞–Ω–∏—Ä—É–µ—Ç –ø–µ—Ä–≤—ã–µ 3 —Ç–æ–≤–∞—Ä–∞ - –æ–Ω–∏ –µ—Å—Ç—å –≤ –Ω–∞–ª–∏—á–∏–∏");
        steps.add("5. ‚ö†Ô∏è 4-–π —Ç–æ–≤–∞—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤ —Å–∏—Å—Ç–µ–º–µ (–æ—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è)");
        steps.add("6. üìû –°–±–æ—Ä—â–∏–∫ –Ω–∞–∂–∏–º–∞–µ—Ç –∫–Ω–æ–ø–∫—É '–ü—Ä–æ–±–ª–µ–º–∞' - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –æ—Ñ–∏—Å");
        steps.add("7. üë®‚Äçüíº –û—Ñ–∏—Å–º–µ–Ω –∑–≤–æ–Ω–∏—Ç –∫–ª–∏–µ–Ω—Ç—É: '–¢–æ–≤–∞—Ä X –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç, –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å —Å 3 —Ç–æ–≤–∞—Ä–∞–º–∏?'");
        steps.add("8. ‚úÖ –ö–ª–∏–µ–Ω—Ç —Å–æ–≥–ª–∞—à–∞–µ—Ç—Å—è –ø–æ–ª—É—á–∏—Ç—å 3 —Ç–æ–≤–∞—Ä–∞ —Å–µ–π—á–∞—Å");
        steps.add("9. üîÑ Transaction Saga –ø–æ–ª—É—á–∞–µ—Ç –∫–æ–º–∞–Ω–¥—É 'partial_commit'");
        steps.add("10. üí∞ –î–µ–Ω—å–≥–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è —Ç–æ–ª—å–∫–æ –∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä");
        steps.add("11. üöö –ö–ª–∏–µ–Ω—Ç—É –ø—Ä–∏–≤–æ–∑—è—Ç 3 —Ç–æ–≤–∞—Ä–∞ –≤–º–µ—Å—Ç–æ 5");
        steps.add("12. üò† –ù–∞ —Å–ª–µ–¥—É—é—â–∏–π –¥–µ–Ω—å –∫–ª–∏–µ–Ω—Ç –∑–≤–æ–Ω–∏—Ç: '–ì–¥–µ –æ—Å—Ç–∞–ª—å–Ω—ã–µ 2 —Ç–æ–≤–∞—Ä–∞? –Ø –∏—Ö –æ–ø–ª–∞—Ç–∏–ª!'");
        steps.add("13. üîç –û—Ñ–∏—Å –ø—Ä–æ–≤–µ—Ä—è–µ—Ç: 2 —Ç–æ–≤–∞—Ä–∞ –Ω–µ –±—ã–ª–∏ –ø—Ä–æ–±–∏—Ç—ã —Å–±–æ—Ä—â–∏–∫–æ–º");
        steps.add("14. üè¨ –ü—Ä–æ–±–ª–µ–º–∞: —ç—Ç–∏ —Ç–æ–≤–∞—Ä—ã –º–æ–≥—É—Ç –±—ã—Ç—å –Ω–∞ –¥—Ä—É–≥–∏—Ö —Å–∫–ª–∞–¥–∞—Ö –≥–æ—Ä–æ–¥–∞");
        steps.add("15. üìû –û—Ñ–∏—Å –æ–±–∑–≤–∞–Ω–∏–≤–∞–µ—Ç 3 —Å–∫–ª–∞–¥–∞, –Ω–∞—Ö–æ–¥–∏—Ç —Ç–æ–≤–∞—Ä—ã –Ω–∞ —Ä–∞–∑–Ω—ã—Ö");
        steps.add("16. üöó –ö—É—Ä—å–µ—Ä –¥–æ–ª–∂–µ–Ω –æ–±—ä–µ—Ö–∞—Ç—å 3 —Å–∫–ª–∞–¥–∞ –¥–ª—è —Å–±–æ—Ä–∞ 2 —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("17. ‚è∞ –ò—Ç–æ–≥: –¥–æ—Å—Ç–∞–≤–∫–∞ –∑–∞–Ω–∏–º–∞–µ—Ç 1 –ß–ê–° –≤–º–µ—Å—Ç–æ –æ–±—ã—á–Ω—ã—Ö 15 –ú–ò–ù–£–¢");
        steps.add("18. üí∏ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã: –±–µ–Ω–∑–∏–Ω, –≤—Ä–µ–º—è –∫—É—Ä—å–µ—Ä–∞, –Ω–µ–¥–æ–≤–æ–ª—å–Ω—ã–π –∫–ª–∏–µ–Ω—Ç");

        return steps;
    }

    private Map<String, Object> analyzeConsequences() {
        Map<String, Object> consequences = new LinkedHashMap<>();

        consequences.put("time", "–£–≤–µ–ª–∏—á–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ—Å—Ç–∞–≤–∫–∏ –≤ 4 —Ä–∞–∑–∞ (15 –º–∏–Ω ‚Üí 1 —á–∞—Å)");
        consequences.put("cost", "–†–æ—Å—Ç –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤ –Ω–∞ 300%");
        consequences.put("customerSatisfaction", "–†–µ–∑–∫–æ–µ —Å–Ω–∏–∂–µ–Ω–∏–µ (–∫–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç –Ω–µ–ø–æ–ª–Ω—ã–π –∑–∞–∫–∞–∑)");
        consequences.put("processComplexity", "–£—Å–ª–æ–∂–Ω–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ (–æ–±–∑–≤–æ–Ω —Å–∫–ª–∞–¥–æ–≤, —Ä—É—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞)");
        consequences.put("reliability", "–ù–∏–∑–∫–∞—è (–Ω–µ–ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö)");
        consequences.put("scalability", "–ü–ª–æ—Ö–∞—è (—Ä—É—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞ –Ω–µ –º–∞—Å—à—Ç–∞–±–∏—Ä—É–µ—Ç—Å—è)");

        return consequences;
    }

    private Map<String, Object> getSolutionPhilosophy() {
        Map<String, Object> philosophy = new LinkedHashMap<>();

        philosophy.put("coreIdea", "–ü—Ä–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –æ—à–∏–±–∫–∞—Ö –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å, —á–µ–º –ø—ã—Ç–∞—Ç—å—Å—è –µ–≥–æ –ø–æ—á–∏–Ω–∏—Ç—å");
        philosophy.put("analogy", "–ö–∞–∫ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–∞ –∑–∞–≤–∏—Å—à–µ–≥–æ –∫–æ–º–ø—å—é—Ç–µ—Ä–∞ –≤–º–µ—Å—Ç–æ –ø–æ–∏—Å–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –±–∞–≥–∞ –≤ –∫–æ–¥–µ");
        philosophy.put("principle", "–¶–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å –∏ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º–æ—Å—Ç—å –≤–∞–∂–Ω–µ–µ —á–∞—Å—Ç–∏—á–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏");
        philosophy.put("approach", "–ü–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏");
        philosophy.put("technology", "Transaction Saga Pattern –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã–º–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è–º–∏");

        return philosophy;
    }

    private List<String> createSolutionScenario() {
        List<String> steps = new ArrayList<>();

        steps.add("1. üì± –ö–ª–∏–µ–Ω—Ç –∑–∞–∫–∞–∑—ã–≤–∞–µ—Ç 5 —Ç–æ–≤–∞—Ä–æ–≤ —á–µ—Ä–µ–∑ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ");
        steps.add("2. üí≥ –ù–∞—á–∏–Ω–∞–µ—Ç—Å—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –≤ Transaction Saga (–ø–æ—Ä—Ç 8090)");
        steps.add("3. üè≠ –°–±–æ—Ä—â–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ, –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä–∫—É");
        steps.add("4. ‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä (–æ—à–∏–±–∫–∞ —Å–∫–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è)");
        steps.add("5. üìû –°–±–æ—Ä—â–∏–∫ –Ω–∞–∂–∏–º–∞–µ—Ç '–ü—Ä–æ–±–ª–µ–º–∞' - —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –æ—Ñ–∏—Å");
        steps.add("6. üë®‚Äçüíº –û—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –¥–ª—è —É—Ç–æ—á–Ω–µ–Ω–∏–π");
        steps.add("7. üîÑ Transaction Saga –ø–æ–ª—É—á–∞–µ—Ç —Å–æ–±—ã—Ç–∏–µ 'ERROR_DETECTED'");
        steps.add("8. ‚èπÔ∏è Saga –≤—ã–ø–æ–ª–Ω—è–µ—Ç –∫–æ–º–ø–µ–Ω—Å–∏—Ä—É—é—â–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ –¥–ª—è –í–°–ï–• —à–∞–≥–æ–≤");
        steps.add("9. üí∞ –í–°–ï –¥–µ–Ω—å–≥–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –∫–ª–∏–µ–Ω—Ç—É (–ø–æ–ª–Ω—ã–π –≤–æ–∑–≤—Ä–∞—Ç)");
        steps.add("10. ‚úÖ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –ø–æ–º–µ—á–∞–µ—Ç—Å—è –∫–∞–∫ 'COMPENSATED' (–æ—Ç–º–µ–Ω–µ–Ω–∞ –ø–æ–ª–Ω–æ—Å—Ç—å—é)");
        steps.add("11. üÜï Saga —Å–æ–∑–¥–∞–µ—Ç –ù–û–í–£–Æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é —Å —Ç–µ–º–∏ –∂–µ –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏");
        steps.add("12. üîÑ –°–±–æ—Ä—â–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç –Ω–æ–≤–æ–µ –∑–∞–¥–∞–Ω–∏–µ —Å —Ç–µ–º –∂–µ —Å–ø–∏—Å–∫–æ–º —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("13. üìã –°–±–æ—Ä—â–∏–∫ –ü–ï–†–ï–ü–†–û–í–ï–†–Ø–ï–¢ –í–°–ï 5 —Ç–æ–≤–∞—Ä–æ–≤ –∑–∞–Ω–æ–≤–æ");
        steps.add("14. ‚úÖ –í—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã (4 –∏–∑ 5) —É—Å–ø–µ—à–Ω–æ —Å–∫–∞–Ω–∏—Ä—É—é—Ç—Å—è");
        steps.add("15. üí≥ –ö–ª–∏–µ–Ω—Ç –æ–ø–ª–∞—á–∏–≤–∞–µ—Ç —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω—ã–µ 4 —Ç–æ–≤–∞—Ä–∞");
        steps.add("16. üöö –î–æ—Å—Ç–∞–≤–∫–∞ –∑–∞–Ω–∏–º–∞–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ 15 –ú–ò–ù–£–¢");
        steps.add("17. üòä –ö–ª–∏–µ–Ω—Ç –¥–æ–≤–æ–ª–µ–Ω: –ø–æ–ª—É—á–∏–ª –ø–æ–ª–Ω—ã–π (–¥–æ—Å—Ç—É–ø–Ω—ã–π) –∑–∞–∫–∞–∑ –±—ã—Å—Ç—Ä–æ");
        steps.add("18. üìä –°–∏—Å—Ç–µ–º–∞ —á–∏—Å—Ç–∞: –Ω–µ—Ç '–≤–∏—Å—è—â–∏—Ö' —Ç–æ–≤–∞—Ä–æ–≤, –≤—Å–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω—ã");

        return steps;
    }

    private Map<String, Object> getSolutionBenefits() {
        Map<String, Object> benefits = new LinkedHashMap<>();

        benefits.put("time", "–°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–µ –≤—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏ (15 –º–∏–Ω—É—Ç)");
        benefits.put("cost", "–ù–æ—Ä–º–∞–ª—å–Ω—ã–µ –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ä–∞—Å—Ö–æ–¥—ã");
        benefits.put("customerSatisfaction", "–í—ã—Å–æ–∫–∞—è (–∫–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç –ø–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π –∑–∞–∫–∞–∑)");
        benefits.put("processComplexity", "–ü—Ä–æ—Å—Ç–æ–π –∏ –ø—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π –ø—Ä–æ—Ü–µ—Å—Å");
        benefits.put("reliability", "–í—ã—Å–æ–∫–∞—è (–≥–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø—Ä–∏ –ª—é–±—ã—Ö –æ—à–∏–±–∫–∞—Ö)");
        benefits.put("scalability", "–•–æ—Ä–æ—à–∞—è (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø—Ä–æ—Ü–µ—Å—Å, –±–µ–∑ —Ä—É—á–Ω–æ–π —Ä–∞–±–æ—Ç—ã)");
        benefits.put("debugging", "–£–ø—Ä–æ—â–µ–Ω–Ω–æ–µ –æ—Ç–ª–∞–¥–∫–∞ (–∫–∞–∂–¥–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ–∑–∞–≤–∏—Å–∏–º–∞)");
        benefits.put("dataIntegrity", "–ì–∞—Ä–∞–Ω—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö");

        return benefits;
    }

    private Map<String, Object> createSolutionComparison() {
        Map<String, Object> comparison = new LinkedHashMap<>();

        Map<String, Object> oldWay = new LinkedHashMap<>();
        oldWay.put("name", "–ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏");
        oldWay.put("time", "1 —á–∞—Å");
        oldWay.put("cost", "–í—ã—Å–æ–∫–∞—è (+300%)");
        oldWay.put("customer", "–ù–µ–¥–æ–≤–æ–ª—å–Ω—ã–π (–Ω–µ–ø–æ–ª–Ω—ã–π –∑–∞–∫–∞–∑)");
        oldWay.put("process", "–°–ª–æ–∂–Ω—ã–π (—Ä—É—á–Ω–∞—è —Ä–∞–±–æ—Ç–∞)");
        oldWay.put("reliability", "–ù–∏–∑–∫–∞—è");

        Map<String, Object> newWay = new LinkedHashMap<>();
        newWay.put("name", "–ü–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ Saga");
        newWay.put("time", "15 –º–∏–Ω—É—Ç");
        newWay.put("cost", "–ù–æ—Ä–º–∞–ª—å–Ω–∞—è");
        newWay.put("customer", "–î–æ–≤–æ–ª—å–Ω—ã–π (–ø–æ–ª–Ω—ã–π –¥–æ—Å—Ç—É–ø–Ω—ã–π –∑–∞–∫–∞–∑)");
        newWay.put("process", "–ü—Ä–æ—Å—Ç–æ–π (–∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π)");
        newWay.put("reliability", "–í—ã—Å–æ–∫–∞—è");
        newWay.put("philosophy", "–ü–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å –≤–º–µ—Å—Ç–æ –ø–æ—á–∏–Ω–∫–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–π –æ—à–∏–±–∫–∏");

        comparison.put("oldWay", oldWay);
        comparison.put("newWay", newWay);
        comparison.put("improvement", "–í—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏: -75%, –ó–∞—Ç—Ä–∞—Ç—ã: -75%, –£–¥–æ–≤–ª–µ—Ç–≤–æ—Ä–µ–Ω–Ω–æ—Å—Ç—å: +100%");
        comparison.put("technology", "Transaction Saga Pattern");

        return comparison;
    }

    private Map<String, Object> createMissionConclusions() {
        Map<String, Object> conclusions = new LinkedHashMap<>();

        conclusions.put("problemDemonstrated", true);
        conclusions.put("solutionDemonstrated", true);
        conclusions.put("comparisonProvided", true);
        conclusions.put("missionAccomplished", true);

        conclusions.put("keyLearnings", Arrays.asList(
                "1. –ß–∞—Å—Ç–∏—á–Ω–æ–µ –∑–∞–∫—Ä—ã—Ç–∏–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π –æ–ø–∞—Å–Ω–æ –¥–ª—è –∫–ª–∏–µ–Ω—Ç—Å–∫–æ–≥–æ –æ–ø—ã—Ç–∞",
                "2. Transaction Saga Pattern —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π",
                "3. –ü—Ä–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω—ã—Ö –æ—à–∏–±–∫–∞—Ö –±–µ–∑–æ–ø–∞—Å–Ω–µ–µ –ø–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å",
                "4. –¶–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö –≤–∞–∂–Ω–µ–µ —á–∞—Å—Ç–∏—á–Ω–æ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏",
                "5. –•–æ—Ä–æ—à–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –æ–∫—É–ø–∞–µ—Ç—Å—è –≤ –¥–æ–ª–≥–æ—Å—Ä–æ—á–Ω–æ–π –ø–µ—Ä—Å–ø–µ–∫—Ç–∏–≤–µ"
        ));

        conclusions.put("businessValue", "–°–æ–∫—Ä–∞—â–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ –¥–æ—Å—Ç–∞–≤–∫–∏ —Å 1 —á–∞—Å–∞ –¥–æ 15 –º–∏–Ω—É—Ç –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö");
        conclusions.put("technicalValue", "–ù–∞–¥–µ–∂–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ –≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–Ω–æ–π –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ");
        conclusions.put("customerValue", "–ü—Ä–µ–¥—Å–∫–∞–∑—É–µ–º—ã–π –∏ –∫–∞—á–µ—Å—Ç–≤–µ–Ω–Ω—ã–π —Å–µ—Ä–≤–∏—Å –¥–∞–∂–µ –ø—Ä–∏ —Å–±–æ—è—Ö");

        return conclusions;
    }

    private boolean verifySagaForMission() {
        int sagaPort = 8090;

        if (!isPortOpen(sagaPort)) {
            logger.error("‚ùå Transaction Saga –Ω–µ –∑–∞–ø—É—â–µ–Ω (–ø–æ—Ä—Ç {} –∑–∞–∫—Ä—ã—Ç)", sagaPort);
            return false;
        }

        // –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –æ—Ç Saga
        try {
            ResponseEntity<String> response = restTemplate.getForEntity(
                    "http://localhost:" + sagaPort + "/actuator/health",
                    String.class
            );

            if (response.getStatusCode().is2xxSuccessful()) {
                logger.info("‚úÖ Transaction Saga –∑–¥–æ—Ä–æ–≤ –∏ –æ—Ç–≤–µ—á–∞–µ—Ç");
                return true;
            } else {
                logger.warn("‚ö†Ô∏è Transaction Saga –∑–∞–ø—É—â–µ–Ω, –Ω–æ health check –≤–µ—Ä–Ω—É–ª {}", response.getStatusCode());
                return true; // –í—Å–µ —Ä–∞–≤–Ω–æ —Å—á–∏—Ç–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–º
            }

        } catch (Exception e) {
            logger.warn("‚ö†Ô∏è Transaction Saga –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ health check: {}", e.getMessage());
            return true; // –ü–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç - —Å—á–∏—Ç–∞–µ–º –¥–æ—Å—Ç—É–ø–Ω—ã–º
        }
    }

    private void monitorMissionPorts() {
        int[] missionPorts = {8090, 8082, 8083, 8086, 8085};

        for (int port : missionPorts) {
            boolean isOpen = isPortOpen(port);
            String serviceName = getServiceNameByPort(port);

            if (isOpen) {
                logger.debug("–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: {} (–ø–æ—Ä—Ç {}) ‚úÖ", serviceName, port);
            } else {
                logger.debug("–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥: {} (–ø–æ—Ä—Ç {}) ‚ùå", serviceName, port);
            }
        }
    }

    private void checkSagaHealth() {
        int sagaPort = 8090;

        if (!isPortOpen(sagaPort)) {
            logger.warn("‚ö†Ô∏è Transaction Saga Service (–ø–æ—Ä—Ç {}) –Ω–µ –∑–∞–ø—É—â–µ–Ω!", sagaPort);
            logger.warn("   –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è!");
            logger.warn("   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: cd TransactionSaga && mvn spring-boot:run -Dserver.port=8090");
        } else {
            logger.debug("Transaction Saga Service (–ø–æ—Ä—Ç {}) –∑–∞–ø—É—â–µ–Ω", sagaPort);
        }
    }

    private void updateServiceInfos() {
        for (ServiceInfo info : serviceInfos.values()) {
            boolean wasRunning = info.isRunning;
            info.isRunning = isPortOpen(info.port);
            info.lastChecked = LocalDateTime.now();

            if (wasRunning != info.isRunning) {
                logger.info("–ò–∑–º–µ–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è: {} (–ø–æ—Ä—Ç {}) {} -> {}",
                        info.name, info.port,
                        wasRunning ? "–∑–∞–ø—É—â–µ–Ω" : "–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω",
                        info.isRunning ? "–∑–∞–ø—É—â–µ–Ω" : "–æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
            }
        }
    }

    private boolean isPortManagedByOrchestrator(int port) {
        try {
            // –ü—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –ø–æ—Ä—Ç –≤ ServiceType
            com.kefir.logistics.launcher_service.model.enums.ServiceType serviceType =
                    com.kefir.logistics.launcher_service.model.enums.ServiceType.fromPort(port);

            return serviceOrchestrator.isServiceRunning(serviceType);

        } catch (IllegalArgumentException e) {
            // –ù–µ –Ω–∞–π–¥–µ–Ω ServiceType –¥–ª—è —ç—Ç–æ–≥–æ –ø–æ—Ä—Ç–∞
            return false;
        } catch (Exception e) {
            logger.debug("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ä—Ç–æ–º {}: {}", port, e.getMessage());
            return false;
        }
    }

    private String getServiceNameByPort(int port) {
        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            if (entry.getValue() == port) {
                return entry.getKey();
            }
        }
        return "Unknown Service (port " + port + ")";
    }

    private String getPortsRecommendation(int managed, int external, int free) {
        if (external > 0) {
            return "–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –≤–Ω–µ—à–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –Ω–∞ –ø–æ—Ä—Ç–∞—Ö KEFIR. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /ports/smart-release –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è";
        } else if (managed == KEFIR_SERVICES.size() - 1) { // –º–∏–Ω—É—Å –ª–∞—É–Ω—á–µ—Ä
            return "–í—Å–µ –ø–æ—Ä—Ç—ã —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º. –°–∏—Å—Ç–µ–º–∞ –≤ –∏–¥–µ–∞–ª—å–Ω–æ–º —Å–æ—Å—Ç–æ—è–Ω–∏–∏";
        } else if (free > 0) {
            return "–ï—Å—Ç—å —Å–≤–æ–±–æ–¥–Ω—ã–µ –ø–æ—Ä—Ç—ã. –ú–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã";
        } else {
            return "–°—Ç–∞—Ç—É—Å –ø–æ—Ä—Ç–æ–≤ –≤ –Ω–æ—Ä–º–µ";
        }
    }

    private boolean isPortOpen(int port) {
        try (Socket socket = new Socket()) {
            socket.connect(new InetSocketAddress("localhost", port), 1000);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private boolean releasePortWithPowerShell(int port) {
        return powerShellHelper.releasePortWithPowerShell(port);
    }

    private String getUptime() {
        Duration uptime = Duration.between(startTime, LocalDateTime.now());
        long hours = uptime.toHours();
        long minutes = uptime.toMinutes() % 60;
        long seconds = uptime.getSeconds() % 60;

        return String.format("%d —á %d –º–∏–Ω %d —Å–µ–∫", hours, minutes, seconds);
    }

    private String calculateSuccessRate() {
        if (totalTransactions.get() == 0) {
            return "100%";
        }

        double rate = (1 - (double)failedTransactions.get() / totalTransactions.get()) * 100;
        return String.format("%.1f%%", rate);
    }
}package com.kefir.logistics.launcher.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/api/v1/logs")
public class LogController {

    @GetMapping("/{serviceName}")
    public ResponseEntity<List<String>> getServiceLogs(
            @PathVariable String serviceName,
            @RequestParam(defaultValue = "100") int lines) {

        try {
            Path logFile = Paths.get("./logs/" + serviceName + ".log");
            if (Files.exists(logFile)) {
                List<String> allLines = Files.readAllLines(logFile);
                int startIndex = Math.max(0, allLines.size() - lines);
                List<String> lastLines = allLines.subList(startIndex, allLines.size());
                return ResponseEntity.ok(lastLines);
            } else {
                List<String> message = new ArrayList<>();
                message.add("Log file not found for service: " + serviceName);
                return ResponseEntity.ok(message);
            }
        } catch (IOException e) {
            List<String> error = new ArrayList<>();
            error.add("Error reading logs: " + e.getMessage());
            return ResponseEntity.internalServerError().body(error);
        }
    }

    @GetMapping("/{serviceName}/download")
    public ResponseEntity<Resource> downloadLogFile(@PathVariable String serviceName) {
        try {
            Path logFile = Paths.get("./logs/" + serviceName + ".log");
            if (Files.exists(logFile)) {
                Resource resource = new UrlResource(logFile.toUri());

                return ResponseEntity.ok()
                        .contentType(MediaType.APPLICATION_OCTET_STREAM)
                        .header(HttpHeaders.CONTENT_DISPOSITION,
                                "attachment; filename=\"" + serviceName + "-logs.log\"")
                        .body(resource);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (IOException e) {
            return ResponseEntity.internalServerError().build();
        }
    }

    @DeleteMapping("/{serviceName}")
    public ResponseEntity<String> clearServiceLogs(@PathVariable String serviceName) {
        try {
            Path logFile = Paths.get("./logs/" + serviceName + ".log");
            if (Files.exists(logFile)) {
                Files.write(logFile, new byte[0]);
                return ResponseEntity.ok("Logs cleared for service: " + serviceName);
            } else {
                return ResponseEntity.ok("Log file not found for service: " + serviceName);
            }
        } catch (IOException e) {
            return ResponseEntity.internalServerError()
                    .body("Error clearing logs: " + e.getMessage());
        }
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.service.ServiceOrchestrator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
public class MainController {

    @Autowired
    private ApplicationContext context;

    @GetMapping("/")
    public Map<String, Object> home() {
        Map<String, Object> response = new HashMap<>();
        response.put("service", "KEFIR Launcher Service");
        response.put("version", "1.0.0");
        response.put("status", "running");
        response.put("endpoints", Map.of(
                "root", "/",
                "health", "/health",
                "autoStart", "/autostart",
                "config", "/api/v1/config/info",
                "servicesStatus", "/api/v1/services/status",
                "startAll", "/api/v1/services/start-all (POST)",
                "listServices", "/api/v1/services/list"
        ));
        response.put("timestamp", System.currentTimeMillis());
        return response;
    }

    @GetMapping("/health")
    public Map<String, String> health() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "launcher-service");
        response.put("time", java.time.LocalDateTime.now().toString());
        return response;
    }

    @GetMapping("/autostart")
    public Map<String, Object> autoStart() {
        Map<String, Object> response = new HashMap<>();

        new Thread(() -> {
            try {
                // –ñ–¥–µ–º 1 —Å–µ–∫—É–Ω–¥—É –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º
                Thread.sleep(1000);

                // –ü–æ–ª—É—á–∞–µ–º ServiceOrchestrator –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ Spring
                ServiceOrchestrator orchestrator = context.getBean(ServiceOrchestrator.class);

                // –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
                orchestrator.startAllServices();

                System.out.println("Auto-start of all services completed");

            } catch (Exception e) {
                System.err.println("Error in auto-start: " + e.getMessage());
                e.printStackTrace();
            }
        }).start();

        response.put("status", "initiated");
        response.put("message", "Auto-start of all services has been initiated");
        response.put("checkStatus", "http://localhost:8099/api/v1/services/status");
        response.put("timestamp", System.currentTimeMillis());

        return response;
    }

    @GetMapping("/ping")
    public String ping() {
        return "pong";
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import com.kefir.logistics.launcher_service.service.ServiceOrchestrator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/services")
@Tag(name = "Service Management", description = "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞–º–∏ KEFIR")
public class ServiceController {

    private static final Logger logger = LoggerFactory.getLogger(ServiceController.class);

    private final ServiceOrchestrator serviceOrchestrator;

    @Autowired
    public ServiceController(ServiceOrchestrator serviceOrchestrator) {
        this.serviceOrchestrator = serviceOrchestrator;
    }

    @GetMapping("/health")
    @Operation(summary = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ ServiceController")
    public ResponseEntity<Map<String, Object>> health() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "KEFIR Launcher Service - Service Controller");
        response.put("timestamp", System.currentTimeMillis());
        response.put("version", "1.0.0");
        response.put("mission", "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–∞–º–∏ –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ —Ä–µ—à–µ–Ω–∏—è –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏");
        return ResponseEntity.ok(response);
    }

    @PostMapping("/start-all")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å—ã KEFIR")
    public ResponseEntity<Map<String, Object>> startAllServices() {
        logger.info("üöÄ –ó–ê–ü–†–û–°: –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤ KEFIR");

        try {
            List<ServiceStatusDTO> results = serviceOrchestrator.startAllServices();
            long successful = results.stream()
                    .filter(status -> status.getState() != null && status.getState().isRunning())
                    .count();

            Map<String, Object> response = new HashMap<>();
            response.put("message", "–ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤ –∏–Ω–∏—Ü–∏–∏—Ä–æ–≤–∞–Ω");
            response.put("totalServices", results.size());
            response.put("successful", successful);
            response.put("failed", results.size() - successful);
            response.put("successRate", String.format("%.1f%%", (successful * 100.0 / results.size())));
            response.put("mission", "–ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏–∏ –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏ –∏ –µ—ë —Ä–µ—à–µ–Ω–∏—è");
            response.put("timestamp", System.currentTimeMillis());
            response.put("nextSteps", List.of(
                    "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å: GET /api/v1/services/status",
                    "–ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–µ–º–æ –º–∏—Å—Å–∏–∏: POST /api/v1/demo/mission/complete"
            ));

            logger.info("‚úÖ –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω: {}/{} —É—Å–ø–µ—à–Ω–æ", successful, results.size());
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤: {}", e.getMessage(), e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("error", "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @PostMapping("/start-mission")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏")
    public ResponseEntity<Map<String, Object>> startMissionServices() {
        logger.info("üéØ –ó–ê–ü–†–û–°: –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏");

        try {
            List<ServiceStatusDTO> results = serviceOrchestrator.startMissionServices();
            long successful = results.stream()
                    .filter(status -> status.getState() != null && status.getState().isRunning())
                    .count();

            Map<String, Object> response = new HashMap<>();
            response.put("message", "–ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω");
            response.put("mission", "–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏ –∏ —Ä–µ—à–µ–Ω–∏—è —á–µ—Ä–µ–∑ Transaction Saga");
            response.put("criticalServices", List.of(
                    "Transaction Saga Service (–ø–æ—Ä—Ç 8090) - –ö–õ–Æ–ß–ï–í–û–ô –¥–ª—è —Ä–µ—à–µ–Ω–∏—è",
                    "Warehouse Service (–ø–æ—Ä—Ç 8082) - –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤",
                    "Shopping Cart Service (–ø–æ—Ä—Ç 8083) - –Ω–∞—á–∞–ª–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏",
                    "Collector Service (–ø–æ—Ä—Ç 8086) - –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å–±–æ—Ä—â–∏–∫–æ–º",
                    "Office Service (–ø–æ—Ä—Ç 8085) - —Å–≤—è–∑—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º"
            ));
            response.put("totalServices", results.size());
            response.put("successful", successful);
            response.put("sagaAvailable", successful > 0 && results.stream()
                    .anyMatch(s -> s.getServiceType() == ServiceType.SAGA_SERVICE && s.getState().isRunning()));
            response.put("timestamp", System.currentTimeMillis());
            response.put("readyForDemo", successful >= 5); // –ú–∏–Ω–∏–º—É–º 5 –∫–ª—é—á–µ–≤—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤

            if (response.get("readyForDemo").equals(true)) {
                response.put("nextStep", "POST /api/v1/demo/mission/complete - –≤—ã–ø–æ–ª–Ω–∏—Ç—å –ø–æ–ª–Ω—É—é –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—é –º–∏—Å—Å–∏–∏");
            } else {
                response.put("recommendation", "–ó–∞–ø—É—Å—Ç–∏—Ç–µ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏–µ —Å–µ—Ä–≤–∏—Å—ã –≤—Ä—É—á–Ω—É—é –∏–ª–∏ –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏");
            }

            logger.info("‚úÖ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏ –∑–∞–≤–µ—Ä—à–µ–Ω: {}/{} —É—Å–ø–µ—à–Ω–æ", successful, results.size());
            return ResponseEntity.ok(response);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏: {}", e.getMessage(), e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("error", "–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –º–∏—Å—Å–∏–∏");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("critical", "Transaction Saga Service (–ø–æ—Ä—Ç 8090) –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø—É—â–µ–Ω");
            errorResponse.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @PostMapping("/start/{serviceId}")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å")
    public ResponseEntity<ServiceStatusDTO> startService(@PathVariable String serviceId) {
        logger.info("üöÄ –ó–ê–ü–†–û–°: –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ {}", serviceId);

        try {
            ServiceType serviceType = ServiceType.fromId(serviceId);
            ServiceStatusDTO result = serviceOrchestrator.startService(serviceType);

            logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} –∑–∞–ø—É—â–µ–Ω: {}", serviceId, result.getState());
            return ResponseEntity.ok(result);

        } catch (IllegalArgumentException e) {
            logger.warn("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: {}", serviceId);

            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: " + serviceId);
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.badRequest().body(errorResponse);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ {}: {}", serviceId, e.getMessage());

            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞: " + e.getMessage());
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @PostMapping("/stop/{serviceId}")
    @Operation(summary = "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å")
    public ResponseEntity<ServiceStatusDTO> stopService(@PathVariable String serviceId) {
        logger.info("üõë –ó–ê–ü–†–û–°: –û—Å—Ç–∞–Ω–æ–≤–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ {}", serviceId);

        try {
            ServiceType serviceType = ServiceType.fromId(serviceId);
            ServiceStatusDTO result = serviceOrchestrator.stopService(serviceType);

            logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {}", serviceId, result.getState());
            return ResponseEntity.ok(result);

        } catch (IllegalArgumentException e) {
            logger.warn("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: {}", serviceId);

            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: " + serviceId);
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.badRequest().body(errorResponse);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ —Å–µ—Ä–≤–∏—Å–∞ {}: {}", serviceId, e.getMessage());

            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏: " + e.getMessage());
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @PostMapping("/restart/{serviceId}")
    @Operation(summary = "–ü–µ—Ä–µ–∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å")
    public ResponseEntity<ServiceStatusDTO> restartService(@PathVariable String serviceId) {
        logger.info("üîÑ –ó–ê–ü–†–û–°: –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–∞ {}", serviceId);

        try {
            ServiceType serviceType = ServiceType.fromId(serviceId);
            ServiceStatusDTO result = serviceOrchestrator.restartService(serviceType);

            logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω: {}", serviceId, result.getState());
            return ResponseEntity.ok(result);

        } catch (IllegalArgumentException e) {
            logger.warn("‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: {}", serviceId);

            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: " + serviceId);
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.badRequest().body(errorResponse);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞ —Å–µ—Ä–≤–∏—Å–∞ {}: {}", serviceId, e.getMessage());

            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞: " + e.getMessage());
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @GetMapping("/status")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤")
    public ResponseEntity<Map<String, Object>> getAllStatus() {
        logger.debug("üîç –ó–ê–ü–†–û–°: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");

        try {
            Map<ServiceType, ServiceStatusDTO> statusMap = serviceOrchestrator.getAllServiceStatuses();
            List<Map<String, Object>> services = new ArrayList<>();

            long runningCount = 0;
            long missionServicesRunning = 0;
            boolean sagaRunning = false;

            for (Map.Entry<ServiceType, ServiceStatusDTO> entry : statusMap.entrySet()) {
                Map<String, Object> serviceInfo = new HashMap<>();
                ServiceStatusDTO status = entry.getValue();

                serviceInfo.put("id", entry.getKey().getId());
                serviceInfo.put("name", entry.getKey().getDisplayName());
                serviceInfo.put("port", entry.getKey().getDefaultPort());
                serviceInfo.put("missionRole", getMissionRole(entry.getKey()));

                if (status.getState() != null) {
                    serviceInfo.put("state", status.getState().getCode());
                    serviceInfo.put("stateDescription", status.getState().getDescription());
                    serviceInfo.put("running", status.getState().isRunning());

                    if (status.getState().isRunning()) {
                        runningCount++;
                    }
                } else {
                    serviceInfo.put("state", "unknown");
                    serviceInfo.put("stateDescription", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ");
                    serviceInfo.put("running", false);
                }

                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–ª—é—á–µ–≤—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏
                if (isMissionCriticalService(entry.getKey())) {
                    serviceInfo.put("missionCritical", true);
                    if (status.getState() != null && status.getState().isRunning()) {
                        missionServicesRunning++;
                    }

                    if (entry.getKey() == ServiceType.SAGA_SERVICE && status.getState() != null && status.getState().isRunning()) {
                        sagaRunning = true;
                        serviceInfo.put("saga", true);
                    }
                } else {
                    serviceInfo.put("missionCritical", false);
                }

                serviceInfo.put("pid", status.getPid());
                serviceInfo.put("startedAt", status.getStartedAt());
                serviceInfo.put("lastChecked", status.getLastChecked());
                serviceInfo.put("errorMessage", status.getErrorMessage());
                serviceInfo.put("portOpen", status.isPortOpen());
                serviceInfo.put("managed", status.isManaged());

                services.add(serviceInfo);
            }

            Map<String, Object> response = new HashMap<>();
            response.put("services", services);
            response.put("total", services.size());
            response.put("running", runningCount);
            response.put("stopped", services.size() - runningCount);
            response.put("missionCriticalRunning", missionServicesRunning);
            response.put("sagaAvailable", sagaRunning);
            response.put("missionPossible", sagaRunning && missionServicesRunning >= 3); // Saga + –º–∏–Ω–∏–º—É–º 3 –∫–ª—é—á–µ–≤—ã—Ö
            response.put("timestamp", System.currentTimeMillis());
            response.put("mission", "–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏ –∏ —Ä–µ—à–µ–Ω–∏—è —á–µ—Ä–µ–∑ Transaction Saga");

            if (!sagaRunning) {
                response.put("criticalWarning", "Transaction Saga Service –Ω–µ –∑–∞–ø—É—â–µ–Ω! –ú–∏—Å—Å–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞.");
                response.put("recommendation", "–ó–∞–ø—É—Å—Ç–∏—Ç–µ Saga: POST /api/v1/services/start/TransactionSaga");
            } else if (missionServicesRunning < 3) {
                response.put("warning", "–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –∫–ª—é—á–µ–≤—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏");
                response.put("recommendation", "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ POST /api/v1/services/start-mission –¥–ª—è –∑–∞–ø—É—Å–∫–∞");
            } else {
                response.put("ready", "–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞ –∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—é –º–∏—Å—Å–∏–∏");
                response.put("nextStep", "POST /api/v1/demo/mission/complete - –≤—ã–ø–æ–ª–Ω–∏—Ç—å –¥–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—é");
            }

            return ResponseEntity.ok(response);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä–≤–∏—Å–æ–≤: {}", e.getMessage(), e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("error", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–æ–≤");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @GetMapping("/status/{serviceId}")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞")
    public ResponseEntity<ServiceStatusDTO> getServiceStatus(@PathVariable String serviceId) {
        logger.debug("üîç –ó–ê–ü–†–û–°: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Å–µ—Ä–≤–∏—Å–∞ {}", serviceId);

        try {
            ServiceType serviceType = ServiceType.fromId(serviceId);
            ServiceStatusDTO status = serviceOrchestrator.getServiceStatus(serviceType);

            if (status != null) {
                return ResponseEntity.ok(status);
            }

            ServiceStatusDTO notFoundResponse = new ServiceStatusDTO();
            notFoundResponse.setErrorMessage("–°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω: " + serviceId);
            notFoundResponse.setServiceName(serviceId);
            return ResponseEntity.status(404).body(notFoundResponse);

        } catch (IllegalArgumentException e) {
            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å: " + serviceId);
            errorResponse.setServiceName(serviceId);
            return ResponseEntity.status(404).body(errorResponse);
        }
    }

    @GetMapping("/list")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –≤—Å–µ—Ö –¥–æ—Å—Ç—É–ø–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤")
    public ResponseEntity<Map<String, Object>> listAllServices() {
        logger.debug("üìã –ó–ê–ü–†–û–°: –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");

        Map<String, Object> response = new HashMap<>();
        List<Map<String, Object>> services = new ArrayList<>();

        for (ServiceType type : ServiceType.values()) {
            Map<String, Object> serviceInfo = new HashMap<>();
            serviceInfo.put("id", type.getId());
            serviceInfo.put("name", type.getDisplayName());
            serviceInfo.put("port", type.getDefaultPort());
            serviceInfo.put("description", type.getDisplayName());
            serviceInfo.put("missionCritical", isMissionCriticalService(type));
            serviceInfo.put("missionRole", getMissionRole(type));
            serviceInfo.put("directory", type.getDirectory());

            services.add(serviceInfo);
        }

        response.put("availableServices", services);
        response.put("count", services.size());
        response.put("missionCriticalCount", services.stream()
                .filter(s -> (Boolean) s.get("missionCritical"))
                .count());
        response.put("timestamp", System.currentTimeMillis());
        response.put("mission", "KEFIR Logistics - –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ—à–µ–Ω–∏—è –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏");

        return ResponseEntity.ok(response);
    }

    @GetMapping("/mission/readiness")
    @Operation(summary = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏")
    public ResponseEntity<Map<String, Object>> checkMissionReadiness() {
        logger.info("üéØ –ó–ê–ü–†–û–°: –ü—Ä–æ–≤–µ—Ä–∫–∞ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –º–∏—Å—Å–∏–∏");

        try {
            Map<String, Object> readiness = serviceOrchestrator.checkMissionReadiness();
            return ResponseEntity.ok(readiness);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –º–∏—Å—Å–∏–∏: {}", e.getMessage(), e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("error", "–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    @PostMapping("/stop-all")
    @Operation(summary = "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã")
    public ResponseEntity<Map<String, Object>> stopAllServices() {
        logger.info("üõë –ó–ê–ü–†–û–°: –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");

        try {
            Map<String, Object> result = serviceOrchestrator.stopAllRunningServices();
            result.put("message", "–í—Å–µ —Å–µ—Ä–≤–∏—Å—ã –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã");
            result.put("mission", "–°–∏—Å—Ç–µ–º–∞ –≤–æ–∑–≤—Ä–∞—â–µ–Ω–∞ –≤ –∏—Å—Ö–æ–¥–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ");
            return ResponseEntity.ok(result);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –æ—Å—Ç–∞–Ω–æ–≤–∫–∏ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤: {}", e.getMessage(), e);

            Map<String, Object> errorResponse = new HashMap<>();
            errorResponse.put("error", "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã");
            errorResponse.put("message", e.getMessage());
            errorResponse.put("timestamp", System.currentTimeMillis());

            return ResponseEntity.status(500).body(errorResponse);
        }
    }

    // ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ============

    private boolean isMissionCriticalService(ServiceType serviceType) {
        return serviceType == ServiceType.SAGA_SERVICE ||
                serviceType == ServiceType.SKLAD_SERVICE ||
                serviceType == ServiceType.BACKET_SERVICE ||
                serviceType == ServiceType.COLLECTOR_SERVICE ||
                serviceType == ServiceType.OFFICE_SERVICE;
    }

    private String getMissionRole(ServiceType serviceType) {
        switch (serviceType) {
            case SAGA_SERVICE:
                return "Transaction Saga - —Ä–µ—à–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ (–ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ï–ù)";
            case SKLAD_SERVICE:
                return "Warehouse Service - –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤";
            case BACKET_SERVICE:
                return "Shopping Cart Service - –Ω–∞—á–∞–ª–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç–æ–º";
            case COLLECTOR_SERVICE:
                return "Collector Service - –æ–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å–±–æ—Ä—â–∏–∫–æ–º";
            case OFFICE_SERVICE:
                return "Office Service - —Å–≤—è–∑—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º –ø—Ä–∏ –æ—à–∏–±–∫–µ";
            case AUTH_SERVICE:
                return "Authentication Service - –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π";
            case USER_SERVICE:
                return "User Management Service - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏";
            case DELIVERY_SERVICE:
                return "Delivery Service - –¥–æ—Å—Ç–∞–≤–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤";
            case API_GATEWAY:
                return "API Gateway - —Ç–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –≤ —Å–∏—Å—Ç–µ–º—É";
            default:
                return "–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å";
        }
    }
}package com.kefir.logistics.launcher_service.exception;

import com.kefir.logistics.launcher_service.model.dto.ErrorResponseDTO;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ServiceLaunchException.class)
    public ResponseEntity<ErrorResponseDTO> handleServiceLaunchException(ServiceLaunchException ex) {
        logger.error("Service launch error: {}", ex.getMessage(), ex);

        ErrorResponseDTO error = new ErrorResponseDTO(
                "SERVICE_LAUNCH_FAILED",
                ex.getMessage(),
                ex.getServiceName()
        );

        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(ServiceNotFoundException.class)
    public ResponseEntity<ErrorResponseDTO> handleServiceNotFoundException(ServiceNotFoundException ex) {
        logger.warn("Service not found: {}", ex.getMessage());

        ErrorResponseDTO error = new ErrorResponseDTO(
                "SERVICE_NOT_FOUND",
                ex.getMessage(),
                ex.getServiceName()
        );

        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponseDTO> handleIllegalArgumentException(IllegalArgumentException ex) {
        logger.warn("Invalid argument: {}", ex.getMessage());

        ErrorResponseDTO error = new ErrorResponseDTO(
                "INVALID_ARGUMENT",
                ex.getMessage(),
                null
        );

        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleGenericException(Exception ex) {
        logger.error("Unexpected error: {}", ex.getMessage(), ex);

        ErrorResponseDTO error = new ErrorResponseDTO(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                null
        );

        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}{

    private final String serviceName;
    private final String errorCode;

    public ServiceLaunchException(String serviceName, String message) {
        super("Failed to launch service '" + serviceName + "': " + message);
        this.serviceName = serviceName;
        this.errorCode = "LAUNCH_FAILED";
    }

    public ServiceLaunchException(String serviceName, String message, Throwable cause) {
        super("Failed to launch service '" + serviceName + "': " + message, cause);
        this.serviceName = serviceName;
        this.errorCode = "LAUNCH_FAILED";
    }

    public ServiceLaunchException(String serviceName, String message, String errorCode) {
        super("Failed to launch service '" + serviceName + "': " + message);
        this.serviceName = serviceName;
        this.errorCode = errorCode;
    }

    public String getServiceName() {
        return serviceName;
    }

    public String getErrorCode() {
        return errorCode;
    }
}package com.kefir.logistics.launcher_service.exception;

public class ServiceNotFoundException extends RuntimeException {

    private final String serviceName;

    public ServiceNotFoundException(String serviceName) {
        super("Service not found: " + serviceName);
        this.serviceName = serviceName;
    }

    public ServiceNotFoundException(String serviceName, String message) {
        super("Service '" + serviceName + "' not found: " + message);
        this.serviceName = serviceName;
    }

    public String getServiceName() {
        return serviceName;
    }
}package com.kefir.logistics.launcher_service.model.dto;

import com.kefir.logistics.launcher_service.model.enums.DemoScenarioType;
import java.time.LocalDateTime;
import java.util.Map;

public class DemoExecutionDTO {
    private String executionId;
    private DemoScenarioType scenarioType;
    private String scenarioTitle;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String status; // STARTED, RUNNING, COMPLETED, FAILED, CANCELLED
    private String errorMessage;
    private int executionTimeSeconds;
    private Map<String, Object> parameters;
    private Map<String, Object> results;
    private Map<String, Object> metrics;
    private String executedBy; // –ö—Ç–æ –∑–∞–ø—É—Å—Ç–∏–ª
    private String sessionId; // ID —Å–µ—Å—Å–∏–∏

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoExecutionDTO() {
        this.executionId = "DEMO_" + System.currentTimeMillis();
        this.startTime = LocalDateTime.now();
        this.status = "STARTED";
    }

    public DemoExecutionDTO(DemoScenarioType scenarioType, String scenarioTitle) {
        this();
        this.scenarioType = scenarioType;
        this.scenarioTitle = scenarioTitle;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getExecutionId() { return executionId; }
    public void setExecutionId(String executionId) { this.executionId = executionId; }

    public DemoScenarioType getScenarioType() { return scenarioType; }
    public void setScenarioType(DemoScenarioType scenarioType) { this.scenarioType = scenarioType; }

    public String getScenarioTitle() { return scenarioTitle; }
    public void setScenarioTitle(String scenarioTitle) { this.scenarioTitle = scenarioTitle; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public int getExecutionTimeSeconds() { return executionTimeSeconds; }
    public void setExecutionTimeSeconds(int executionTimeSeconds) { this.executionTimeSeconds = executionTimeSeconds; }

    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }

    public Map<String, Object> getResults() { return results; }
    public void setResults(Map<String, Object> results) { this.results = results; }

    public Map<String, Object> getMetrics() { return metrics; }
    public void setMetrics(Map<String, Object> metrics) { this.metrics = metrics; }

    public String getExecutedBy() { return executedBy; }
    public void setExecutedBy(String executedBy) { this.executedBy = executedBy; }

    public String getSessionId() { return sessionId; }
    public void setSessionId(String sessionId) { this.sessionId = sessionId; }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    public void complete(Map<String, Object> results) {
        this.endTime = LocalDateTime.now();
        this.status = "COMPLETED";
        this.results = results;
        calculateExecutionTime();
    }

    public void fail(String errorMessage) {
        this.endTime = LocalDateTime.now();
        this.status = "FAILED";
        this.errorMessage = errorMessage;
        calculateExecutionTime();
    }

    private void calculateExecutionTime() {
        if (startTime != null && endTime != null) {
            this.executionTimeSeconds = (int) java.time.Duration.between(startTime, endTime).getSeconds();
        }
    }
}package com.kefir.logistics.launcher_service.model.dto;

import com.kefir.logistics.launcher_service.model.enums.DemoScenarioType;
import com.kefir.logistics.launcher_service.model.enums.ErrorType;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

public class DemoScenarioDTO {
    private DemoScenarioType scenarioType;
    private String title;
    private String description;
    private List<String> steps;
    private List<ErrorType> simulatedErrors;
    private Map<String, Object> testData;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private boolean running;
    private Map<String, Object> results;

    // –î–û–ë–ê–í–ò–¢–¨:
    private String operationId;           // ID –æ–ø–µ—Ä–∞—Ü–∏–∏
    private String status;                // –°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    private String errorMessage;          // –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    private int executionTimeSeconds;     // –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    private List<String> executedServices; // –ö–∞–∫–∏–µ —Å–µ—Ä–≤–∏—Å—ã –±—ã–ª–∏ –∑–∞–ø—É—â–µ–Ω—ã
    private Map<String, Object> metrics;  // –ú–µ—Ç—Ä–∏–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoScenarioDTO() {}

    public DemoScenarioDTO(DemoScenarioType scenarioType, String title) {
        this.scenarioType = scenarioType;
        this.title = title;
        this.startTime = LocalDateTime.now();
        this.running = true;
        this.status = "STARTED";
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª–µ–π
    public DemoScenarioType getScenarioType() { return scenarioType; }
    public void setScenarioType(DemoScenarioType scenarioType) { this.scenarioType = scenarioType; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public List<String> getSteps() { return steps; }
    public void setSteps(List<String> steps) { this.steps = steps; }

    public List<ErrorType> getSimulatedErrors() { return simulatedErrors; }
    public void setSimulatedErrors(List<ErrorType> simulatedErrors) { this.simulatedErrors = simulatedErrors; }

    public Map<String, Object> getTestData() { return testData; }
    public void setTestData(Map<String, Object> testData) { this.testData = testData; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }

    public boolean isRunning() { return running; }
    public void setRunning(boolean running) { this.running = running; }

    public Map<String, Object> getResults() { return results; }
    public void setResults(Map<String, Object> results) { this.results = results; }

    // –î–û–ë–ê–í–ò–¢–¨ –≥–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã –¥–ª—è –Ω–æ–≤—ã—Ö –ø–æ–ª–µ–π:
    public String getOperationId() { return operationId; }
    public void setOperationId(String operationId) { this.operationId = operationId; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public int getExecutionTimeSeconds() { return executionTimeSeconds; }
    public void setExecutionTimeSeconds(int executionTimeSeconds) { this.executionTimeSeconds = executionTimeSeconds; }

    public List<String> getExecutedServices() { return executedServices; }
    public void setExecutedServices(List<String> executedServices) { this.executedServices = executedServices; }

    public Map<String, Object> getMetrics() { return metrics; }
    public void setMetrics(Map<String, Object> metrics) { this.metrics = metrics; }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    public void complete() {
        this.endTime = LocalDateTime.now();
        this.running = false;
        this.status = "COMPLETED";

        if (this.startTime != null && this.endTime != null) {
            this.executionTimeSeconds = (int) java.time.Duration.between(startTime, endTime).getSeconds();
        }
    }

    public void fail(String errorMessage) {
        this.endTime = LocalDateTime.now();
        this.running = false;
        this.status = "FAILED";
        this.errorMessage = errorMessage;
    }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;

public class ErrorResponseDTO {

    private String errorCode;
    private String message;
    private String details;
    private LocalDateTime timestamp;
    private String serviceName;

    public ErrorResponseDTO() {
        this.timestamp = LocalDateTime.now();
    }

    public ErrorResponseDTO(String errorCode, String message, String serviceName) {
        this();
        this.errorCode = errorCode;
        this.message = message;
        this.serviceName = serviceName;
    }

    public ErrorResponseDTO(String errorCode, String message, String details, String serviceName) {
        this();
        this.errorCode = errorCode;
        this.message = message;
        this.details = details;
        this.serviceName = serviceName;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getErrorCode() { return errorCode; }
    public void setErrorCode(String errorCode) { this.errorCode = errorCode; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public String getDetails() { return details; }
    public void setDetails(String details) { this.details = details; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;

public class LogEntryDTO {

    private LocalDateTime timestamp;
    private String level;          // INFO, ERROR, WARN, DEBUG
    private String serviceName;
    private String thread;
    private String logger;
    private String message;
    private String stackTrace;     // –î–ª—è –æ—à–∏–±–æ–∫

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public LogEntryDTO() {}

    public LogEntryDTO(LocalDateTime timestamp, String level, String serviceName, String message) {
        this.timestamp = timestamp;
        this.level = level;
        this.serviceName = serviceName;
        this.message = message;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getLevel() { return level; }
    public void setLevel(String level) { this.level = level; }

    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getThread() { return thread; }
    public void setThread(String thread) { this.thread = thread; }

    public String getLogger() { return logger; }
    public void setLogger(String logger) { this.logger = logger; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public String getStackTrace() { return stackTrace; }
    public void setStackTrace(String stackTrace) { this.stackTrace = stackTrace; }

    // Builder
    public static LogEntryDTOBuilder builder() {
        return new LogEntryDTOBuilder();
    }

    public static class LogEntryDTOBuilder {
        private LocalDateTime timestamp;
        private String level;
        private String serviceName;
        private String thread;
        private String logger;
        private String message;
        private String stackTrace;

        public LogEntryDTOBuilder timestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
            return this;
        }

        public LogEntryDTOBuilder level(String level) {
            this.level = level;
            return this;
        }

        public LogEntryDTOBuilder serviceName(String serviceName) {
            this.serviceName = serviceName;
            return this;
        }

        public LogEntryDTOBuilder thread(String thread) {
            this.thread = thread;
            return this;
        }

        public LogEntryDTOBuilder logger(String logger) {
            this.logger = logger;
            return this;
        }

        public LogEntryDTOBuilder message(String message) {
            this.message = message;
            return this;
        }

        public LogEntryDTOBuilder stackTrace(String stackTrace) {
            this.stackTrace = stackTrace;
            return this;
        }

        public LogEntryDTO build() {
            LogEntryDTO dto = new LogEntryDTO();
            dto.setTimestamp(timestamp);
            dto.setLevel(level);
            dto.setServiceName(serviceName);
            dto.setThread(thread);
            dto.setLogger(logger);
            dto.setMessage(message);
            dto.setStackTrace(stackTrace);
            return dto;
        }
    }
}package com.kefir.logistics.launcher_service.model.dto;

import com.kefir.logistics.launcher_service.model.enums.ServiceState;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;

import java.time.LocalDateTime;
import java.util.Map;

public class ServiceStatusDTO {
    private ServiceType serviceType;
    private ServiceState state;
    private Integer pid;
    private LocalDateTime startedAt;
    private LocalDateTime lastChecked;
    private String healthUrl;
    private String logPath;
    private String errorMessage;
    private Map<String, Object> metrics;
    private String version;

    private boolean portOpen;
    private int startupTimeSeconds;
    private int restartCount;
    private String lastError;
    private LocalDateTime lastErrorTime;

    private String missionRole;
    private boolean requiredForMission;  // <-- –ë–´–õ–û –î–£–ë–õ–ò–†–û–í–ê–ù–ò–ï
    private boolean isHealthy;
    private int port;
    private String serviceName;
    private LocalDateTime lastHealthCheck;
    private boolean isManaged = true;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceStatusDTO() {}

    public ServiceStatusDTO(ServiceType serviceType, ServiceState state) {
        this.serviceType = serviceType;
        this.state = state;
        this.startedAt = LocalDateTime.now();
        this.lastChecked = LocalDateTime.now();
        this.restartCount = 0;
        this.lastHealthCheck = LocalDateTime.now();
        this.isManaged = (state != ServiceState.EXTERNAL);
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public ServiceType getServiceType() { return serviceType; }
    public void setServiceType(ServiceType serviceType) { this.serviceType = serviceType; }

    public ServiceState getState() { return state; }
    public void setState(ServiceState state) {
        this.state = state;
        if (state == ServiceState.EXTERNAL) {
            this.isManaged = false;
        }
    }

    public Integer getPid() { return pid; }
    public void setPid(Integer pid) { this.pid = pid; }

    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }

    public LocalDateTime getLastChecked() { return lastChecked; }
    public void setLastChecked(LocalDateTime lastChecked) { this.lastChecked = lastChecked; }

    public String getHealthUrl() { return healthUrl; }
    public void setHealthUrl(String healthUrl) { this.healthUrl = healthUrl; }

    public String getLogPath() { return logPath; }
    public void setLogPath(String logPath) { this.logPath = logPath; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public Map<String, Object> getMetrics() { return metrics; }
    public void setMetrics(Map<String, Object> metrics) { this.metrics = metrics; }

    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }

    public boolean isPortOpen() { return portOpen; }
    public void setPortOpen(boolean portOpen) { this.portOpen = portOpen; }

    public int getStartupTimeSeconds() { return startupTimeSeconds; }
    public void setStartupTimeSeconds(int startupTimeSeconds) { this.startupTimeSeconds = startupTimeSeconds; }

    public int getRestartCount() { return restartCount; }
    public void setRestartCount(int restartCount) { this.restartCount = restartCount; }
    public void incrementRestartCount() { this.restartCount++; }

    public String getLastError() { return lastError; }
    public void setLastError(String lastError) {
        this.lastError = lastError;
        this.lastErrorTime = LocalDateTime.now();
    }

    public LocalDateTime getLastErrorTime() { return lastErrorTime; }
    public void setLastErrorTime(LocalDateTime lastErrorTime) { this.lastErrorTime = lastErrorTime; }

    // –ù–û–í–´–ï –ú–ï–¢–û–î–´ (–ë–ï–ó –î–£–ë–õ–ò–†–û–í–ê–ù–ò–Ø)

    public String getMissionRole() { return missionRole; }
    public void setMissionRole(String missionRole) { this.missionRole = missionRole; }

    // –¢–û–õ–¨–ö–û –û–î–ò–ù –ú–ï–¢–û–î isRequiredForMission() - —É–±—Ä–∞—Ç—å –¥—É–±–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
    public boolean isRequiredForMission() {
        return requiredForMission;
    }

    public void setRequiredForMission(boolean requiredForMission) {
        this.requiredForMission = requiredForMission;
    }

    public boolean isHealthy() {
        if (state == null) {
            return false;
        }
        if (state == ServiceState.EXTERNAL) {
            return portOpen;
        }
        return state.isRunning() && portOpen;
    }

    public void setHealthy(boolean healthy) {
        this.isHealthy = healthy;
    }

    public int getPort() { return port; }
    public void setPort(int port) { this.port = port; }

    public String getServiceName() {
        if (serviceName != null) {
            return serviceName;
        }
        return serviceType != null ? serviceType.getDisplayName() : "Unknown";
    }

    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public LocalDateTime getLastHealthCheck() { return lastHealthCheck; }
    public void setLastHealthCheck(LocalDateTime lastHealthCheck) { this.lastHealthCheck = lastHealthCheck; }

    public boolean isManaged() { return isManaged; }
    public void setManaged(boolean managed) { this.isManaged = managed; }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    public void updateHealthCheck(boolean portOpen, String errorMessage) {
        this.lastChecked = LocalDateTime.now();
        this.lastHealthCheck = LocalDateTime.now();
        this.portOpen = portOpen;

        if (errorMessage != null) {
            this.errorMessage = errorMessage;
            this.lastError = errorMessage;
            this.lastErrorTime = LocalDateTime.now();
            this.isHealthy = false;
        } else {
            this.isHealthy = true && portOpen;
        }
    }

    public boolean isRunning() {
        return state != null && state.isRunning();
    }

    public boolean isExternal() {
        return state == ServiceState.EXTERNAL;
    }

    // Builder pattern
    public static ServiceStatusDTOBuilder builder() {
        return new ServiceStatusDTOBuilder();
    }

    public static class ServiceStatusDTOBuilder {
        private ServiceType serviceType;
        private ServiceState state;
        private Integer pid;
        private LocalDateTime startedAt;
        private LocalDateTime lastChecked;
        private String healthUrl;
        private String logPath;
        private String errorMessage;
        private Map<String, Object> metrics;
        private String version;
        private String missionRole;
        private boolean requiredForMission;
        private int port;
        private String serviceName;
        private boolean portOpen;
        private boolean isManaged = true;

        public ServiceStatusDTOBuilder serviceType(ServiceType serviceType) {
            this.serviceType = serviceType;
            return this;
        }

        public ServiceStatusDTOBuilder state(ServiceState state) {
            this.state = state;
            if (state == ServiceState.EXTERNAL) {
                this.isManaged = false;
            }
            return this;
        }

        public ServiceStatusDTOBuilder pid(Integer pid) {
            this.pid = pid;
            return this;
        }

        public ServiceStatusDTOBuilder startedAt(LocalDateTime startedAt) {
            this.startedAt = startedAt;
            return this;
        }

        public ServiceStatusDTOBuilder lastChecked(LocalDateTime lastChecked) {
            this.lastChecked = lastChecked;
            return this;
        }

        public ServiceStatusDTOBuilder healthUrl(String healthUrl) {
            this.healthUrl = healthUrl;
            return this;
        }

        public ServiceStatusDTOBuilder logPath(String logPath) {
            this.logPath = logPath;
            return this;
        }

        public ServiceStatusDTOBuilder errorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
            return this;
        }

        public ServiceStatusDTOBuilder metrics(Map<String, Object> metrics) {
            this.metrics = metrics;
            return this;
        }

        public ServiceStatusDTOBuilder version(String version) {
            this.version = version;
            return this;
        }

        public ServiceStatusDTOBuilder missionRole(String missionRole) {
            this.missionRole = missionRole;
            return this;
        }

        public ServiceStatusDTOBuilder requiredForMission(boolean requiredForMission) {
            this.requiredForMission = requiredForMission;
            return this;
        }

        public ServiceStatusDTOBuilder port(int port) {
            this.port = port;
            return this;
        }

        public ServiceStatusDTOBuilder serviceName(String serviceName) {
            this.serviceName = serviceName;
            return this;
        }

        public ServiceStatusDTOBuilder portOpen(boolean portOpen) {
            this.portOpen = portOpen;
            return this;
        }

        public ServiceStatusDTOBuilder managed(boolean isManaged) {
            this.isManaged = isManaged;
            return this;
        }

        public ServiceStatusDTO build() {
            ServiceStatusDTO dto = new ServiceStatusDTO();
            dto.setServiceType(serviceType);
            dto.setState(state);
            dto.setPid(pid);
            dto.setStartedAt(startedAt);
            dto.setLastChecked(lastChecked);
            dto.setHealthUrl(healthUrl);
            dto.setLogPath(logPath);
            dto.setErrorMessage(errorMessage);
            dto.setMetrics(metrics);
            dto.setVersion(version);
            dto.setMissionRole(missionRole);
            dto.setRequiredForMission(requiredForMission);
            dto.setPort(port);
            dto.setServiceName(serviceName);
            dto.setPortOpen(portOpen);
            dto.setManaged(isManaged);
            return dto;
        }
    }

    @Override
    public String toString() {
        return String.format("ServiceStatusDTO{service=%s, state=%s, port=%d, mission='%s', required=%s, managed=%s, healthy=%s}",
                getServiceName(),
                state != null ? state.getDescription() : "null",
                port,
                missionRole != null ? missionRole : "null",
                requiredForMission,
                isManaged,
                isHealthy());
    }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.List;

public class SystemHealthDTO {
    private String systemName;
    private String overallStatus; // UP, DOWN, DEGRADED
    private LocalDateTime checkTime;
    private Map<String, ServiceHealthDTO> services;
    private List<String> warnings;
    private List<String> errors;
    private SystemMetricsDTO metrics;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public SystemHealthDTO() {
        this.systemName = "KEFIR Logistics System";
        this.checkTime = LocalDateTime.now();
        this.overallStatus = "UP";
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getSystemName() { return systemName; }
    public void setSystemName(String systemName) { this.systemName = systemName; }

    public String getOverallStatus() { return overallStatus; }
    public void setOverallStatus(String overallStatus) { this.overallStatus = overallStatus; }

    public LocalDateTime getCheckTime() { return checkTime; }
    public void setCheckTime(LocalDateTime checkTime) { this.checkTime = checkTime; }

    public Map<String, ServiceHealthDTO> getServices() { return services; }
    public void setServices(Map<String, ServiceHealthDTO> services) { this.services = services; }

    public List<String> getWarnings() { return warnings; }
    public void setWarnings(List<String> warnings) { this.warnings = warnings; }

    public List<String> getErrors() { return errors; }
    public void setErrors(List<String> errors) { this.errors = errors; }

    public SystemMetricsDTO getMetrics() { return metrics; }
    public void setMetrics(SystemMetricsDTO metrics) { this.metrics = metrics; }
}

class ServiceHealthDTO {
    private String serviceName;
    private String status; // UP, DOWN, UNKNOWN
    private int responseTimeMs;
    private LocalDateTime lastCheck;
    private String healthEndpoint;
    private Map<String, Object> details;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceHealthDTO() {}

    public ServiceHealthDTO(String serviceName, String status) {
        this.serviceName = serviceName;
        this.status = status;
        this.lastCheck = LocalDateTime.now();
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public int getResponseTimeMs() { return responseTimeMs; }
    public void setResponseTimeMs(int responseTimeMs) { this.responseTimeMs = responseTimeMs; }

    public LocalDateTime getLastCheck() { return lastCheck; }
    public void setLastCheck(LocalDateTime lastCheck) { this.lastCheck = lastCheck; }

    public String getHealthEndpoint() { return healthEndpoint; }
    public void setHealthEndpoint(String healthEndpoint) { this.healthEndpoint = healthEndpoint; }

    public Map<String, Object> getDetails() { return details; }
    public void setDetails(Map<String, Object> details) { this.details = details; }
}

class SystemMetricsDTO {
    private int totalServices;
    private int healthyServices;
    private int unhealthyServices;
    private double healthPercentage;
    private long totalMemoryMB;
    private long usedMemoryMB;
    private double memoryUsagePercentage;
    private int cpuUsagePercentage;
    private int activeThreads;
    private int totalTransactions;
    private int failedTransactions;
    private double successRate;

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public int getTotalServices() { return totalServices; }
    public void setTotalServices(int totalServices) { this.totalServices = totalServices; }

    public int getHealthyServices() { return healthyServices; }
    public void setHealthyServices(int healthyServices) { this.healthyServices = healthyServices; }

    public int getUnhealthyServices() { return unhealthyServices; }
    public void setUnhealthyServices(int unhealthyServices) { this.unhealthyServices = unhealthyServices; }

    public double getHealthPercentage() { return healthPercentage; }
    public void setHealthPercentage(double healthPercentage) { this.healthPercentage = healthPercentage; }

    public long getTotalMemoryMB() { return totalMemoryMB; }
    public void setTotalMemoryMB(long totalMemoryMB) { this.totalMemoryMB = totalMemoryMB; }

    public long getUsedMemoryMB() { return usedMemoryMB; }
    public void setUsedMemoryMB(long usedMemoryMB) { this.usedMemoryMB = usedMemoryMB; }

    public double getMemoryUsagePercentage() { return memoryUsagePercentage; }
    public void setMemoryUsagePercentage(double memoryUsagePercentage) { this.memoryUsagePercentage = memoryUsagePercentage; }

    public int getCpuUsagePercentage() { return cpuUsagePercentage; }
    public void setCpuUsagePercentage(int cpuUsagePercentage) { this.cpuUsagePercentage = cpuUsagePercentage; }

    public int getActiveThreads() { return activeThreads; }
    public void setActiveThreads(int activeThreads) { this.activeThreads = activeThreads; }

    public int getTotalTransactions() { return totalTransactions; }
    public void setTotalTransactions(int totalTransactions) { this.totalTransactions = totalTransactions; }

    public int getFailedTransactions() { return failedTransactions; }
    public void setFailedTransactions(int failedTransactions) { this.failedTransactions = failedTransactions; }

    public double getSuccessRate() { return successRate; }
    public void setSuccessRate(double successRate) { this.successRate = successRate; }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.List;

public class SystemHealthDTO {
    private String systemName;
    private String overallStatus; // UP, DOWN, DEGRADED
    private LocalDateTime checkTime;
    private Map<String, ServiceHealthDTO> services;
    private List<String> warnings;
    private List<String> errors;
    private SystemMetricsDTO metrics;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public SystemHealthDTO() {
        this.systemName = "KEFIR Logistics System";
        this.checkTime = LocalDateTime.now();
        this.overallStatus = "UP";
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getSystemName() { return systemName; }
    public void setSystemName(String systemName) { this.systemName = systemName; }

    public String getOverallStatus() { return overallStatus; }
    public void setOverallStatus(String overallStatus) { this.overallStatus = overallStatus; }

    public LocalDateTime getCheckTime() { return checkTime; }
    public void setCheckTime(LocalDateTime checkTime) { this.checkTime = checkTime; }

    public Map<String, ServiceHealthDTO> getServices() { return services; }
    public void setServices(Map<String, ServiceHealthDTO> services) { this.services = services; }

    public List<String> getWarnings() { return warnings; }
    public void setWarnings(List<String> warnings) { this.warnings = warnings; }

    public List<String> getErrors() { return errors; }
    public void setErrors(List<String> errors) { this.errors = errors; }

    public SystemMetricsDTO getMetrics() { return metrics; }
    public void setMetrics(SystemMetricsDTO metrics) { this.metrics = metrics; }
}

class ServiceHealthDTO {
    private String serviceName;
    private String status; // UP, DOWN, UNKNOWN
    private int responseTimeMs;
    private LocalDateTime lastCheck;
    private String healthEndpoint;
    private Map<String, Object> details;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceHealthDTO() {}

    public ServiceHealthDTO(String serviceName, String status) {
        this.serviceName = serviceName;
        this.status = status;
        this.lastCheck = LocalDateTime.now();
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public int getResponseTimeMs() { return responseTimeMs; }
    public void setResponseTimeMs(int responseTimeMs) { this.responseTimeMs = responseTimeMs; }

    public LocalDateTime getLastCheck() { return lastCheck; }
    public void setLastCheck(LocalDateTime lastCheck) { this.lastCheck = lastCheck; }

    public String getHealthEndpoint() { return healthEndpoint; }
    public void setHealthEndpoint(String healthEndpoint) { this.healthEndpoint = healthEndpoint; }

    public Map<String, Object> getDetails() { return details; }
    public void setDetails(Map<String, Object> details) { this.details = details; }
}

class SystemMetricsDTO {
    private int totalServices;
    private int healthyServices;
    private int unhealthyServices;
    private double healthPercentage;
    private long totalMemoryMB;
    private long usedMemoryMB;
    private double memoryUsagePercentage;
    private int cpuUsagePercentage;
    private int activeThreads;
    private int totalTransactions;
    private int failedTransactions;
    private double successRate;

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public int getTotalServices() { return totalServices; }
    public void setTotalServices(int totalServices) { this.totalServices = totalServices; }

    public int getHealthyServices() { return healthyServices; }
    public void setHealthyServices(int healthyServices) { this.healthyServices = healthyServices; }

    public int getUnhealthyServices() { return unhealthyServices; }
    public void setUnhealthyServices(int unhealthyServices) { this.unhealthyServices = unhealthyServices; }

    public double getHealthPercentage() { return healthPercentage; }
    public void setHealthPercentage(double healthPercentage) { this.healthPercentage = healthPercentage; }

    public long getTotalMemoryMB() { return totalMemoryMB; }
    public void setTotalMemoryMB(long totalMemoryMB) { this.totalMemoryMB = totalMemoryMB; }

    public long getUsedMemoryMB() { return usedMemoryMB; }
    public void setUsedMemoryMB(long usedMemoryMB) { this.usedMemoryMB = usedMemoryMB; }

    public double getMemoryUsagePercentage() { return memoryUsagePercentage; }
    public void setMemoryUsagePercentage(double memoryUsagePercentage) { this.memoryUsagePercentage = memoryUsagePercentage; }

    public int getCpuUsagePercentage() { return cpuUsagePercentage; }
    public void setCpuUsagePercentage(int cpuUsagePercentage) { this.cpuUsagePercentage = cpuUsagePercentage; }

    public int getActiveThreads() { return activeThreads; }
    public void setActiveThreads(int activeThreads) { this.activeThreads = activeThreads; }

    public int getTotalTransactions() { return totalTransactions; }
    public void setTotalTransactions(int totalTransactions) { this.totalTransactions = totalTransactions; }

    public int getFailedTransactions() { return failedTransactions; }
    public void setFailedTransactions(int failedTransactions) { this.failedTransactions = failedTransactions; }

    public double getSuccessRate() { return successRate; }
    public void setSuccessRate(double successRate) { this.successRate = successRate; }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.List;

public class SystemHealthDTO {
    private String systemName;
    private String overallStatus; // UP, DOWN, DEGRADED
    private LocalDateTime checkTime;
    private Map<String, ServiceHealthDTO> services;
    private List<String> warnings;
    private List<String> errors;
    private SystemMetricsDTO metrics;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public SystemHealthDTO() {
        this.systemName = "KEFIR Logistics System";
        this.checkTime = LocalDateTime.now();
        this.overallStatus = "UP";
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getSystemName() { return systemName; }
    public void setSystemName(String systemName) { this.systemName = systemName; }

    public String getOverallStatus() { return overallStatus; }
    public void setOverallStatus(String overallStatus) { this.overallStatus = overallStatus; }

    public LocalDateTime getCheckTime() { return checkTime; }
    public void setCheckTime(LocalDateTime checkTime) { this.checkTime = checkTime; }

    public Map<String, ServiceHealthDTO> getServices() { return services; }
    public void setServices(Map<String, ServiceHealthDTO> services) { this.services = services; }

    public List<String> getWarnings() { return warnings; }
    public void setWarnings(List<String> warnings) { this.warnings = warnings; }

    public List<String> getErrors() { return errors; }
    public void setErrors(List<String> errors) { this.errors = errors; }

    public SystemMetricsDTO getMetrics() { return metrics; }
    public void setMetrics(SystemMetricsDTO metrics) { this.metrics = metrics; }
}

class ServiceHealthDTO {
    private String serviceName;
    private String status; // UP, DOWN, UNKNOWN
    private int responseTimeMs;
    private LocalDateTime lastCheck;
    private String healthEndpoint;
    private Map<String, Object> details;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceHealthDTO() {}

    public ServiceHealthDTO(String serviceName, String status) {
        this.serviceName = serviceName;
        this.status = status;
        this.lastCheck = LocalDateTime.now();
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public int getResponseTimeMs() { return responseTimeMs; }
    public void setResponseTimeMs(int responseTimeMs) { this.responseTimeMs = responseTimeMs; }

    public LocalDateTime getLastCheck() { return lastCheck; }
    public void setLastCheck(LocalDateTime lastCheck) { this.lastCheck = lastCheck; }

    public String getHealthEndpoint() { return healthEndpoint; }
    public void setHealthEndpoint(String healthEndpoint) { this.healthEndpoint = healthEndpoint; }

    public Map<String, Object> getDetails() { return details; }
    public void setDetails(Map<String, Object> details) { this.details = details; }
}

class SystemMetricsDTO {
    private int totalServices;
    private int healthyServices;
    private int unhealthyServices;
    private double healthPercentage;
    private long totalMemoryMB;
    private long usedMemoryMB;
    private double memoryUsagePercentage;
    private int cpuUsagePercentage;
    private int activeThreads;
    private int totalTransactions;
    private int failedTransactions;
    private double successRate;

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public int getTotalServices() { return totalServices; }
    public void setTotalServices(int totalServices) { this.totalServices = totalServices; }

    public int getHealthyServices() { return healthyServices; }
    public void setHealthyServices(int healthyServices) { this.healthyServices = healthyServices; }

    public int getUnhealthyServices() { return unhealthyServices; }
    public void setUnhealthyServices(int unhealthyServices) { this.unhealthyServices = unhealthyServices; }

    public double getHealthPercentage() { return healthPercentage; }
    public void setHealthPercentage(double healthPercentage) { this.healthPercentage = healthPercentage; }

    public long getTotalMemoryMB() { return totalMemoryMB; }
    public void setTotalMemoryMB(long totalMemoryMB) { this.totalMemoryMB = totalMemoryMB; }

    public long getUsedMemoryMB() { return usedMemoryMB; }
    public void setUsedMemoryMB(long usedMemoryMB) { this.usedMemoryMB = usedMemoryMB; }

    public double getMemoryUsagePercentage() { return memoryUsagePercentage; }
    public void setMemoryUsagePercentage(double memoryUsagePercentage) { this.memoryUsagePercentage = memoryUsagePercentage; }

    public int getCpuUsagePercentage() { return cpuUsagePercentage; }
    public void setCpuUsagePercentage(int cpuUsagePercentage) { this.cpuUsagePercentage = cpuUsagePercentage; }

    public int getActiveThreads() { return activeThreads; }
    public void setActiveThreads(int activeThreads) { this.activeThreads = activeThreads; }

    public int getTotalTransactions() { return totalTransactions; }
    public void setTotalTransactions(int totalTransactions) { this.totalTransactions = totalTransactions; }

    public int getFailedTransactions() { return failedTransactions; }
    public void setFailedTransactions(int failedTransactions) { this.failedTransactions = failedTransactions; }

    public double getSuccessRate() { return successRate; }
    public void setSuccessRate(double successRate) { this.successRate = successRate; }
}package com.kefir.logistics.launcher_service.model.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.time.Duration;

@Entity
@Table(name = "demo_executions")
public class DemoExecutionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "demo_scenario_id", nullable = false)
    private Long demoScenarioId;

    @Column(name = "execution_time", nullable = false)
    private LocalDateTime executionTime;

    @Column(name = "duration_seconds")
    private Long durationSeconds;

    @Column(name = "status", nullable = false)
    private String status; // SUCCESS, FAILED, PARTIAL

    @Column(name = "error_message", length = 2000)
    private String errorMessage;

    @Column(name = "executed_by")
    private String executedBy;

    @Column(name = "metrics", columnDefinition = "TEXT")
    private String metrics; // JSON —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoExecutionEntity() {
        this.executionTime = LocalDateTime.now();
    }

    public DemoExecutionEntity(Long demoScenarioId, String status) {
        this();
        this.demoScenarioId = demoScenarioId;
        this.status = status;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getDemoScenarioId() { return demoScenarioId; }
    public void setDemoScenarioId(Long demoScenarioId) { this.demoScenarioId = demoScenarioId; }

    public LocalDateTime getExecutionTime() { return executionTime; }
    public void setExecutionTime(LocalDateTime executionTime) { this.executionTime = executionTime; }

    public Long getDurationSeconds() { return durationSeconds; }
    public void setDurationSeconds(Long durationSeconds) { this.durationSeconds = durationSeconds; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public String getExecutedBy() { return executedBy; }
    public void setExecutedBy(String executedBy) { this.executedBy = executedBy; }

    public String getMetrics() { return metrics; }
    public void setMetrics(String metrics) { this.metrics = metrics; }

    // –ú–µ—Ç–æ–¥ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    public void calculateDuration(LocalDateTime endTime) {
        if (endTime != null && executionTime != null) {
            this.durationSeconds = Duration.between(executionTime, endTime).getSeconds();
        }
    }
}package com.kefir.logistics.launcher_service.model.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "demo_scenarios")
public class DemoScenarioEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "scenario_type", nullable = false)
    private String scenarioType;

    @Column(name = "scenario_name", nullable = false)
    private String scenarioName;

    @Column(name = "description", length = 2000)
    private String description;

    @Column(name = "start_time")
    private LocalDateTime startTime;

    @Column(name = "end_time")
    private LocalDateTime endTime;

    @Column(name = "status")
    private String status; // CREATED, RUNNING, COMPLETED, FAILED

    @Column(name = "result_data", columnDefinition = "TEXT")
    private String resultData; // JSON —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏

    @Column(name = "created_by")
    private String createdBy;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoScenarioEntity() {
        this.createdAt = LocalDateTime.now();
        this.status = "CREATED";
    }

    public DemoScenarioEntity(String scenarioType, String scenarioName) {
        this();
        this.scenarioType = scenarioType;
        this.scenarioName = scenarioName;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getScenarioType() { return scenarioType; }
    public void setScenarioType(String scenarioType) { this.scenarioType = scenarioType; }

    public String getScenarioName() { return scenarioName; }
    public void setScenarioName(String scenarioName) { this.scenarioName = scenarioName; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getResultData() { return resultData; }
    public void setResultData(String resultData) { this.resultData = resultData; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}package com.kefir.logistics.launcher_service.model.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "service_logs")
@TableGenerator(name = "log_gen", table = "id_gen", pkColumnName = "gen_name",
        valueColumnName = "gen_value", pkColumnValue = "log_gen", initialValue = 1, allocationSize = 100)
public class ServiceLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "log_gen")
    private Long id;

    @Column(name = "service_id", nullable = false)
    private String serviceId;

    @Column(name = "log_level", nullable = false)
    private String logLevel; // INFO, ERROR, WARN, DEBUG

    @Column(name = "message", length = 4000, nullable = false)
    private String message;

    @Column(name = "timestamp", nullable = false)
    private LocalDateTime timestamp;

    @Column(name = "thread_name")
    private String threadName;

    @Column(name = "logger_name")
    private String loggerName;

    @Column(name = "stack_trace", columnDefinition = "TEXT")
    private String stackTrace;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceLogEntity() {
        this.timestamp = LocalDateTime.now();
    }

    public ServiceLogEntity(String serviceId, String logLevel, String message) {
        this();
        this.serviceId = serviceId;
        this.logLevel = logLevel;
        this.message = message;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getServiceId() { return serviceId; }
    public void setServiceId(String serviceId) { this.serviceId = serviceId; }

    public String getLogLevel() { return logLevel; }
    public void setLogLevel(String logLevel) { this.logLevel = logLevel; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getThreadName() { return threadName; }
    public void setThreadName(String threadName) { this.threadName = threadName; }

    public String getLoggerName() { return loggerName; }
    public void setLoggerName(String loggerName) { this.loggerName = loggerName; }

    public String getStackTrace() { return stackTrace; }
    public void setStackTrace(String stackTrace) { this.stackTrace = stackTrace; }
}package com.kefir.logistics.launcher_service.model.entity;


import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "service_status_history")
public class ServiceStatusEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "service_id", nullable = false)
    private String serviceId;

    @Column(name = "service_name", nullable = false)
    private String serviceName;

    @Column(name = "status", nullable = false)
    private String status;

    @Column(name = "pid")
    private Integer pid;

    @Column(name = "started_at")
    private LocalDateTime startedAt;

    @Column(name = "stopped_at")
    private LocalDateTime stoppedAt;

    @Column(name = "error_message", length = 1000)
    private String errorMessage;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceStatusEntity() {
        this.createdAt = LocalDateTime.now();
    }

    public ServiceStatusEntity(String serviceId, String serviceName, String status) {
        this();
        this.serviceId = serviceId;
        this.serviceName = serviceName;
        this.status = status;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getServiceId() { return serviceId; }
    public void setServiceId(String serviceId) { this.serviceId = serviceId; }

    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Integer getPid() { return pid; }
    public void setPid(Integer pid) { this.pid = pid; }

    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }

    public LocalDateTime getStoppedAt() { return stoppedAt; }
    public void setStoppedAt(LocalDateTime stoppedAt) { this.stoppedAt = stoppedAt; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}package com.kefir.logistics.launcher_service.model.enums;

public enum DemoScenarioType {
    NORMAL_PROCESS("–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–∫–∞–∑–∞"),
    SINGLE_MISSING_ITEM("–û–¥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä"),
    CASCADE_ERRORS("–ö–∞—Å–∫–∞–¥–Ω—ã–µ –æ—à–∏–±–∫–∏ (–ì–ª–∞–≤–Ω—ã–π –¥–µ–º–æ)"),
    CLIENT_DEMANDS_ALL("–ö–ª–∏–µ–Ω—Ç —Ç—Ä–µ–±—É–µ—Ç –≤—Å–µ —Ç–æ–≤–∞—Ä—ã"),
    NIGHTMARE_SCENARIO("–ù–æ—á–Ω–æ–π –∫–æ—à–º–∞—Ä (–º–∞–≥–∞–∑–∏–Ω—ã –∑–∞–∫—Ä—ã—Ç—ã)");

    private final String description;

    DemoScenarioType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}package com.kefir.logistics.launcher_service.model.enums;

public enum ErrorType {
    PRODUCT_NOT_FOUND("–¢–æ–≤–∞—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞ —Å–∫–ª–∞–¥–µ"),
    LOW_STOCK("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–∞"),
    TRANSACTION_TIMEOUT("–¢–∞–π–º–∞—É—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"),
    WAREHOUSE_CLOSED("–°–∫–ª–∞–¥ –∑–∞–∫—Ä—ã—Ç"),
    DELIVERY_FAILED("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç–∞–≤–∫–∏"),
    PAYMENT_FAILED("–û—à–∏–±–∫–∞ –æ–ø–ª–∞—Ç—ã");

    private final String description;

    ErrorType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}package com.kefir.logistics.launcher_service.model.enums;

public enum ServiceState {
    STOPPED("stopped", "–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", false),
    STARTING("starting", "–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è", false),
    RUNNING("running", "–†–∞–±–æ—Ç–∞–µ—Ç", true),
    FAILED("failed", "–û—à–∏–±–∫–∞", false),
    RESTARTING("restarting", "–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è", false),
    HEALTHY("healthy", "–ó–¥–æ—Ä–æ–≤", true),
    UNHEALTHY("unhealthy", "–ù–µ –∑–¥–æ—Ä–æ–≤", false),
    EXTERNAL("external", "–í–Ω–µ—à–Ω–∏–π –ø—Ä–æ—Ü–µ—Å—Å", true); // <-- –î–û–ë–ê–í–õ–ï–ù–û!

    private final String code;
    private final String description;
    private final boolean active;

    ServiceState(String code, String description, boolean active) {
        this.code = code;
        this.description = description;
        this.active = active;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }

    public boolean isActive() {
        return active;
    }

    public boolean isRunning() {
        return this == RUNNING || this == HEALTHY || this == EXTERNAL;
    }

    public boolean isStopped() {
        return this == STOPPED;
    }

    public boolean isFailed() {
        return this == FAILED || this == UNHEALTHY;
    }

    // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞
    public boolean isManaged() {
        return this != EXTERNAL;
    }

    public boolean isExternal() {
        return this == EXTERNAL;
    }

    public boolean isHealthyState() {
        return this == HEALTHY || this == RUNNING || this == EXTERNAL;
    }

    public static ServiceState fromCode(String code) {
        for (ServiceState state : values()) {
            if (state.getCode().equalsIgnoreCase(code)) {
                return state;
            }
        }
        throw new IllegalArgumentException("Unknown ServiceState code: " + code);
    }

    @Override
    public String toString() {
        return String.format("%s (%s)", code, description);
    }
}package com.kefir.logistics.launcher_service.model.enums;

public enum ServiceType {
    AUTH_SERVICE("AUTH", 8097, "Auth", "Authentication Service"),
    USER_SERVICE("USER", 8081, "User", "User Management Service"),
    SKLAD_SERVICE("Sklad", 8082, "Sklad", "Warehouse Service"),
    BACKET_SERVICE("backet-service", 8083, "Backet", "Shopping Cart Service"),
    OFFICE_SERVICE("Office", 8085, "Office", "Office Management Service"),
    COLLECTOR_SERVICE("COLLECTOR", 8086, "Collector", "Collector Service"),
    DELIVERY_SERVICE("Delivery", 8088, "Delivery", "Delivery Service"),
    SAGA_SERVICE("TransactionSaga", 8090, "TransactionSaga", "Transaction Saga Service"),
    API_GATEWAY("ApiGateWay", 8080, "ApiGateWay", "API Gateway");

    private String id;
    private int port;
    private String directory;
    private String displayName;

    ServiceType(String id, int port, String directory, String displayName) {
        this.id = id;
        this.port = port;
        this.directory = directory;
        this.displayName = displayName;
    }

    public String getId() { return id; }
    public int getPort() { return port; }
    public int getDefaultPort() { return port; }  // –î–û–ë–ê–í–¨–¢–ï –≠–¢–û–¢ –ú–ï–¢–û–î
    public String getDirectory() { return directory; }
    public String getDisplayName() { return displayName; }

    public static ServiceType fromId(String id) {
        for (ServiceType type : values()) {
            if (type.id.equalsIgnoreCase(id)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unknown service: " + id);
    }

    public static ServiceType fromPort(int port) {
        for (ServiceType type : values()) {
            if (type.port == port) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unknown port: " + port);
    }
}package com.kefir.logistics.launcher_service.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

@Component
public class DemoAutoStarter implements ApplicationListener<ContextRefreshedEvent> {
    private static final Logger logger = LoggerFactory.getLogger(DemoAutoStarter.class);
    private static boolean alreadyStarted = false;

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        if (!alreadyStarted) {
            alreadyStarted = true;

            logger.info("=== –ê–í–¢–û–°–¢–ê–†–¢ –°–ò–°–¢–ï–ú–´ KEFIR LOGISTICS ===");

            // –ó–∞–ø—É—Å–∫ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
            new Thread(() -> {
                try {
                    // –ñ–¥–µ–º 5 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ –ª–∞—É–Ω—á–µ—Ä–∞
                    Thread.sleep(5000);

                    logger.info("üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏...");
                    // –ò—Å–ø–æ–ª—å–∑—É–µ–º –Ω–æ–≤—ã–π –º–µ—Ç–æ–¥ –¥–ª—è –º–∏—Å—Å–∏–∏ –≤–º–µ—Å—Ç–æ startAllServices()
                    serviceOrchestrator.startMissionServices();

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    logger.error("–ê–≤—Ç–æ—Å—Ç–∞—Ä—Ç –ø—Ä–µ—Ä–≤–∞–Ω");
                } catch (Exception e) {
                    logger.error("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç–∞: {}", e.getMessage(), e);
                }
            }).start();
        }
    }
}package com.kefir.logistics.launcher_service.service;

import com.kefir.logistics.launcher_service.model.dto.DemoScenarioDTO;
import com.kefir.logistics.launcher_service.model.enums.DemoScenarioType;
import com.kefir.logistics.launcher_service.model.enums.ErrorType;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.*;

@Service
public class DemoScenarioService {

    private static final Logger logger = LoggerFactory.getLogger(DemoScenarioService.class);

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    private final Map<String, DemoScenarioDTO> activeScenarios = new HashMap<>();

    /**
     * –ì–ª–∞–≤–Ω—ã–π –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–π: –ö–∞—Å–∫–∞–¥–Ω—ã–µ –æ—à–∏–±–∫–∏ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤
     */
    public DemoScenarioDTO runCascadeErrorsDemo() {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ: –ö–ê–°–ö–ê–î–ù–´–ï –û–®–ò–ë–ö–ò");

        DemoScenarioDTO scenario = createCascadeErrorsScenario();
        activeScenarios.put(scenario.getScenarioType().name(), scenario);

        // –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        new Thread(() -> executeCascadeErrorsScenario(scenario)).start();

        return scenario;
    }

    private DemoScenarioDTO createCascadeErrorsScenario() {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(DemoScenarioType.CASCADE_ERRORS);
        scenario.setTitle("–ö–∞—Å–∫–∞–¥–Ω—ã–µ –æ—à–∏–±–∫–∏ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤");
        scenario.setDescription("–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ–∞–ª—å–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã –ª–æ–≥–∏—Å—Ç–∏–∫–∏: " +
                "–æ–¥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä –≤—ã–∑—ã–≤–∞–µ—Ç —Ü–µ–ø–æ—á–∫—É –ø—Ä–æ–±–ª–µ–º, –ø—Ä–∏–≤–æ–¥—è—â—É—é " +
                "–∫ –¥–æ—Å—Ç–∞–≤–∫–µ —Ç–æ–ª—å–∫–æ 2 –∏–∑ 6 —Ç–æ–≤–∞—Ä–æ–≤ –∫–ª–∏–µ–Ω—Ç—É.");
        scenario.setStartTime(LocalDateTime.now());
        scenario.setRunning(true);

        // –®–∞–≥–∏ —Å—Ü–µ–Ω–∞—Ä–∏—è
        List<String> steps = new ArrayList<>();
        steps.add("1Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞: –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –¥–µ—Ñ–∏—Ü–∏—Ç—ã —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("2Ô∏è‚É£ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ –Ω–∞ 6 —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("3Ô∏è‚É£ –°–∏—Å—Ç–µ–º–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç '–≤—Å–µ —Ç–æ–≤–∞—Ä—ã –≤ –Ω–∞–ª–∏—á–∏–∏' (–ª–æ–∂—å!)");
        steps.add("4Ô∏è‚É£ –°–±–æ—Ä—â–∏–∫ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –π–æ–≥—É—Ä—Ç–∞");
        steps.add("5Ô∏è‚É£ 15-–º–∏–Ω—É—Ç–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ: –æ—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º");
        steps.add("6Ô∏è‚É£ –ö–ê–¢–ê–°–¢–†–û–§–ê: –ó–∞ —ç—Ç–æ –≤—Ä–µ–º—è –¥—Ä—É–≥–∏–µ –∫–ª–∏–µ–Ω—Ç—ã –∑–∞–±–∏—Ä–∞—é—Ç —Ç–æ–≤–∞—Ä—ã");
        steps.add("7Ô∏è‚É£ –†–µ–∑—É–ª—å—Ç–∞—Ç: –ö–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç —Ç–æ–ª—å–∫–æ 2 –∏–∑ 6 —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("8Ô∏è‚É£ –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏: 1,689 —Ä—É–± –∏–∑ 2,184 —Ä—É–±");
        scenario.setSteps(steps);

        // –°–∏–º—É–ª–∏—Ä—É–µ–º—ã–µ –æ—à–∏–±–∫–∏
        List<ErrorType> errors = Arrays.asList(
                ErrorType.PRODUCT_NOT_FOUND,
                ErrorType.LOW_STOCK,
                ErrorType.TRANSACTION_TIMEOUT
        );
        scenario.setSimulatedErrors(errors);

        // –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        Map<String, Object> testData = new HashMap<>();
        testData.put("orderId", "ORDER-" + System.currentTimeMillis());
        testData.put("clientId", "CLIENT-DEMO-001");
        testData.put("collectorId", "COLLECTOR-DEMO-001");
        testData.put("products", Arrays.asList("–ú–æ–ª–æ–∫–æ", "–•–ª–µ–±", "–ô–æ–≥—É—Ä—Ç", "–Ø–π—Ü–∞", "–°—ã—Ä", "–ú–∞—Å–ª–æ"));
        testData.put("quantities", Arrays.asList(2, 1, 4, 10, 5, 3));
        scenario.setTestData(testData);

        return scenario;
    }

    private void executeCascadeErrorsScenario(DemoScenarioDTO scenario) {
        try {
            logger.info("=== –ù–ê–ß–ê–õ–û –î–ï–ú–û: –ö–ê–°–ö–ê–î–ù–´–ï –û–®–ò–ë–ö–ò ===");

            // –®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤
            scenario.getSteps().set(0, "‚úÖ " + scenario.getSteps().get(0));
            logger.info("–®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã...");

            // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
            serviceOrchestrator.startService(ServiceType.SKLAD_SERVICE);           // ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
            serviceOrchestrator.startService(ServiceType.BACKET_SERVICE);          // ‚Üê —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ
            serviceOrchestrator.startService(ServiceType.COLLECTOR_SERVICE);       // ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
            serviceOrchestrator.startService(ServiceType.OFFICE_SERVICE);

            Thread.sleep(5000);

            // –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –¥–µ—Ñ–∏—Ü–∏—Ç—ã
            scenario.getSteps().set(1, "‚úÖ " + scenario.getSteps().get(1));
            logger.info("–®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –¥–µ—Ñ–∏—Ü–∏—Ç—ã —Ç–æ–≤–∞—Ä–æ–≤...");
            logger.info("  - –ô–æ–≥—É—Ä—Ç: 0 —à—Ç (—è–≤–Ω—ã–π –¥–µ—Ñ–∏—Ü–∏—Ç)");
            logger.info("  - –Ø–π—Ü–∞: 1 –∏–∑ 10 (—Å–∫—Ä—ã—Ç—ã–π –¥–µ—Ñ–∏—Ü–∏—Ç)");
            logger.info("  - –°—ã—Ä: 2 –∏–∑ 5 (—Å–∫—Ä—ã—Ç—ã–π –¥–µ—Ñ–∏—Ü–∏—Ç)");

            Thread.sleep(3000);

            // –®–∞–≥ 3: –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑
            scenario.getSteps().set(2, "‚úÖ " + scenario.getSteps().get(2));
            logger.info("–®–∞–≥ 3: –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ –Ω–∞ 6 —Ç–æ–≤–∞—Ä–æ–≤...");
            logger.info("  –°–∏—Å—Ç–µ–º–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç: '–í—Å–µ —Ç–æ–≤–∞—Ä—ã –≤ –Ω–∞–ª–∏—á–∏–∏'");

            Thread.sleep(3000);

            // –®–∞–≥ 4: –°–±–æ—Ä—â–∏–∫ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É
            scenario.getSteps().set(3, "‚úÖ " + scenario.getSteps().get(3));
            logger.info("–®–∞–≥ 4: –°–±–æ—Ä—â–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä–∫—É...");
            logger.info("  - –ú–æ–ª–æ–∫–æ ‚úì");
            logger.info("  - –•–ª–µ–± ‚úì");
            logger.info("  - –ô–æ–≥—É—Ä—Ç ‚ùå –ù–ï –ù–ê–ô–î–ï–ù!");

            // –°–∏–º—É–ª–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –æ—Ñ–∏—Å
            logger.info("  üì® –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –æ—Ñ–∏—Å");

            Thread.sleep(3000);

            // –®–∞–≥ 5: –û–∂–∏–¥–∞–Ω–∏–µ –∏ –∑–≤–æ–Ω–æ–∫ –∫–ª–∏–µ–Ω—Ç—É
            scenario.getSteps().set(4, "‚úÖ " + scenario.getSteps().get(4));
            logger.info("–®–∞–≥ 5: 15-–º–∏–Ω—É—Ç–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ...");
            logger.info("  üìû –û—Ñ–∏—Å –∑–≤–æ–Ω–∏—Ç –∫–ª–∏–µ–Ω—Ç—É: '–ô–æ–≥—É—Ä—Ç–∞ –Ω–µ—Ç. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?'");
            logger.info("  üë§ –ö–ª–∏–µ–Ω—Ç: '–î–∞, –ø—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –±–µ–∑ –π–æ–≥—É—Ä—Ç–∞'");

            Thread.sleep(2000);

            // –®–∞–≥ 6: –ö–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞ - –¥—Ä—É–≥–∏–µ –∫–ª–∏–µ–Ω—Ç—ã –∑–∞–±–∏—Ä–∞—é—Ç —Ç–æ–≤–∞—Ä—ã
            scenario.getSteps().set(5, "üî• " + scenario.getSteps().get(5));
            logger.info("–®–∞–≥ 6: –ö–ê–¢–ê–°–¢–†–û–§–ê –≤–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è!");
            logger.info("  –î—Ä—É–≥–∏–µ –∫–ª–∏–µ–Ω—Ç—ã –∑–∞–±—Ä–∞–ª–∏ —Ç–æ–≤–∞—Ä—ã:");
            logger.info("  - –Ø–π—Ü–∞: –±—ã–ª–æ 10, —Å—Ç–∞–ª–æ 3 (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç 7)");
            logger.info("  - –°—ã—Ä: –±—ã–ª–æ 5, —Å—Ç–∞–ª–æ 1 (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç 4)");
            logger.info("  - –ú–∞—Å–ª–æ: –±—ã–ª–æ 3, —Å—Ç–∞–ª–æ 1 (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç 2)");

            Thread.sleep(3000);

            // –®–∞–≥ 7: –ü–ª–∞—á–µ–≤–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            scenario.getSteps().set(6, "üí• " + scenario.getSteps().get(6));
            logger.info("–®–∞–≥ 7: –ò–¢–û–ì–û–í–´–ô –†–ï–ó–£–õ–¨–¢–ê–¢:");
            logger.info("  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            logger.info("  ‚îÇ  –û–ñ–ò–î–ê–õ–û–°–¨: 6 —Ç–æ–≤–∞—Ä–æ–≤      ‚îÇ");
            logger.info("  ‚îÇ  –ü–û–õ–£–ß–ï–ù–û: 2 —Ç–æ–≤–∞—Ä–∞        ‚îÇ");
            logger.info("  ‚îÇ  –£–°–ü–ï–®–ù–û–°–¢–¨: 33%           ‚îÇ");
            logger.info("  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
            logger.info("  –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: —Ç–æ–ª—å–∫–æ –ú–æ–ª–æ–∫–æ –∏ –•–ª–µ–±");

            // –®–∞–≥ 8: –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏
            scenario.getSteps().set(7, "üí∞ " + scenario.getSteps().get(7));
            Map<String, Object> results = new HashMap<>();
            results.put("totalOrderValue", 2184.87);
            results.put("deliveredValue", 335.48);
            results.put("losses", 1849.39);
            results.put("lossPercentage", 84.6);
            results.put("timeLost", "45+ –º–∏–Ω—É—Ç");
            results.put("clientSatisfaction", "–†–ê–ó–ì–ù–ï–í–ê–ù");

            scenario.setResults(results);

            logger.info("–®–∞–≥ 8: –§–ò–ù–ê–ù–°–û–í–´–ï –ü–û–¢–ï–†–ò:");
            logger.info("  - –°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞–∫–∞–∑–∞: 2,184.87 —Ä—É–±");
            logger.info("  - –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –Ω–∞: 335.48 —Ä—É–±");
            logger.info("  - –ü–û–¢–ï–†–ò: 1,849.39 —Ä—É–± (84.6%)");
            logger.info("  - –í—Ä–µ–º—è: 45+ –º–∏–Ω—É—Ç");
            logger.info("  - –ö–ª–∏–µ–Ω—Ç: –†–ê–ó–ì–ù–ï–í–ê–ù");

            // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏—è
            scenario.setEndTime(LocalDateTime.now());
            scenario.setRunning(false);

            logger.info("=== –ó–ê–í–ï–†–®–ï–ù–ò–ï –î–ï–ú–û ===");
            logger.info("üìä –î–µ–º–æ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {} —Å–µ–∫—É–Ω–¥",
                    java.time.Duration.between(scenario.getStartTime(), scenario.getEndTime()).getSeconds());

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("–î–µ–º–æ –ø—Ä–µ—Ä–≤–∞–Ω–æ: {}", e.getMessage());
            scenario.setRunning(false);
        }
    }

    /**
     * –î—Ä—É–≥–∏–µ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–∏
     */
    public DemoScenarioDTO runNormalProcessDemo() {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(DemoScenarioType.NORMAL_PROCESS);
        scenario.setTitle("–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–∫–∞–∑–∞");
        scenario.setDescription("–£—Å–ø–µ—à–Ω—ã–π –∑–∞–∫–∞–∑ –±–µ–∑ –æ—à–∏–±–æ–∫");
        // ... —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        return scenario;
    }

    public DemoScenarioDTO runSingleMissingItemDemo() {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(DemoScenarioType.SINGLE_MISSING_ITEM);
        scenario.setTitle("–û–¥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä");
        scenario.setDescription("–ö–ª–∏–µ–Ω—Ç —Å–æ–≥–ª–∞—à–∞–µ—Ç—Å—è –Ω–∞ –∑–∞–∫–∞–∑ –±–µ–∑ –æ–¥–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞");
        // ... —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        return scenario;
    }

    public List<DemoScenarioDTO> getAllScenarios() {
        return Arrays.asList(
                createCascadeErrorsScenario(),
                createScenario(DemoScenarioType.NORMAL_PROCESS),
                createScenario(DemoScenarioType.SINGLE_MISSING_ITEM),
                createScenario(DemoScenarioType.CLIENT_DEMANDS_ALL),
                createScenario(DemoScenarioType.NIGHTMARE_SCENARIO)
        );
    }

    private DemoScenarioDTO createScenario(DemoScenarioType type) {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(type);
        scenario.setTitle(type.getDescription());
        scenario.setRunning(false);
        return scenario;
    }

    public DemoScenarioDTO getActiveScenario(String scenarioType) {
        return activeScenarios.get(scenarioType);
    }
}package com.kefir.logistics.launcher_service.service;

import com.kefir.logistics.launcher_service.model.dto.LogEntryDTO;
import com.kefir.logistics.launcher_service.model.entity.ServiceLogEntity;
import org.springframework.stereotype.Service;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class LogStreamingService {

    private static final Pattern LOG_PATTERN = Pattern.compile(
            "(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}) (\\w+) (\\[.*?\\]) (\\[.*?\\]) (.*)"
    );

    private static final DateTimeFormatter LOG_DATE_FORMAT =
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

    public List<LogEntryDTO> getServiceLogs(String serviceName, int maxLines) {
        List<LogEntryDTO> logs = new ArrayList<>();
        File logFile = new File("./logs/" + serviceName + ".log");

        if (!logFile.exists()) {
            // –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ–± —ç—Ç–æ–º
            LogEntryDTO entry = LogEntryDTO.builder()
                    .timestamp(LocalDateTime.now())
                    .level("WARN")
                    .serviceName(serviceName)
                    .message("Log file not found: " + logFile.getAbsolutePath())
                    .build();
            logs.add(entry);
            return logs;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            List<String> lines = new ArrayList<>();
            String line;

            // –ß–∏—Ç–∞–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }

            // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ maxLines —Å—Ç—Ä–æ–∫
            int startIndex = Math.max(0, lines.size() - maxLines);
            for (int i = startIndex; i < lines.size(); i++) {
                LogEntryDTO logEntry = parseLogLine(lines.get(i), serviceName);
                if (logEntry != null) {
                    logs.add(logEntry);
                }
            }

        } catch (IOException e) {
            LogEntryDTO errorEntry = LogEntryDTO.builder()
                    .timestamp(LocalDateTime.now())
                    .level("ERROR")
                    .serviceName(serviceName)
                    .message("Error reading log file: " + e.getMessage())
                    .build();
            logs.add(errorEntry);
        }

        return logs;
    }

    public List<LogEntryDTO> searchLogs(String serviceName, String searchTerm,
                                        LocalDateTime from, LocalDateTime to) {
        List<LogEntryDTO> results = new ArrayList<>();
        File logFile = new File("./logs/" + serviceName + ".log");

        if (!logFile.exists()) {
            return results;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;

            while ((line = reader.readLine()) != null) {
                LogEntryDTO logEntry = parseLogLine(line, serviceName);
                if (logEntry != null) {
                    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                    boolean timeMatch = true;
                    if (from != null && logEntry.getTimestamp().isBefore(from)) {
                        timeMatch = false;
                    }
                    if (to != null && logEntry.getTimestamp().isAfter(to)) {
                        timeMatch = false;
                    }

                    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø–æ–∏—Å–∫–æ–≤–æ–º—É –∑–∞–ø—Ä–æ—Å—É
                    boolean textMatch = true;
                    if (searchTerm != null && !searchTerm.isEmpty()) {
                        textMatch = logEntry.getMessage().toLowerCase()
                                .contains(searchTerm.toLowerCase());
                    }

                    if (timeMatch && textMatch) {
                        results.add(logEntry);
                    }
                }
            }

        } catch (IOException e) {
            // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –Ω–æ –Ω–µ –ø–∞–¥–∞–µ–º
            System.err.println("Error searching logs: " + e.getMessage());
        }

        return results;
    }

    private LogEntryDTO parseLogLine(String logLine, String serviceName) {
        try {
            Matcher matcher = LOG_PATTERN.matcher(logLine);
            if (matcher.matches()) {
                LocalDateTime timestamp = LocalDateTime.parse(matcher.group(1), LOG_DATE_FORMAT);
                String level = matcher.group(2);
                String thread = matcher.group(3).replace("[", "").replace("]", "");
                String logger = matcher.group(4).replace("[", "").replace("]", "");
                String message = matcher.group(5);

                return LogEntryDTO.builder()
                        .timestamp(timestamp)
                        .level(level)
                        .serviceName(serviceName)
                        .thread(thread)
                        .logger(logger)
                        .message(message)
                        .build();
            }
        } catch (Exception e) {
            // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∑–∞–ø–∏—Å—å
            return LogEntryDTO.builder()
                    .timestamp(LocalDateTime.now())
                    .level("INFO")
                    .serviceName(serviceName)
                    .message(logLine)
                    .build();
        }

        return null;
    }

    public ServiceLogEntity convertToEntity(LogEntryDTO dto) {
        ServiceLogEntity entity = new ServiceLogEntity();
        entity.setServiceId(dto.getServiceName());
        entity.setLogLevel(dto.getLevel());
        entity.setMessage(dto.getMessage());
        entity.setTimestamp(dto.getTimestamp());
        entity.setThreadName(dto.getThread());
        entity.setLoggerName(dto.getLogger());
        entity.setStackTrace(dto.getStackTrace());
        return entity;
    }

    public LogEntryDTO convertToDTO(ServiceLogEntity entity) {
        return LogEntryDTO.builder()
                .timestamp(entity.getTimestamp())
                .level(entity.getLogLevel())
                .serviceName(entity.getServiceId())
                .thread(entity.getThreadName())
                .logger(entity.getLoggerName())
                .message(entity.getMessage())
                .stackTrace(entity.getStackTrace())
                .build();
    }
}package ru.kefir.service;

import org.springframework.stereotype.Service;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Service
public class ProcessManagerService {

    private final Map<Integer, Process> runningProcesses = new HashMap<>();
    private final Map<Integer, Integer> portToPidMap = new HashMap<>();

    public Process startService(String command, int port) throws IOException {
        Process process = Runtime.getRuntime().exec(command);
        runningProcesses.put(port, process);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º PID (–Ω—É–∂–Ω–æ –¥–ª—è Windows)
        try {
            // –ü–æ–ª—É—á–∞–µ–º PID –ø—Ä–æ—Ü–µ—Å—Å–∞
            long pid = process.pid();
            portToPidMap.put(port, (int) pid);
        } catch (UnsupportedOperationException e) {
            // –ù–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö pid() –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
            portToPidMap.put(port, -1);
        }

        return process;
    }

    public boolean stopService(int port) {
        Process process = runningProcesses.get(port);
        if (process != null) {
            process.destroy();
            try {
                if (process.isAlive()) {
                    process.destroyForcibly();
                }
            } catch (Exception e) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º
            }
            runningProcesses.remove(port);
            portToPidMap.remove(port);
            return true;
        }
        return false;
    }

    public void stopAllServices() {
        for (Integer port : runningProcesses.keySet()) {
            stopService(port);
        }
        runningProcesses.clear();
        portToPidMap.clear();
    }

    public Map<Integer, Process> getRunningProcesses() {
        return new HashMap<>(runningProcesses);
    }
}package com.kefir.logistics.launcher_service.service;


import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.model.enums.ServiceState;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class ServiceMonitor {

    private static final Logger logger = LoggerFactory.getLogger(ServiceMonitor.class);

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    private final Map<ServiceType, ServiceHealthInfo> healthCache = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        logger.info("Service Monitor initialized");

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫—ç—à –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
        for (ServiceType serviceType : ServiceType.values()) {
            healthCache.put(serviceType, new ServiceHealthInfo());
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
     */
    @Scheduled(fixedDelay = 30000)
    public void checkAllServicesHealth() {
        logger.debug("Running scheduled health check for all services");

        for (ServiceType serviceType : ServiceType.values()) {
            ServiceHealthInfo healthInfo = checkServiceHealth(serviceType);
            healthCache.put(serviceType, healthInfo);

            // –ï—Å–ª–∏ —Å–µ—Ä–≤–∏—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç
            ServiceStatusDTO status = serviceOrchestrator.getServiceStatus(serviceType);
            if (status != null && status.getState().isRunning() && !healthInfo.isHealthy()) {
                logger.warn("Service {} is running but not responding (HTTP: {})",
                        serviceType.getDisplayName(), healthInfo.getLastHttpStatus());

                // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π restart:
                // if (healthInfo.getConsecutiveFailures() > 3) {
                //     logger.info("Auto-restarting service {} due to health failures",
                //         serviceType.getDisplayName());
                //     serviceOrchestrator.restartService(serviceType);
                // }
            }
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
     */
    public ServiceHealthInfo checkServiceHealth(ServiceType serviceType) {
        ServiceHealthInfo healthInfo = healthCache.getOrDefault(serviceType, new ServiceHealthInfo());
        healthInfo.setLastCheckTime(LocalDateTime.now());

        try {
            // –ü—Ä–æ–±—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
            List<String> endpoints = Arrays.asList(
                    String.format("http://localhost:%d/actuator/health", serviceType.getPort()),
                    String.format("http://localhost:%d/actuator/info", serviceType.getPort()),
                    String.format("http://localhost:%d", serviceType.getPort())
            );

            boolean isHealthy = false;
            String response = null;
            int httpStatus = 0;

            for (String endpoint : endpoints) {
                try {
                    URL url = new URL(endpoint);
                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(5000);
                    connection.setReadTimeout(5000);

                    httpStatus = connection.getResponseCode();

                    if (httpStatus >= 200 && httpStatus < 300) {
                        isHealthy = true;
                        response = "HTTP " + httpStatus;
                        break;
                    }

                    connection.disconnect();

                } catch (IOException e) {
                    // –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π endpoint
                    continue;
                }
            }

            healthInfo.setHealthy(isHealthy);
            healthInfo.setLastHttpStatus(httpStatus);
            healthInfo.setLastResponse(response);

            if (isHealthy) {
                healthInfo.setConsecutiveFailures(0);
                healthInfo.setLastSuccessTime(LocalDateTime.now());
                logger.debug("Service {} is healthy (HTTP: {})",
                        serviceType.getDisplayName(), httpStatus);
            } else {
                healthInfo.incrementFailures();
                logger.warn("Service {} is unhealthy (HTTP: {})",
                        serviceType.getDisplayName(), httpStatus);
            }

        } catch (Exception e) {
            logger.error("Error checking health for {}: {}",
                    serviceType.getDisplayName(), e.getMessage());
            healthInfo.setHealthy(false);
            healthInfo.setLastResponse("Error: " + e.getMessage());
            healthInfo.incrementFailures();
        }

        return healthInfo;
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
     */
    public Map<ServiceType, ServiceHealthInfo> getAllServicesHealth() {
        Map<ServiceType, ServiceHealthInfo> result = new HashMap<>();

        for (ServiceType serviceType : ServiceType.values()) {
            ServiceHealthInfo healthInfo = healthCache.get(serviceType);
            if (healthInfo == null ||
                    healthInfo.getLastCheckTime() == null ||
                    healthInfo.getLastCheckTime().isBefore(LocalDateTime.now().minusMinutes(1))) {

                // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏, –æ–±–Ω–æ–≤–ª—è–µ–º
                healthInfo = checkServiceHealth(serviceType);
            }
            result.put(serviceType, healthInfo);
        }

        return result;
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
     */
    public Map<String, Object> getHealthSummary() {
        Map<ServiceType, ServiceHealthInfo> healthData = getAllServicesHealth();

        int totalServices = ServiceType.values().length;
        int healthyServices = 0;
        int unhealthyServices = 0;
        int unknownServices = 0;

        List<Map<String, Object>> detailedStatus = new ArrayList<>();

        for (Map.Entry<ServiceType, ServiceHealthInfo> entry : healthData.entrySet()) {
            ServiceHealthInfo healthInfo = entry.getValue();

            if (healthInfo.isHealthy()) {
                healthyServices++;
            } else if (healthInfo.getConsecutiveFailures() > 0) {
                unhealthyServices++;
            } else {
                unknownServices++;
            }

            Map<String, Object> serviceStatus = new HashMap<>();
            serviceStatus.put("service", entry.getKey().getDisplayName());
            serviceStatus.put("healthy", healthInfo.isHealthy());
            serviceStatus.put("lastCheck", healthInfo.getLastCheckTime());
            serviceStatus.put("responseTime", healthInfo.getResponseTime());
            serviceStatus.put("consecutiveFailures", healthInfo.getConsecutiveFailures());

            detailedStatus.add(serviceStatus);
        }

        Map<String, Object> summary = new HashMap<>();
        summary.put("timestamp", LocalDateTime.now());
        summary.put("totalServices", totalServices);
        summary.put("healthyServices", healthyServices);
        summary.put("unhealthyServices", unhealthyServices);
        summary.put("unknownServices", unknownServices);
        summary.put("healthPercentage", totalServices > 0 ?
                (healthyServices * 100.0 / totalServices) : 0);
        summary.put("detailedStatus", detailedStatus);

        return summary;
    }

    /**
     * –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫–ª–∞—Å—Å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∑–¥–æ—Ä–æ–≤—å–µ —Å–µ—Ä–≤–∏—Å–∞
     */
    public static class ServiceHealthInfo {
        private boolean healthy = false;
        private LocalDateTime lastCheckTime;
        private LocalDateTime lastSuccessTime;
        private int consecutiveFailures = 0;
        private int lastHttpStatus = 0;
        private String lastResponse;
        private long responseTime; // –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö

        // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
        public boolean isHealthy() { return healthy; }
        public void setHealthy(boolean healthy) { this.healthy = healthy; }

        public LocalDateTime getLastCheckTime() { return lastCheckTime; }
        public void setLastCheckTime(LocalDateTime lastCheckTime) { this.lastCheckTime = lastCheckTime; }

        public LocalDateTime getLastSuccessTime() { return lastSuccessTime; }
        public void setLastSuccessTime(LocalDateTime lastSuccessTime) { this.lastSuccessTime = lastSuccessTime; }

        public int getConsecutiveFailures() { return consecutiveFailures; }
        public void setConsecutiveFailures(int consecutiveFailures) { this.consecutiveFailures = consecutiveFailures; }
        public void incrementFailures() { this.consecutiveFailures++; }

        public int getLastHttpStatus() { return lastHttpStatus; }
        public void setLastHttpStatus(int lastHttpStatus) { this.lastHttpStatus = lastHttpStatus; }

        public String getLastResponse() { return lastResponse; }
        public void setLastResponse(String lastResponse) { this.lastResponse = lastResponse; }

        public long getResponseTime() { return responseTime; }
        public void setResponseTime(long responseTime) { this.responseTime = responseTime; }
    }
}package com.kefir.logistics.launcher_service.service;

import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.model.enums.ServiceState;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import com.kefir.logistics.launcher_service.util.PowerShellHelper;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;
import java.util.stream.Collectors;

@Service
public class ServiceOrchestrator {
    private static final Logger logger = LoggerFactory.getLogger(ServiceOrchestrator.class);

    @Autowired
    private PowerShellHelper powerShellHelper;

    @Value("${app.autoStart:false}")
    private boolean autoStartEnabled;

    @Value("${app.startup.delay.ms:3000}")
    private int startupDelayMs;

    @Value("${app.services.baseDir:C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend}")
    private String baseDirectory;

    private final Map<ServiceType, Process> runningProcesses = new ConcurrentHashMap<>();
    private final Map<ServiceType, ServiceStatusDTO> serviceStatuses = new ConcurrentHashMap<>();
    private final ExecutorService executorService = Executors.newCachedThreadPool();
    private final RestTemplate restTemplate = new RestTemplate();

    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –ø–æ—Ä—Ç–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏
    private static final Map<ServiceType, MissionConfig> MISSION_CONFIG = new HashMap<ServiceType, MissionConfig>() {{
        put(ServiceType.SAGA_SERVICE, new MissionConfig(true, 1, "–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π –¥–ª—è —Ä–µ—à–µ–Ω–∏—è"));
        put(ServiceType.SKLAD_SERVICE, new MissionConfig(true, 2, "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏—Ö —Ç–æ–≤–∞—Ä–æ–≤"));
        put(ServiceType.BACKET_SERVICE, new MissionConfig(true, 3, "–ù–∞—á–∞–ª–æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –∫–ª–∏–µ–Ω—Ç–æ–º"));
        put(ServiceType.COLLECTOR_SERVICE, new MissionConfig(true, 4, "–û–±–Ω–∞—Ä—É–∂–µ–Ω–∏–µ –æ—à–∏–±–∫–∏ —Å–±–æ—Ä—â–∏–∫–æ–º"));
        put(ServiceType.OFFICE_SERVICE, new MissionConfig(true, 5, "–°–≤—è–∑—å —Å –∫–ª–∏–µ–Ω—Ç–æ–º"));
        put(ServiceType.DELIVERY_SERVICE, new MissionConfig(false, 6, "–î–æ—Å—Ç–∞–≤–∫–∞"));
        put(ServiceType.USER_SERVICE, new MissionConfig(false, 7, "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏"));
        put(ServiceType.AUTH_SERVICE, new MissionConfig(true, 8, "–ê—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—è"));
        put(ServiceType.API_GATEWAY, new MissionConfig(true, 9, "–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞"));
    }};

    private static class MissionConfig {
        boolean requiredForMission;
        int startupOrder;
        String missionRole;

        MissionConfig(boolean requiredForMission, int startupOrder, String missionRole) {
            this.requiredForMission = requiredForMission;
            this.startupOrder = startupOrder;
            this.missionRole = missionRole;
        }
    }

    @PostConstruct
    public void init() {
        logger.info("=== SERVICE ORCHESTRATOR INITIALIZATION ===");
        logger.info("Mission: Demonstrate transaction error and solution via Saga");

        initializeServiceStatuses();

        if (autoStartEnabled) {
            new Thread(() -> {
                try {
                    Thread.sleep(startupDelayMs);
                    logger.info("=== AUTO-STARTING MISSION SERVICES ===");
                    startMissionServices();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        } else {
            logger.info("–ê–≤—Ç–æ—Å—Ç–∞—Ä—Ç –æ—Ç–∫–ª—é—á–µ–Ω. –°–µ—Ä–≤–∏—Å—ã –±—É–¥—É—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é.");
        }
    }

    private void initializeServiceStatuses() {
        for (ServiceType type : ServiceType.values()) {
            int port = getServicePort(type);
            ServiceStatusDTO status = ServiceStatusDTO.builder()
                    .serviceType(type)
                    .state(ServiceState.STOPPED)
                    .healthUrl("http://localhost:" + port + "/actuator/health")
                    .logPath("./logs/" + type.getId() + ".log")
                    .lastChecked(LocalDateTime.now())
                    .missionRole(getMissionRole(type))
                    .requiredForMission(isRequiredForMission(type))
                    .port(port)
                    .serviceName(type.getDisplayName())
                    .portOpen(false)
                    .build();

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω –ª–∏ —É–∂–µ —Å–µ—Ä–≤–∏—Å
            if (isPortOpen(port)) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ–º –ª–∏ –º—ã —ç—Ç–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º
                if (isPortManagedByUs(type, port)) {
                    status.setState(ServiceState.RUNNING);
                    status.setPortOpen(true);
                    logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} (–ø–æ—Ä—Ç {}) —É–∂–µ –∑–∞–ø—É—â–µ–Ω –Ω–∞–º–∏", type.getDisplayName(), port);
                } else {
                    // –ü–æ—Ä—Ç –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º
                    status.setState(ServiceState.EXTERNAL);
                    status.setPortOpen(true);
                    status.setManaged(false);
                    logger.warn("‚ö†Ô∏è –ü–æ—Ä—Ç {} –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º (—Å–µ—Ä–≤–∏—Å {})", port, type.getDisplayName());
                }
            }

            serviceStatuses.put(type, status);
        }
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {} —Å—Ç–∞—Ç—É—Å–æ–≤ —Å–µ—Ä–≤–∏—Å–æ–≤", ServiceType.values().length);
    }

    // ============ –û–°–ù–û–í–ù–´–ï –ú–ï–¢–û–î–´ ============

    /**
     * –ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã –≤ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ (–¥–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
     */
    public List<ServiceStatusDTO> startAllServices() {
        logger.info("üöÄ –ó–ê–ü–£–°–ö –í–°–ï–• –°–ï–†–í–ò–°–û–í KEFIR");

        // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–µ—Ä–≤–∏—Å—ã –ø–æ –ø–æ—Ä—è–¥–∫—É –∑–∞–ø—É—Å–∫–∞
        List<ServiceType> allServices = Arrays.stream(ServiceType.values())
                .sorted(Comparator.comparing(st -> {
                    MissionConfig config = MISSION_CONFIG.get(st);
                    return config != null ? config.startupOrder : 100;
                }))
                .collect(Collectors.toList());

        List<ServiceStatusDTO> results = new ArrayList<>();

        logger.info("1. üßπ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ –ø–æ—Ä—Ç–æ–≤...");
        releaseExternalPorts(allServices);

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã
        for (ServiceType serviceType : allServices) {
            try {
                logger.info("üöÄ –ó–∞–ø—É—Å–∫ {}...", serviceType.getDisplayName());
                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                // –ü–∞—É–∑–∞ –º–µ–∂–¥—É –∑–∞–ø—É—Å–∫–∞–º–∏
                if (!serviceType.equals(allServices.get(allServices.size() - 1))) {
                    Thread.sleep(3000);
                }

            } catch (Exception e) {
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å {}: {}", serviceType.getDisplayName(), e.getMessage());

                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .build();
                results.add(errorStatus);
            }
        }

        // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
        try {
            logger.info("‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ (15 —Å–µ–∫—É–Ω–¥)...");
            Thread.sleep(15000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        long successful = results.stream()
                .filter(s -> s.getState() != null && s.getState().isRunning())
                .count();

        logger.info("üìä –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω: {}/{} —É—Å–ø–µ—à–Ω–æ", successful, allServices.size());
        logger.info("=========================================");
        logger.info("üöÄ –ó–ê–ü–£–°–ö –ó–ê–í–ï–†–®–ï–ù");
        logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ: {}", successful);
        logger.info("‚ùå –ù–µ—É–¥–∞—á–Ω–æ: {}", allServices.size() - successful);
        logger.info("üìä –í—Å–µ–≥–æ: {}", allServices.size());
        logger.info("=========================================");

        return results;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø—É—â–µ–Ω—ã –ª–∏ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –º–∏—Å—Å–∏–∏
     */
    public boolean areMissionServicesRunning() {
        return serviceStatuses.values().stream()
                .filter(ServiceStatusDTO::isRequiredForMission)
                .allMatch(status -> status.getState() != null && status.getState().isRunning());
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø—É—â–µ–Ω –ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å
     */
    public boolean isServiceRunning(ServiceType serviceType) {
        ServiceStatusDTO status = serviceStatuses.get(serviceType);
        if (status == null || status.getState() == null) {
            return false;
        }
        return status.getState().isRunning();
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ —Å–µ—Ä–≤–∏—Å–∞
     */
    public boolean isServiceHealthy(ServiceType serviceType) {
        try {
            ServiceStatusDTO status = serviceStatuses.get(serviceType);
            if (status == null || status.getState() == null || !status.getState().isRunning()) {
                return false;
            }

            int port = getServicePort(serviceType);

            // 1. –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä—Ç–∞
            if (!isPortOpen(port)) {
                return false;
            }

            // 2. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
            String[] endpoints = {
                    "http://localhost:" + port + "/actuator/health",
                    "http://localhost:" + port + "/health",
                    "http://localhost:" + port + "/",
                    "http://localhost:" + port + "/api/health"
            };

            for (String endpoint : endpoints) {
                try {
                    ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);
                    if (response.getStatusCode().is2xxSuccessful()) {
                        logger.debug("‚úÖ –°–µ—Ä–≤–∏—Å {} –∑–¥–æ—Ä–æ–≤ (endpoint: {})", serviceType.getDisplayName(), endpoint);
                        return true;
                    }
                } catch (Exception e) {
                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–≤–µ—Ä—è—Ç—å –¥—Ä—É–≥–∏–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
                }
            }

            // 3. –ï—Å–ª–∏ –ø–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç, —Å—á–∏—Ç–∞–µ–º –∑–¥–æ—Ä–æ–≤—ã–º (–¥–∞–∂–µ –µ—Å–ª–∏ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –Ω–µ –æ—Ç–≤–µ—á–∞—é—Ç)
            logger.warn("–°–µ—Ä–≤–∏—Å {} –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {}, –Ω–æ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –Ω–µ –æ—Ç–≤–µ—á–∞—é—Ç",
                    serviceType.getDisplayName(), port);
            return true;

        } catch (Exception e) {
            logger.warn("–û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–∏—Å–∞ {}: {}", serviceType.getDisplayName(), e.getMessage());
            return false;
        }
    }

    /**
     * –ó–∞–ø—É—Å–∫–∞–µ—Ç —Å–µ—Ä–≤–∏—Å —Å –∏–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω–æ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
     */
    public ServiceStatusDTO startService(ServiceType serviceType) {
        String displayName = serviceType.getDisplayName();
        logger.info("üöÄ –ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–ê: {} (–º–∏—Å—Å–∏—è: {})", displayName, getMissionRole(serviceType));

        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω –ª–∏ —É–∂–µ —Å–µ—Ä–≤–∏—Å
            if (isServiceRunning(serviceType)) {
                if (isServiceHealthy(serviceType)) {
                    logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} —É–∂–µ –∑–∞–ø—É—â–µ–Ω –∏ –∑–¥–æ—Ä–æ–≤", displayName);
                    return serviceStatuses.get(serviceType);
                } else {
                    logger.warn("‚ö†Ô∏è –°–µ—Ä–≤–∏—Å {} –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –∑–¥–æ—Ä–æ–≤. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º...", displayName);
                    stopService(serviceType);
                    Thread.sleep(2000);
                }
            }

            updateServiceStatus(serviceType, ServiceState.STARTING, null);

            String directory = getServiceDirectory(serviceType);
            int port = getServicePort(serviceType);

            logger.info("üìÅ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {}", directory);
            logger.info("üîå –ü–æ—Ä—Ç: {}", port);
            logger.info("üéØ –†–æ–ª—å –≤ –º–∏—Å—Å–∏–∏: {}", getMissionRole(serviceType));

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é
            File serviceDir = new File(directory);
            if (!serviceDir.exists()) {
                String errorMsg = "‚ùå –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: " + directory;
                logger.error(errorMsg);
                updateServiceStatus(serviceType, ServiceState.FAILED, null, errorMsg);
                return serviceStatuses.get(serviceType);
            }

            // –û–°–û–ë–ï–ù–ù–û –í–ê–ñ–ù–û: –î–ª—è Saga —Å–µ—Ä–≤–∏—Å–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–æ—Ä—Ç
            if (serviceType == ServiceType.SAGA_SERVICE) {
                logger.info("üîß Transaction Saga Service - –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Å–µ—Ä–≤–∏—Å, –ø—Ä–æ–≤–µ—Ä—è—é –ø–æ—Ä—Ç 8090...");
                if (isPortOpen(port)) {
                    logger.warn("‚ö†Ô∏è –ü–æ—Ä—Ç 8090 –∑–∞–Ω—è—Ç. –û—Å–≤–æ–±–æ–∂–¥–∞—é –¥–ª—è Saga...");
                    boolean released = powerShellHelper.releasePortWithPowerShell(port);
                    if (!released) {
                        String errorMsg = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç 8090 –¥–ª—è Transaction Saga";
                        updateServiceStatus(serviceType, ServiceState.FAILED, null, errorMsg);
                        logger.error(errorMsg);
                        return serviceStatuses.get(serviceType);
                    }
                    Thread.sleep(3000);
                }
            } else {
                // –î–ª—è –¥—Ä—É–≥–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç –ª–∏ –ø–æ—Ä—Ç –Ω–∞—à–∏–º –∂–µ –ø—Ä–æ—Ü–µ—Å—Å–æ–º
                if (isPortOpen(port) && isPortManagedByUs(serviceType, port)) {
                    logger.info("‚úÖ –ü–æ—Ä—Ç {} —É–∂–µ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –Ω–∞—à–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º", port);
                } else if (isPortOpen(port)) {
                    // –ü–æ—Ä—Ç –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º - –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º —á–µ—Ä–µ–∑ PowerShell
                    logger.warn("‚ö†Ô∏è –ü–æ—Ä—Ç {} –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º, –æ—Å–≤–æ–±–æ–∂–¥–∞—é...", port);
                    boolean released = powerShellHelper.releasePortWithPowerShell(port);
                    if (!released) {
                        logger.warn("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {}, –ø—Ä–æ–±—É—é –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å...", port);
                    }
                    Thread.sleep(2000);
                }
            }

            // –°–æ–±–∏—Ä–∞–µ–º –∫–æ–º–∞–Ω–¥—É –¥–ª—è –∑–∞–ø—É—Å–∫–∞
            List<String> command = buildStartCommand(serviceType, port, directory);
            logger.debug("üíª –ö–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—Å–∫–∞: {}", String.join(" ", command));

            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            processBuilder.directory(serviceDir);
            processBuilder.redirectErrorStream(true);

            Process process = processBuilder.start();
            runningProcesses.put(serviceType, process);

            // –ß–∏—Ç–∞–µ–º –≤—ã–≤–æ–¥
            startOutputReader(serviceType, process);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –∑–∞–ø—É—Å–∫–∞
            checkServiceStartup(serviceType, process, port);

            return serviceStatuses.get(serviceType);

        } catch (Exception e) {
            logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–∏—Å {}: {}", displayName, e.getMessage(), e);
            updateServiceStatus(serviceType, ServiceState.FAILED, null, e.getMessage());
            return serviceStatuses.get(serviceType);
        }
    }

    /**
     * –ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏ –≤ –ø—Ä–∞–≤–∏–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
     */
    public List<ServiceStatusDTO> startMissionServices() {
        logger.info("üéØ –ó–ê–ü–£–°–ö –í–°–ï–• –°–ï–†–í–ò–°–û–í –î–õ–Ø –ú–ò–°–°–ò–ò KEFIR");

        // –ü–æ–ª—É—á–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã –≤ –ø–æ—Ä—è–¥–∫–µ –∑–∞–ø—É—Å–∫–∞ –¥–ª—è –º–∏—Å—Å–∏–∏
        List<ServiceType> missionServices = getMissionServicesInOrder();

        List<ServiceStatusDTO> results = new ArrayList<>();

        // –°–Ω–∞—á–∞–ª–∞ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
        logger.info("1. üßπ –û—Å–≤–æ–±–æ–∂–¥–∞—é –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤...");
        releaseExternalPortsForMission(missionServices);

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã –≤ –ø–æ—Ä—è–¥–∫–µ –≤–∞–∂–Ω–æ—Å—Ç–∏ –¥–ª—è –º–∏—Å—Å–∏–∏
        for (ServiceType serviceType : missionServices) {
            try {
                logger.info("üöÄ –ó–∞–ø—É—Å–∫ {} ({})...",
                        serviceType.getDisplayName(), getMissionRole(serviceType));

                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                // –û—Å–æ–±–µ–Ω–Ω–∞—è –ø–∞—É–∑–∞ –ø–æ—Å–ª–µ –∑–∞–ø—É—Å–∫–∞ Saga
                if (serviceType == ServiceType.SAGA_SERVICE) {
                    logger.info("‚è≥ –î–∞—é –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –¥–ª—è –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Saga...");
                    Thread.sleep(5000);
                } else {
                    Thread.sleep(3000);
                }

            } catch (Exception e) {
                logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ {}: {}", serviceType.getDisplayName(), e.getMessage());

                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .missionRole(getMissionRole(serviceType))
                        .build();
                results.add(errorStatus);
            }
        }

        // –ò—Ç–æ–≥–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        logger.info("üìä –ò–¢–û–ì–ò –ó–ê–ü–£–°–ö–ê –°–ï–†–í–ò–°–û–í –î–õ–Ø –ú–ò–°–°–ò–ò:");
        long successful = results.stream()
                .filter(s -> s.getState() != null && s.getState().isRunning())
                .count();

        logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ: {}/{}", successful, missionServices.size());
        logger.info("‚ùå –ù–µ—É–¥–∞—á–Ω–æ: {}", missionServices.size() - successful);

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
        checkCriticalMissionServices();

        return results;
    }

    /**
     * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–µ—Ä–≤–∏—Å
     */
    public ServiceStatusDTO stopService(ServiceType serviceType) {
        String displayName = serviceType.getDisplayName();
        logger.info("üõë –û–°–¢–ê–ù–û–í–ö–ê –°–ï–†–í–ò–°–ê: {}", displayName);

        Process process = runningProcesses.get(serviceType);
        if (process != null && process.isAlive()) {
            try {
                // –ú—è–≥–∫–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
                process.destroy();
                if (process.waitFor(10, TimeUnit.SECONDS)) {
                    runningProcesses.remove(serviceType);
                    updateServiceStatus(serviceType, ServiceState.STOPPED, null);
                    logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", displayName);
                } else {
                    // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–∞—è –æ—Å—Ç–∞–Ω–æ–≤–∫–∞
                    process.destroyForcibly();
                    updateServiceStatus(serviceType, ServiceState.FAILED, null, "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
                    logger.warn("‚ö†Ô∏è –°–µ—Ä–≤–∏—Å {} –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", displayName);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                logger.error("‚ùå –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–µ—Ä–≤–∏—Å–∞ {}", displayName);
            }
        } else {
            logger.info("–°–µ—Ä–≤–∏—Å {} –Ω–µ –∑–∞–ø—É—â–µ–Ω –∏–ª–∏ —É–∂–µ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", displayName);
            updateServiceStatus(serviceType, ServiceState.STOPPED, null);
        }

        return serviceStatuses.get(serviceType);
    }

    /**
     * –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç —Å–µ—Ä–≤–∏—Å
     */
    public ServiceStatusDTO restartService(ServiceType serviceType) {
        String displayName = serviceType.getDisplayName();
        logger.info("üîÑ –ü–ï–†–ï–ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–ê: {}", displayName);

        stopService(serviceType);

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        return startService(serviceType);
    }

    /**
     * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤—Å–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
     */
    public Map<String, Object> stopAllRunningServices() {
        logger.info("üõë –û–°–¢–ê–ù–û–í–ö–ê –í–°–ï–• –ó–ê–ü–£–©–ï–ù–ù–´–• –°–ï–†–í–ò–°–û–í");

        Map<String, Object> result = new LinkedHashMap<>();
        List<String> stoppedServices = new ArrayList<>();

        runningProcesses.forEach((serviceType, process) -> {
            if (process != null && process.isAlive()) {
                try {
                    String displayName = serviceType.getDisplayName();
                    process.destroy();

                    if (process.waitFor(5, TimeUnit.SECONDS)) {
                        updateServiceStatus(serviceType, ServiceState.STOPPED, null);
                        stoppedServices.add(displayName);
                        logger.info("‚úÖ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: {}", displayName);
                    } else {
                        process.destroyForcibly();
                        updateServiceStatus(serviceType, ServiceState.FAILED, null, "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
                        logger.warn("‚ö†Ô∏è –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: {}", displayName);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–µ—Ä–≤–∏—Å–∞: {}", e.getMessage());
                }
            }
        });

        runningProcesses.clear();
        result.put("stoppedServices", stoppedServices);
        result.put("count", stoppedServices.size());
        result.put("timestamp", LocalDateTime.now());

        return result;
    }

    // ============ –ú–ï–¢–û–î–´ –î–õ–Ø –ú–ò–°–°–ò–ò ============

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å—ã —Å–µ—Ä–≤–∏—Å–æ–≤, –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö –¥–ª—è –º–∏—Å—Å–∏–∏
     */
    public List<ServiceStatusDTO> getMissionServiceStatuses() {
        return serviceStatuses.values().stream()
                .filter(ServiceStatusDTO::isRequiredForMission)
                .sorted(Comparator.comparing(s -> MISSION_CONFIG.get(s.getServiceType()).startupOrder))
                .collect(Collectors.toList());
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç—å —Å–∏—Å—Ç–µ–º—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏
     */
    public Map<String, Object> checkMissionReadiness() {
        Map<String, Object> result = new LinkedHashMap<>();
        List<Map<String, Object>> serviceChecks = new ArrayList<>();

        boolean allReady = true;
        boolean sagaAvailable = false;

        for (ServiceType serviceType : ServiceType.values()) {
            if (!isRequiredForMission(serviceType)) {
                continue;
            }

            Map<String, Object> check = new LinkedHashMap<>();
            check.put("service", serviceType.getDisplayName());
            check.put("port", getServicePort(serviceType));
            check.put("missionRole", getMissionRole(serviceType));
            check.put("required", true);

            boolean isRunning = isServiceRunning(serviceType);
            boolean isHealthy = isServiceHealthy(serviceType);

            check.put("running", isRunning);
            check.put("healthy", isHealthy);
            check.put("status", isRunning && isHealthy ? "READY" : "NOT_READY");

            if (!isRunning || !isHealthy) {
                allReady = false;
                check.put("issue", isRunning ? "–ó–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –∑–¥–æ—Ä–æ–≤" : "–ù–µ –∑–∞–ø—É—â–µ–Ω");
            }

            if (serviceType == ServiceType.SAGA_SERVICE) {
                sagaAvailable = isRunning && isHealthy;
                check.put("critical", true);
            }

            serviceChecks.add(check);
        }

        result.put("serviceChecks", serviceChecks);
        result.put("allReady", allReady);
        result.put("sagaAvailable", sagaAvailable);
        result.put("missionPossible", sagaAvailable); // –ú–∏—Å—Å–∏—è –≤–æ–∑–º–æ–∂–Ω–∞ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ Saga –¥–æ—Å—Ç—É–ø–µ–Ω
        result.put("timestamp", LocalDateTime.now());

        if (!sagaAvailable) {
            result.put("criticalMessage", "Transaction Saga Service –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω. –ú–∏—Å—Å–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞!");
            result.put("recommendation", "–ó–∞–ø—É—Å—Ç–∏—Ç–µ Transaction Saga Service –Ω–∞ –ø–æ—Ä—Ç—É 8090");
        } else if (!allReady) {
            result.put("recommendation", "–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ startMissionServices() –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –Ω–µ–¥–æ—Å—Ç–∞—é—â–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");
        } else {
            result.put("recommendation", "–í—Å–µ —Å–∏—Å—Ç–µ–º—ã –≥–æ—Ç–æ–≤—ã. –ú–æ–∂–Ω–æ –≤—ã–ø–æ–ª–Ω—è—Ç—å –º–∏—Å—Å–∏—é.");
        }

        return result;
    }

    /**
     * –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è
     */
    public List<ServiceStatusDTO> startServicesForDemo(List<ServiceType> servicesToStart) {
        logger.info("üé¨ –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ: {} —Å–µ—Ä–≤–∏—Å–æ–≤", servicesToStart.size());

        List<ServiceStatusDTO> results = new ArrayList<>();

        // –°–Ω–∞—á–∞–ª–∞ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
        releaseExternalPorts(servicesToStart);

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã
        for (ServiceType serviceType : servicesToStart) {
            try {
                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                Thread.sleep(2000);

            } catch (Exception e) {
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å {}: {}", serviceType.getDisplayName(), e.getMessage());

                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .build();
                results.add(errorStatus);
            }
        }

        return results;
    }

    /**
     * –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ (–±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è)
     */
    public List<ServiceStatusDTO> forceStartServicesForDemo(List<ServiceType> servicesToStart) {
        logger.info("‚ö° –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–´–ô –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ");

        List<ServiceStatusDTO> results = new ArrayList<>();

        // –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º –ø–æ—Ä—Ç—ã
        for (ServiceType serviceType : servicesToStart) {
            int port = getServicePort(serviceType);
            powerShellHelper.releasePortWithPowerShell(port);
        }

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã
        for (ServiceType serviceType : servicesToStart) {
            try {
                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                Thread.sleep(3000);

            } catch (Exception e) {
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å {}: {}", serviceType.getDisplayName(), e.getMessage());

                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .build();
                results.add(errorStatus);
            }
        }

        return results;
    }

    // ============ –ú–ï–¢–û–î–´ –î–õ–Ø –†–ê–ë–û–¢–´ –° –ü–û–†–¢–ê–ú–ò ============

    /**
     * –û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –ø–æ—Ä—Ç—ã –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏
     */
    public Map<String, Object> releaseExternalPortsForMission(List<ServiceType> missionServices) {
        logger.info("üîß –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤ –æ—Ç –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –¥–ª—è –º–∏—Å—Å–∏–∏");

        Map<String, Object> result = new LinkedHashMap<>();
        List<String> releasedPorts = new ArrayList<>();

        for (ServiceType serviceType : missionServices) {
            int port = getServicePort(serviceType);
            String serviceName = serviceType.getDisplayName();

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ–º –ª–∏ –º—ã —ç—Ç–∏–º –ø–æ—Ä—Ç–æ–º
            if (isPortManagedByUs(serviceType, port)) {
                logger.debug("–ü–æ—Ä—Ç {} ({}) —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –Ω–∞–º–∏, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º", port, serviceName);
                continue;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–Ω—è—Ç –ª–∏ –ø–æ—Ä—Ç
            if (isPortOpen(port)) {
                logger.info("‚ö†Ô∏è –ü–æ—Ä—Ç {} ({}) –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º, –æ—Å–≤–æ–±–æ–∂–¥–∞—é...", port, serviceName);

                boolean released = powerShellHelper.releasePortWithPowerShell(port);
                if (released) {
                    releasedPorts.add(port + " (" + serviceName + ")");
                    logger.info("‚úÖ –ü–æ—Ä—Ç {} –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω", port);
                } else {
                    logger.warn("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {}", port);
                }
            }
        }

        result.put("releasedPorts", releasedPorts);
        result.put("count", releasedPorts.size());
        result.put("method", "PowerShell");
        result.put("timestamp", LocalDateTime.now());

        return result;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—Ç–∞—Ç—É—Å –≤—Å–µ—Ö –ø–æ—Ä—Ç–æ–≤ KEFIR
     */
    public Map<String, Object> checkAllPortsStatus() {
        logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ –≤—Å–µ—Ö –ø–æ—Ä—Ç–æ–≤ KEFIR");

        Map<String, Object> result = new LinkedHashMap<>();
        Map<String, Map<String, Object>> portStatus = new LinkedHashMap<>();

        int managed = 0;
        int external = 0;
        int free = 0;

        for (ServiceType serviceType : ServiceType.values()) {
            int port = getServicePort(serviceType);
            String serviceName = serviceType.getDisplayName();

            Map<String, Object> status = new LinkedHashMap<>();
            status.put("port", port);
            status.put("service", serviceName);
            status.put("missionRole", getMissionRole(serviceType));

            boolean isManaged = isPortManagedByUs(serviceType, port);
            boolean isOccupied = isPortOpen(port);

            status.put("occupied", isOccupied);
            status.put("managed", isManaged);

            if (isManaged) {
                status.put("status", "MANAGED");
                status.put("action", "–ù–µ —Ç—Ä–æ–≥–∞—Ç—å (—É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º)");
                managed++;
            } else if (isOccupied) {
                status.put("status", "EXTERNAL");
                status.put("action", "–ú–æ–∂–Ω–æ –æ—Å–≤–æ–±–æ–¥–∏—Ç—å");
                external++;
            } else {
                status.put("status", "FREE");
                status.put("action", "–°–≤–æ–±–æ–¥–µ–Ω –¥–ª—è –∑–∞–ø—É—Å–∫–∞");
                free++;
            }

            portStatus.put(serviceName, status);
        }

        result.put("portStatus", portStatus);
        result.put("summary", Map.of(
                "total", ServiceType.values().length,
                "managed", managed,
                "external", external,
                "free", free
        ));
        result.put("timestamp", LocalDateTime.now());

        return result;
    }

    // ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ============

    private String getServiceDirectory(ServiceType serviceType) {
        Map<ServiceType, String> directories = new HashMap<ServiceType, String>() {{
            put(ServiceType.AUTH_SERVICE, baseDirectory + "\\Auth");
            put(ServiceType.USER_SERVICE, baseDirectory + "\\User");
            put(ServiceType.SKLAD_SERVICE, baseDirectory + "\\Sklad");
            put(ServiceType.BACKET_SERVICE, baseDirectory + "\\Backet");
            put(ServiceType.OFFICE_SERVICE, baseDirectory + "\\Office");
            put(ServiceType.COLLECTOR_SERVICE, baseDirectory + "\\Collector");
            put(ServiceType.DELIVERY_SERVICE, baseDirectory + "\\Delivery");
            put(ServiceType.SAGA_SERVICE, baseDirectory + "\\TransactionSaga");
            put(ServiceType.API_GATEWAY, baseDirectory + "\\ApiGateWay");
        }};

        return directories.getOrDefault(serviceType, baseDirectory);
    }

    private int getServicePort(ServiceType serviceType) {
        return serviceType.getDefaultPort();
    }

    private String getMissionRole(ServiceType serviceType) {
        MissionConfig config = MISSION_CONFIG.get(serviceType);
        return config != null ? config.missionRole : "–í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–π —Å–µ—Ä–≤–∏—Å";
    }

    private boolean isRequiredForMission(ServiceType serviceType) {
        MissionConfig config = MISSION_CONFIG.get(serviceType);
        return config != null && config.requiredForMission;
    }

    private List<ServiceType> getMissionServicesInOrder() {
        return Arrays.stream(ServiceType.values())
                .filter(this::isRequiredForMission)
                .sorted(Comparator.comparing(st -> MISSION_CONFIG.get(st).startupOrder))
                .collect(Collectors.toList());
    }

    private List<String> buildStartCommand(ServiceType serviceType, int port, String directory) {
        List<String> command = new ArrayList<>();
        command.add("cmd");
        command.add("/c");
        command.add("cd");
        command.add("/d");
        command.add(directory);
        command.add("&&");
        command.add("echo");
        command.add("=== Starting " + serviceType.getDisplayName() + " for KEFIR Mission ===");
        command.add("&&");
        command.add("echo");
        command.add("Mission Role: " + getMissionRole(serviceType));
        command.add("&&");
        command.add("mvn");
        command.add("spring-boot:run");
        command.add("-Dserver.port=" + port);
        command.add("-DskipTests");

        return command;
    }

    private void startOutputReader(ServiceType serviceType, Process process) {
        executorService.submit(() -> {
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()))) {

                String line;
                while ((line = reader.readLine()) != null) {
                    logger.debug("[{}] {}", serviceType.getId(), line);

                    if (line.contains("Started") && line.contains("seconds")) {
                        logger.info("üéâ {} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –∑–∞ {} —Å–µ–∫—É–Ω–¥",
                                serviceType.getDisplayName(),
                                extractStartupTime(line));
                    }

                    if (line.contains("ERROR") || line.contains("Failed to start")) {
                        logger.warn("‚ö†Ô∏è –û—à–∏–±–∫–∞ –≤ {}: {}", serviceType.getDisplayName(), line);
                    }

                    // –û—Å–æ–±—ã–π –ª–æ–≥ –¥–ª—è Saga
                    if (serviceType == ServiceType.SAGA_SERVICE && line.contains("transaction")) {
                        logger.info("üîó Saga: {}", line);
                    }
                }
            } catch (IOException e) {
                logger.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞ {}: {}", serviceType.getDisplayName(), e.getMessage());
            }
        });
    }

    private void checkServiceStartup(ServiceType serviceType, Process process, int port) {
        executorService.submit(() -> {
            try {
                // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–ø—É—Å–∫ (–¥–æ–ª—å—à–µ –¥–ª—è Saga)
                int waitTime = (serviceType == ServiceType.SAGA_SERVICE) ? 20000 : 15000;
                Thread.sleep(waitTime);

                if (process.isAlive()) {
                    if (isPortOpen(port)) {
                        updateServiceStatus(serviceType, ServiceState.RUNNING, process.pid());
                        logger.info("‚úÖ {} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {}",
                                serviceType.getDisplayName(), port);

                        // –ó–∞–ø—É—Å–∫–∞–µ–º –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–¥–æ—Ä–æ–≤—å—è –¥–ª—è –≤–∞–∂–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
                        if (isRequiredForMission(serviceType)) {
                            startHealthMonitoring(serviceType);
                        }
                    } else {
                        String errorMsg = "–ü–æ—Ä—Ç " + port + " –Ω–µ –æ—Ç–∫—Ä—ã—Ç –ø–æ—Å–ª–µ " + (waitTime/1000) + " —Å–µ–∫—É–Ω–¥";
                        updateServiceStatus(serviceType, ServiceState.FAILED, null, errorMsg);
                        logger.error("‚ùå {} –∑–∞–ø—É—â–µ–Ω, –Ω–æ –ø–æ—Ä—Ç {} –Ω–µ –æ—Ç–∫—Ä—ã—Ç",
                                serviceType.getDisplayName(), port);
                    }
                } else {
                    updateServiceStatus(serviceType, ServiceState.FAILED, null, "–ü—Ä–æ—Ü–µ—Å—Å –∑–∞–≤–µ—Ä—à–∏–ª—Å—è");
                    logger.error("‚ùå –ü—Ä–æ—Ü–µ—Å—Å {} –∑–∞–≤–µ—Ä—à–∏–ª—Å—è", serviceType.getDisplayName());
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }
        });
    }

    private void updateServiceStatus(ServiceType serviceType, ServiceState state,
                                     Long pid, String... errorMessage) {
        ServiceStatusDTO status = serviceStatuses.get(serviceType);
        if (status != null) {
            status.setState(state);
            if (pid != null) {
                status.setPid(pid.intValue());
            }
            if (errorMessage.length > 0) {
                status.setErrorMessage(errorMessage[0]);
            }
            if (state == ServiceState.RUNNING) {
                status.setStartedAt(LocalDateTime.now());
                status.setPortOpen(true);
            }
            if (state == ServiceState.EXTERNAL) {
                status.setManaged(false);
            }
            status.setLastChecked(LocalDateTime.now());
        }
    }

    private void startHealthMonitoring(ServiceType serviceType) {
        executorService.submit(() -> {
            int port = getServicePort(serviceType);
            String displayName = serviceType.getDisplayName();

            while (runningProcesses.containsKey(serviceType)) {
                try {
                    Thread.sleep(30000); // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥

                    if (!isServiceHealthy(serviceType)) {
                        logger.warn("‚ö†Ô∏è –°–µ—Ä–≤–∏—Å {} (–ø–æ—Ä—Ç {}) –Ω–µ –∑–¥–æ—Ä–æ–≤, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º...",
                                displayName, port);
                        restartService(serviceType);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
    }

    private void checkCriticalMissionServices() {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º Saga –≤ –ø–µ—Ä–≤—É—é –æ—á–µ—Ä–µ–¥—å
        if (!isServiceRunning(ServiceType.SAGA_SERVICE) || !isServiceHealthy(ServiceType.SAGA_SERVICE)) {
            logger.error("‚ùå –ö–†–ò–¢–ò–ß–ï–°–ö–ê–Ø –û–®–ò–ë–ö–ê: Transaction Saga Service –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω!");
            logger.error("   –ë–µ–∑ Saga –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –º–∏—Å—Å–∏–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ!");
            logger.error("   –ü–æ—Ä—Ç: 8090, –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {}\\TransactionSaga", baseDirectory);
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥—Ä—É–≥–∏–µ –∫–ª—é—á–µ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã
        ServiceType[] criticalServices = {
                ServiceType.SKLAD_SERVICE,
                ServiceType.BACKET_SERVICE,
                ServiceType.COLLECTOR_SERVICE,
                ServiceType.OFFICE_SERVICE
        };

        for (ServiceType service : criticalServices) {
            if (!isServiceRunning(service)) {
                logger.warn("‚ö†Ô∏è –ö–ª—é—á–µ–≤–æ–π —Å–µ—Ä–≤–∏—Å {} –Ω–µ –∑–∞–ø—É—â–µ–Ω", service.getDisplayName());
            }
        }
    }

    private void releaseExternalPorts(List<ServiceType> services) {
        for (ServiceType serviceType : services) {
            int port = getServicePort(serviceType);

            if (isPortOpen(port) && !isPortManagedByUs(serviceType, port)) {
                logger.info("–û—Å–≤–æ–±–æ–∂–¥–∞—é –ø–æ—Ä—Ç {} –æ—Ç –≤–Ω–µ—à–Ω–µ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞...", port);
                powerShellHelper.releasePortWithPowerShell(port);

                try {
                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }

    private boolean isPortManagedByUs(ServiceType serviceType, int port) {
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —É –Ω–∞—Å –ø—Ä–æ—Ü–µ—Å—Å –Ω–∞ —ç—Ç–æ–º –ø–æ—Ä—Ç—É
        Process ourProcess = runningProcesses.get(serviceType);
        if (ourProcess != null && ourProcess.isAlive()) {
            return true;
        }

        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ PowerShell
        String pid = powerShellHelper.getProcessIdOnPortPowerShell(port);
        if (pid != null) {
            // –ü–æ–∫–∞ —Å—á–∏—Ç–∞–µ–º, —á—Ç–æ –µ—Å–ª–∏ –ø–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç –∏ —É –Ω–∞—Å –µ—Å—Ç—å —Å—Ç–∞—Ç—É—Å RUNNING, —Ç–æ —ç—Ç–æ –Ω–∞—à
            ServiceStatusDTO status = serviceStatuses.get(serviceType);
            return status != null && status.getState() == ServiceState.RUNNING;
        }

        return false;
    }

    private boolean isPortOpen(int port) {
        try (Socket socket = new Socket()) {
            socket.connect(new InetSocketAddress("localhost", port), 1000);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private String extractStartupTime(String logLine) {
        // –ò–∑–≤–ª–µ–∫–∞–µ–º –≤—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞ –∏–∑ —Å—Ç—Ä–æ–∫–∏ "Started Application in 5.234 seconds"
        try {
            if (logLine.contains("Started") && logLine.contains("seconds")) {
                String[] parts = logLine.split(" ");
                for (int i = 0; i < parts.length; i++) {
                    if (parts[i].equals("in") && i + 1 < parts.length) {
                        return parts[i + 1];
                    }
                }
            }
        } catch (Exception e) {
            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –æ—à–∏–±–∫–∏ –ø–∞—Ä—Å–∏–Ω–≥–∞
        }
        return "unknown";
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
     */
    public Map<ServiceType, ServiceStatusDTO> getAllServiceStatuses() {
        return new HashMap<>(serviceStatuses);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
     */
    public ServiceStatusDTO getServiceStatus(ServiceType serviceType) {
        return serviceStatuses.get(serviceType);
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Å–µ—Å—Å–∏–π
     */
    public long getActiveSessionsCount() {
        return runningProcesses.values().stream()
                .filter(process -> process != null && process.isAlive())
                .count();
    }
package com.kefir.logistics.launcher_service.util;

public class LogTailer {
}

package com.kefir.logistics.launcher_service.util;

public class PortChecker {
}
package com.kefir.logistics.launcher_service.util;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;

import java.io.BufferedReader;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.List;

@Component
public class PowerShellHelper {
    private static final Logger logger = LoggerFactory.getLogger(PowerShellHelper.class);

    /**
     * –û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –ø–æ—Ä—Ç —Å –ø–æ–º–æ—â—å—é PowerShell —Å–∫—Ä–∏–ø—Ç–∞
     * –ò—Å–ø–æ–ª—å–∑—É–µ—Ç –≤–∞—à –ò–î–ï–ê–õ–¨–ù–´–ô —Å–∫—Ä–∏–ø—Ç
     */
    public boolean releasePortWithPowerShell(int port) {
        logger.info("üîß –û—Å–≤–æ–±–æ–∂–¥–∞—é –ø–æ—Ä—Ç {} —Å –ø–æ–º–æ—â—å—é PowerShell", port);

        String command = buildPowerShellCommand(port);

        try {
            logger.debug("–í—ã–ø–æ–ª–Ω—è—é –∫–æ–º–∞–Ω–¥—É: {}", command);

            Process process = Runtime.getRuntime().exec(command);

            // –ß–∏—Ç–∞–µ–º –≤—ã–≤–æ–¥ —Å–∫—Ä–∏–ø—Ç–∞
            BufferedReader outputReader = new BufferedReader(
                    new InputStreamReader(process.getInputStream(), "CP866")); // Windows CP866
            BufferedReader errorReader = new BufferedReader(
                    new InputStreamReader(process.getErrorStream(), "CP866"));

            StringBuilder output = new StringBuilder();
            String line;

            while ((line = outputReader.readLine()) != null) {
                output.append(line).append("\n");
                logger.debug("PowerShell: {}", line);
            }

            while ((line = errorReader.readLine()) != null) {
                logger.error("PowerShell Error: {}", line);
            }

            int exitCode = process.waitFor();
            logger.info("PowerShell —Å–∫—Ä–∏–ø—Ç –∑–∞–≤–µ—Ä—à–∏–ª—Å—è —Å –∫–æ–¥–æ–º: {}", exitCode);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            boolean success = (exitCode == 0);

            if (success) {
                logger.info("‚úÖ PowerShell —É—Å–ø–µ—à–Ω–æ –æ—Å–≤–æ–±–æ–¥–∏–ª –ø–æ—Ä—Ç {}", port);
            } else {
                logger.warn("‚ö†Ô∏è PowerShell –Ω–µ —Å–º–æ–≥ –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {}", port);
            }

            return success;

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ PowerShell —Å–∫—Ä–∏–ø—Ç–∞: {}", e.getMessage(), e);
            return false;
        }
    }

    /**
     * –û—Å–≤–æ–±–æ–∂–¥–∞–µ—Ç –Ω–µ—Å–∫–æ–ª—å–∫–æ –ø–æ—Ä—Ç–æ–≤ –∑–∞ –æ–¥–∏–Ω –≤—ã–∑–æ–≤
     */
    public boolean releasePortsWithPowerShell(List<Integer> ports) {
        if (ports == null || ports.isEmpty()) {
            logger.info("–ù–µ—Ç –ø–æ—Ä—Ç–æ–≤ –¥–ª—è –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏—è");
            return true;
        }

        logger.info("üîß –û—Å–≤–æ–±–æ–∂–¥–∞—é {} –ø–æ—Ä—Ç–æ–≤ —Å –ø–æ–º–æ—â—å—é PowerShell: {}", ports.size(), ports);

        String command = buildMultiPortPowerShellCommand(ports);

        try {
            Process process = Runtime.getRuntime().exec(command);

            // –ß–∏—Ç–∞–µ–º –≤—ã–≤–æ–¥
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream(), "CP866"))) {

                String line;
                while ((line = reader.readLine()) != null) {
                    if (line.contains("‚úÖ") || line.contains("—Å–≤–æ–±–æ–¥–µ–Ω")) {
                        logger.info("PowerShell: {}", line);
                    } else if (line.contains("‚ùå") || line.contains("–æ—à–∏–±–∫–∞")) {
                        logger.error("PowerShell: {}", line);
                    } else {
                        logger.debug("PowerShell: {}", line);
                    }
                }
            }

            int exitCode = process.waitFor();
            boolean success = (exitCode == 0);

            logger.info("PowerShell —Å–∫—Ä–∏–ø—Ç –¥–ª—è {} –ø–æ—Ä—Ç–æ–≤ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è: {}",
                    ports.size(), success ? "–£–°–ü–ï–®–ù–û" : "–° –û–®–ò–ë–ö–û–ô");

            return success;

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–∏ PowerShell —Å–∫—Ä–∏–ø—Ç–∞ –¥–ª—è –ø–æ—Ä—Ç–æ–≤: {}", e.getMessage());
            return false;
        }
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç PID –ø—Ä–æ—Ü–µ—Å—Å–∞, –∑–∞–Ω–∏–º–∞—é—â–µ–≥–æ –ø–æ—Ä—Ç (PowerShell –≤–µ—Ä—Å–∏—è)
     */
    public String getProcessIdOnPortPowerShell(int port) {
        String command = String.format(
                "powershell.exe -Command \"Get-NetTCPConnection -LocalPort %d -ErrorAction SilentlyContinue | " +
                        "Select-Object -ExpandProperty OwningProcess | Select-Object -First 1\"",
                port
        );

        try {
            Process process = Runtime.getRuntime().exec(command);
            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()));

            String pid = reader.readLine();
            process.waitFor();

            if (pid != null && !pid.trim().isEmpty()) {
                return pid.trim();
            }

        } catch (Exception e) {
            logger.debug("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å PID —á–µ—Ä–µ–∑ PowerShell –¥–ª—è –ø–æ—Ä—Ç–∞ {}: {}", port, e.getMessage());
        }

        return null;
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, —Å–≤–æ–±–æ–¥–µ–Ω –ª–∏ –ø–æ—Ä—Ç (PowerShell –≤–µ—Ä—Å–∏—è)
     */
    public boolean isPortFreePowerShell(int port) {
        String command = String.format(
                "powershell.exe -Command \"$conn = Get-NetTCPConnection -LocalPort %d -ErrorAction SilentlyContinue; " +
                        "if ($conn) { Write-Output 'OCCUPIED' } else { Write-Output 'FREE' }\"",
                port
        );

        try {
            Process process = Runtime.getRuntime().exec(command);
            BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()));

            String result = reader.readLine();
            process.waitFor();

            return "FREE".equals(result);

        } catch (Exception e) {
            logger.debug("–ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ—Ä—Ç —á–µ—Ä–µ–∑ PowerShell: {}", e.getMessage());
            return false;
        }
    }

    private String buildPowerShellCommand(int port) {
        // –í–∞—à –ò–î–ï–ê–õ–¨–ù–´–ô —Å–∫—Ä–∏–ø—Ç –≤ –æ–¥–Ω—É —Å—Ç—Ä–æ–∫—É
        return String.format(
                "powershell.exe -Command \"$port = %d; " +
                        "$connection = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue; " +
                        "if ($connection) { " +
                        "    Write-Host '—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é –ø—Ä–æ—Ü–µ—Å—Å –Ω–∞ –ø–æ—Ä—Ç—É $port (PID: ' $connection.OwningProcess ')' -ForegroundColor Yellow; " +
                        "    Stop-Process -Id $connection.OwningProcess -Force; " +
                        "    Write-Host '‚úÖ –ü–æ—Ä—Ç $port –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω' -ForegroundColor Green; " +
                        "} else { " +
                        "    Write-Host '‚úÖ –ü–æ—Ä—Ç $port —Å–≤–æ–±–æ–¥–µ–Ω' -ForegroundColor Green; " +
                        "}\"",
                port
        );
    }

    private String buildMultiPortPowerShellCommand(List<Integer> ports) {
        StringBuilder sb = new StringBuilder();
        sb.append("powershell.exe -Command \"");

        for (Integer port : ports) {
            sb.append(String.format(
                    "$port = %d; " +
                            "$connection = Get-NetTCPConnection -LocalPort $port -ErrorAction SilentlyContinue; " +
                            "if ($connection) { " +
                            "    Write-Host '—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞—é –ø—Ä–æ—Ü–µ—Å—Å –Ω–∞ –ø–æ—Ä—Ç—É $port (PID: ' $connection.OwningProcess ')' -ForegroundColor Yellow; " +
                            "    Stop-Process -Id $connection.OwningProcess -Force; " +
                            "    Write-Host '‚úÖ –ü–æ—Ä—Ç $port –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω' -ForegroundColor Green; " +
                            "} else { " +
                            "    Write-Host '‚úÖ –ü–æ—Ä—Ç $port —Å–≤–æ–±–æ–¥–µ–Ω' -ForegroundColor Green; " +
                            "}; ",
                    port
            ));
        }

        sb.append("\"");
        return sb.toString();
    }
}package com.kefir.logistics.launcher_service.util;

public class ProcessExecutor {
}
package com.kefir.logistics.launcher_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class LauncherServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(LauncherServiceApplication.class, args);
    }
}server:
  port: 8099
  servlet:
    context-path: /

spring:
  application:
    name: launcher-service
  datasource:
    url: jdbc:h2:file:./data/launcherdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
  h2:
    console:
      enabled: true
      path: /h2-console
  main:
    banner-mode: off

launcher:
  base-dir: "../"
  logs-dir: "./logs"
  startup-delay-ms: 5000
  health-check-timeout-sec: 30
  auto-restart: true
  services:
    AUTH:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Auth"
      port: 8097
      display-name: "Auth Service"
    USER:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/User"
      port: 8081
      display-name: "User Service"
    Sklad:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Sklad"
      port: 8082
      display-name: "Warehouse Service"
    backet-service:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Backet"
      port: 8083
      display-name: "Shopping Cart Service"
    Office:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Office"
      port: 8085
      display-name: "Office Service"
    COLLECTOR:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Collector"
      port: 8086
      display-name: "Collector Service"
    Delivery:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Delivery"
      port: 8088
      display-name: "Delivery Service"
    TransactionSaga:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/TransactionSaga"
      port: 8090
      display-name: "Transaction Saga"
    ApiGateWay:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/ApiGateWay"
      port: 8080
      display-name: "API Gateway"
  auto-start: true
  auto-start-delay-ms: 5000
  auto-demo-delay-ms: 35000
  min-services-for-demo: 7
logging:
  level:
    com.kefir.logistics.launcher_service: INFO
    org.springframework.web: INFO
  file:
    name: logs/launcher-service.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"
            }
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.kefir.logistics</groupId>
    <artifactId>launcher-service</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Kefir Launcher Service</name>
    <description>Orchestration service for KEFIR Logistics with demo scenarios</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.5</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>17</java.version>
        <springdoc.version>2.2.0</springdoc.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Configuration Properties Support -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Documentation -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- JSON -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.annotation</groupId>
            <artifactId>jakarta.annotation-api</artifactId>
            <version>2.1.1</version>
        </dependency>
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>com.kefir.logistics.launcher_service.LauncherServiceApplication</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>

