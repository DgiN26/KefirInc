package com.kefir.logistics.launcher_service.config;

import org.springframework.boot.context.properties.ConfigurationProperties;
import org.springframework.stereotype.Component;
import org.springframework.validation.annotation.Validated;

import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotEmpty;
import java.util.Map;

@Component
@ConfigurationProperties(prefix = "launcher")
@Validated
public class ApplicationProperties {

    @NotEmpty
    private String baseDir = "../";

    @NotEmpty
    private String logsDir = "./logs";

    @Min(1000)
    private int startupDelayMs = 5000;

    @Min(5)
    private int healthCheckTimeoutSec = 30;

    private boolean autoRestart = true;

    private Map<String, ServiceConfig> services;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
    public ApplicationProperties() {
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getBaseDir() {
        return baseDir;
    }

    public void setBaseDir(String baseDir) {
        this.baseDir = baseDir;
    }

    public String getLogsDir() {
        return logsDir;
    }

    public void setLogsDir(String logsDir) {
        this.logsDir = logsDir;
    }

    public int getStartupDelayMs() {
        return startupDelayMs;
    }

    public void setStartupDelayMs(int startupDelayMs) {
        this.startupDelayMs = startupDelayMs;
    }

    public int getHealthCheckTimeoutSec() {
        return healthCheckTimeoutSec;
    }

    public void setHealthCheckTimeoutSec(int healthCheckTimeoutSec) {
        this.healthCheckTimeoutSec = healthCheckTimeoutSec;
    }

    public boolean isAutoRestart() {
        return autoRestart;
    }

    public void setAutoRestart(boolean autoRestart) {
        this.autoRestart = autoRestart;
    }

    public Map<String, ServiceConfig> getServices() {
        return services;
    }

    public void setServices(Map<String, ServiceConfig> services) {
        this.services = services;
    }

    public ServiceConfig getServiceConfig(String serviceId) {
        return services != null ? services.get(serviceId) : null;
    }

    public static class ServiceConfig {

        private String id;

        @NotEmpty
        private String directory;

        @Min(1024)
        private int port;

        @NotEmpty
        private String displayName;

        private String healthEndpoint = "/actuator/health";

        public ServiceConfig() {
        }

        public String getId() {
            return id;
        }

        public void setId(String id) {
            this.id = id;
        }

        public String getDirectory() {
            return directory;
        }

        public void setDirectory(String directory) {
            this.directory = directory;
        }

        public int getPort() {
            return port;
        }

        public void setPort(int port) {
            this.port = port;
        }

        public String getDisplayName() {
            return displayName;
        }

        public void setDisplayName(String displayName) {
            this.displayName = displayName;
        }

        public String getHealthEndpoint() {
            return healthEndpoint;
        }

        public void setHealthEndpoint(String healthEndpoint) {
            this.healthEndpoint = healthEndpoint;
        }

        @Override
        public String toString() {
            return String.format("ServiceConfig{id='%s', directory='%s', port=%d, displayName='%s'}",
                    id, directory, port, displayName);
        }
    }

    @Override
    public String toString() {
        return String.format("ApplicationProperties{baseDir='%s', logsDir='%s', servicesCount=%d}",
                baseDir, logsDir, services != null ? services.size() : 0);
    }
}package com.kefir.logistics.launcher_service.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.scheduling.annotation.AsyncConfigurer;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;
import java.util.concurrent.Executor;

@Configuration
@EnableAsync
public class AsyncConfig implements AsyncConfigurer {

    @Override
    public Executor getAsyncExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);           // –û—Å–Ω–æ–≤–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤
        executor.setMaxPoolSize(50);            // –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–æ—Ç–æ–∫–æ–≤
        executor.setQueueCapacity(100);         // –†–∞–∑–º–µ—Ä –æ—á–µ—Ä–µ–¥–∏ –∑–∞–¥–∞—á
        executor.setThreadNamePrefix("LauncherAsync-");
        executor.initialize();
        return executor;
    }
}package com.kefir.logistics.launcher_service.config;

import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component
public class SpringApplicationContextHolder implements ApplicationContextAware {
    private static ApplicationContext applicationContext;

    @Override
    public void setApplicationContext(ApplicationContext context) {
        applicationContext = context;
    }

    public static ApplicationContext getApplicationContext() {
        return applicationContext;
    }
}package com.kefir.logistics.launcher_service.config;

public class SwaggerConfig {
}
package com.kefir.logistics.launcher_service.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.CorsRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/api/**")
                .allowedOrigins(
                        "http://localhost:3000",    // React —Ñ—Ä–æ–Ω—Ç–µ–Ω–¥
                        "http://localhost:8080",    // API Gateway
                        "http://localhost:8081",    // User Service
                        "http://localhost:8090",    // Saga Service
                        "http://localhost:8097",    // Auth Service
                        "http://localhost:8099",    // ‚Üê –î–û–ë–ê–í–õ–ï–ù–û: –°–∞–º Launcher-service
                        "http://127.0.0.1:8099"     // ‚Üê –î–û–ë–ê–í–õ–ï–ù–û: –ê–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–π –∞–¥—Ä–µ—Å
                )
                .allowedMethods("GET", "POST", "PUT", "DELETE", "OPTIONS")
                .allowedHeaders("*")
                .allowCredentials(true)
                .maxAge(3600);
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.config.ApplicationProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/config")
public class ConfigController {

    @Autowired
    private ApplicationProperties appProperties;

    @GetMapping("/info")
    public Map<String, Object> getConfigInfo() {
        Map<String, Object> response = new HashMap<>();

        response.put("status", "OK");
        response.put("service", "Launcher Service Config");

        if (appProperties != null) {
            response.put("baseDir", appProperties.getBaseDir());
            response.put("logsDir", appProperties.getLogsDir());
            response.put("startupDelayMs", appProperties.getStartupDelayMs());
            response.put("healthCheckTimeoutSec", appProperties.getHealthCheckTimeoutSec());
            response.put("autoRestart", appProperties.isAutoRestart());

            if (appProperties.getServices() != null) {
                response.put("servicesCount", appProperties.getServices().size());
                response.put("services", appProperties.getServices());
            } else {
                response.put("servicesCount", 0);
                response.put("services", "No services configured");
            }
        } else {
            response.put("error", "ApplicationProperties not autowired");
        }

        response.put("timestamp", System.currentTimeMillis());

        return response;
    }

    @GetMapping("/check")
    public Map<String, String> checkConfig() {
        Map<String, String> response = new HashMap<>();

        if (appProperties == null) {
            response.put("status", "ERROR");
            response.put("message", "Configuration not loaded");
        } else if (appProperties.getServices() == null || appProperties.getServices().isEmpty()) {
            response.put("status", "WARNING");
            response.put("message", "Configuration loaded but no services defined");
        } else {
            response.put("status", "OK");
            response.put("message", "Configuration loaded successfully");
            response.put("servicesCount", String.valueOf(appProperties.getServices().size()));
        }

        return response;
    }

    @GetMapping("/ping")
    public Map<String, String> ping() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "pong");
        response.put("service", "launcher-service");
        response.put("time", java.time.LocalDateTime.now().toString());
        return response;
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.model.dto.DemoScenarioDTO;
import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.service.DemoScenarioService;
import com.kefir.logistics.launcher_service.service.ServiceOrchestrator;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.web.client.RestTemplateBuilder;
import org.springframework.http.*;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.web.bind.annotation.*;
import org.springframework.web.client.RestTemplate;

import jakarta.annotation.PreDestroy;
import jakarta.annotation.PostConstruct;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.time.Duration;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/demo")
@Tag(name = "Demo Scenarios", description = "–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è–º–∏ KEFIR")
@EnableScheduling
public class DemoController {
    private static final Logger logger = LoggerFactory.getLogger(DemoController.class);

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    @Autowired
    private DemoScenarioService demoScenarioService;

    @Value("${app.demo.startup.check:true}")
    private boolean startupCheckEnabled;

    @Value("${app.demo.autoStartScenario:none}")
    private String autoStartScenario;

    // –ö–ª—é—á–µ–≤—ã–µ –ø–æ—Ä—Ç—ã –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤ KEFIR
    private static final Map<String, Integer> KEFIR_SERVICES = new LinkedHashMap<String, Integer>() {{
        put("Launcher Service", 8099);       // –°–∞–º –ª–∞—É–Ω—á–µ—Ä
        put("API Gateway", 8080);           // API Gateway
        put("Authentication Service", 8097); // Auth
        put("User Management Service", 8081); // User
        put("Warehouse Service", 8082);      // Sklad
        put("Shopping Cart Service", 8083);  // Backet
        put("Office Management Service", 8085); // Office
        put("Collector Service", 8086);      // Collector
        put("Delivery Service", 8088);       // Delivery
        put("Transaction Saga Service", 8090); // TransactionSaga
    }};

    // –¢—Ä–µ–∫–µ—Ä –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
    private final Map<String, ServiceInfo> runningServices = new ConcurrentHashMap<>();

    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–æ–Ω–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    @Value("${app.reports.directory:./reports}")
    private String reportsDirectory;

    @Value("${app.reports.retention.days:7}")
    private int reportsRetentionDays;

    @Value("${app.service.timeout.seconds:30}")
    private int serviceTimeoutSeconds;

    // –ü–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–µ –∫–æ–ª–ª–µ–∫—Ü–∏–∏
    private final ConcurrentHashMap<String, TransactionInfo> activeTransactions = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<String, ErrorInfo> lastErrors = new ConcurrentHashMap<>();
    private final ConcurrentHashMap<Integer, PortInfo> portHistory = new ConcurrentHashMap<>();

    // –°—á–µ—Ç—á–∏–∫–∏ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
    private final AtomicInteger totalTransactions = new AtomicInteger(0);
    private final AtomicInteger failedTransactions = new AtomicInteger(0);
    private final AtomicInteger killedProcesses = new AtomicInteger(0);
    private final LocalDateTime startTime = LocalDateTime.now();

    // Executor –¥–ª—è —Ñ–æ–Ω–æ–≤—ã—Ö –∑–∞–¥–∞—á
    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(4);

    // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∏—Ä—É–µ–º—ã–π RestTemplate
    private final RestTemplate restTemplate;

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –∫–ª–∞—Å—Å—ã –¥–ª—è —Ç–∏–ø–∏–∑–∞—Ü–∏–∏
    private static class ServiceInfo {
        String name;
        int port;
        LocalDateTime startTime;
        String status;
        String pid;
        Process process;

        ServiceInfo(String name, int port) {
            this.name = name;
            this.port = port;
            this.status = "STOPPED";
        }
    }

    private static class TransactionInfo {
        String id;
        String type;
        LocalDateTime startTime;
        LocalDateTime endTime;
        String status;
        Map<String, Object> data;
        List<String> steps;

        TransactionInfo(String id, String type) {
            this.id = id;
            this.type = type;
            this.startTime = LocalDateTime.now();
            this.status = "STARTED";
            this.data = new ConcurrentHashMap<>();
            this.steps = Collections.synchronizedList(new ArrayList<>());
        }
    }

    private static class ErrorInfo {
        String code;
        String message;
        String source;
        LocalDateTime timestamp;
        String stackTrace;

        ErrorInfo(String code, String message, String source, Exception exception) {
            this.code = code;
            this.message = message;
            this.source = source;
            this.timestamp = LocalDateTime.now();
            this.stackTrace = exception != null ? getStackTraceAsString(exception) : null;
        }

        private static String getStackTraceAsString(Exception e) {
            return Arrays.stream(e.getStackTrace())
                    .limit(10)
                    .map(StackTraceElement::toString)
                    .collect(Collectors.joining("\n"));
        }
    }

    private static class PortInfo {
        int port;
        String serviceName;
        boolean occupied;
        String pid;
        LocalDateTime lastChecked;
        int checkCount;

        PortInfo(int port, String serviceName) {
            this.port = port;
            this.serviceName = serviceName;
            this.lastChecked = LocalDateTime.now();
        }
    }

    public DemoController(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplate = restTemplateBuilder
                .setConnectTimeout(Duration.ofSeconds(10))
                .setReadTimeout(Duration.ofSeconds(30))
                .build();

        logger.info("DemoController initialized with configured RestTemplate");
    }

    @PostConstruct
    public void init() {
        logger.info("üöÄ Initializing DemoController...");
        createDirectories();

        // –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è –µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω–æ
        if (!"none".equalsIgnoreCase(autoStartScenario)) {
            logger.info("üìã –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è: {}", autoStartScenario);
            scheduleAutoStart(autoStartScenario, 10000); // –ó–∞–ø—É—Å–∫ —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
        }

        // –ó–∞–ø—É—Å–∫–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞
        if (startupCheckEnabled) {
            startBackgroundTasks();
        }

        logger.info("‚úÖ DemoController initialized successfully. Start time: {}", startTime);
    }

    @PreDestroy
    public void cleanup() {
        logger.info("üßπ Shutting down DemoController...");

        // –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –≤—Å–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
        stopAllRunningServices();

        // –ó–∞–≤–µ—Ä—à–∞–µ–º —Ñ–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏
        scheduler.shutdown();
        try {
            if (!scheduler.awaitTermination(5, TimeUnit.SECONDS)) {
                scheduler.shutdownNow();
            }
        } catch (InterruptedException e) {
            scheduler.shutdownNow();
            Thread.currentThread().interrupt();
        }
        logger.info("‚úÖ DemoController shutdown complete");
    }

    // ============ –ò–ù–¢–ï–õ–õ–ï–ö–¢–£–ê–õ–¨–ù–´–ï –î–ï–ú–û-–≠–ù–î–ü–û–ò–ù–¢–´ ============

    @PostMapping("/cascade-errors")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–µ–º–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫")
    public ResponseEntity<DemoScenarioDTO> runCascadeErrorsDemo() {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫...");

        String operationId = "DEMO_CASCADE_" + System.currentTimeMillis();
        TransactionInfo transaction = new TransactionInfo(operationId, "CASCADE_ERRORS_DEMO");
        activeTransactions.put(operationId, transaction);

        try {
            // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–º–æ
            List<com.kefir.logistics.launcher_service.model.enums.ServiceType> requiredServices =
                    determineRequiredServicesForDemo("cascade-errors");

            transaction.steps.add("1. üîç –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤: " +
                    requiredServices.stream()
                            .map(com.kefir.logistics.launcher_service.model.enums.ServiceType::getDisplayName)
                            .collect(Collectors.joining(", ")));

            // 2. –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤
            List<ServiceStatusDTO> startupResults =
                    serviceOrchestrator.startServicesForDemo(requiredServices);

            transaction.steps.add("2. üöÄ –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤: " +
                    startupResults.size() + " —Å–µ—Ä–≤–∏—Å–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ");

            // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –∑–∞–ø—É—Å–∫–∞
            boolean startupSuccessful = startupResults.stream()
                    .allMatch(result -> result.getState() != null && result.getState().isRunning());

            if (!startupSuccessful) {
                transaction.steps.add("3. ‚ö†Ô∏è –ù–µ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å");
                transaction.status = "PARTIAL";
                transaction.data.put("startupResults", startupResults);

                // –í—Å–µ —Ä–∞–≤–Ω–æ –∑–∞–ø—É—Å–∫–∞–µ–º –¥–µ–º–æ, –Ω–æ —Å –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏–µ–º
                logger.warn("–ù–µ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º –¥–µ–º–æ");
            } else {
                transaction.steps.add("3. ‚úÖ –í—Å–µ —Å–µ—Ä–≤–∏—Å—ã —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω—ã");
            }

            // 4. –ó–∞–ø—É—Å–∫–∞–µ–º –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–π
            transaction.steps.add("4. üé¨ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è");
            DemoScenarioDTO scenario = demoScenarioService.runCascadeErrorsDemo();

            // 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            transaction.status = "COMPLETED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("demoScenario", scenario);
            transaction.data.put("requiredServices", requiredServices);
            transaction.data.put("startupResults", startupResults);

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –î–µ–º–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫ —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ");
            return ResponseEntity.ok(scenario);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –¥–µ–º–æ: {}", e.getMessage(), e);

            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("error", e.getMessage());
            failedTransactions.incrementAndGet();

            lastErrors.put("DEMO_CASCADE_ERROR",
                    new ErrorInfo("DEMO_START_FAILED", e.getMessage(), "runCascadeErrorsDemo", e));

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/cascade-errors/force")
    @Operation(summary = "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å –¥–µ–º–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫")
    public ResponseEntity<DemoScenarioDTO> forceRunCascadeErrorsDemo() {
        logger.info("üöÄ –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–´–ô –∑–∞–ø—É—Å–∫ –¥–µ–º–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫...");

        String operationId = "FORCE_DEMO_CASCADE_" + System.currentTimeMillis();
        TransactionInfo transaction = new TransactionInfo(operationId, "FORCE_CASCADE_ERRORS_DEMO");
        activeTransactions.put(operationId, transaction);

        try {
            // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è —ç—Ç–æ–≥–æ –¥–µ–º–æ
            List<com.kefir.logistics.launcher_service.model.enums.ServiceType> requiredServices =
                    Arrays.asList(
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.COLLECTOR_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.OFFICE_SERVICE
                    );

            transaction.steps.add("1. üîç –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤");

            // 2. –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã –±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è
            List<ServiceStatusDTO> startupResults =
                    serviceOrchestrator.forceStartServicesForDemo(requiredServices);

            transaction.steps.add("2. üöÄ –°–µ—Ä–≤–∏—Å—ã –∑–∞–ø—É—â–µ–Ω—ã (–≤–∫–ª—é—á–∞—è –Ω–µ–∑–¥–æ—Ä–æ–≤—ã–µ)");

            // 3. –î–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
            logger.info("‚è≥ –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é —Å–µ—Ä–≤–∏—Å–æ–≤ (10 —Å–µ–∫—É–Ω–¥)...");
            Thread.sleep(10000);

            // 4. –ó–∞–ø—É—Å–∫–∞–µ–º –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–π –í –õ–Æ–ë–û–ú –°–õ–£–ß–ê–ï
            transaction.steps.add("3. üé¨ –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–´–ô –∑–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è");
            DemoScenarioDTO scenario = demoScenarioService.runCascadeErrorsDemo();

            // 5. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            transaction.status = "COMPLETED_FORCED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("demoScenario", scenario);
            transaction.data.put("requiredServices", requiredServices);
            transaction.data.put("startupResults", startupResults);
            transaction.data.put("forceMode", true);

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –î–µ–º–æ –∫–∞—Å–∫–∞–¥–Ω—ã—Ö –æ—à–∏–±–æ–∫ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ");
            return ResponseEntity.ok(scenario);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ–º –∑–∞–ø—É—Å–∫–µ –¥–µ–º–æ: {}", e.getMessage(), e);

            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("error", e.getMessage());
            failedTransactions.incrementAndGet();

            lastErrors.put("FORCE_DEMO_CASCADE_ERROR",
                    new ErrorInfo("FORCE_DEMO_START_FAILED", e.getMessage(), "forceRunCascadeErrorsDemo", e));

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/normal-process")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–µ–º–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞")
    public ResponseEntity<DemoScenarioDTO> runNormalProcessDemo() {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–≥–æ –ø—Ä–æ—Ü–µ—Å—Å–∞...");
        return runDemoScenarioBase("normal-process", "NORMAL_PROCESS_DEMO");
    }

    @PostMapping("/single-missing")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–µ–º–æ –æ–¥–Ω–æ–≥–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–æ–≤–∞—Ä–∞")
    public ResponseEntity<DemoScenarioDTO> runSingleMissingItemDemo() {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ –æ–¥–Ω–æ–≥–æ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–æ–≤–∞—Ä–∞...");
        return runDemoScenarioBase("single-missing", "SINGLE_MISSING_DEMO");
    }

    @PostMapping("/saga-transaction-error")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –¥–µ–º–æ –æ—à–∏–±–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–æ–π —Å–∞–≥–∏")
    public ResponseEntity<DemoScenarioDTO> runSagaTransactionErrorDemo() {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ –æ—à–∏–±–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–æ–π —Å–∞–≥–∏...");

        String operationId = "DEMO_SAGA_" + System.currentTimeMillis();
        TransactionInfo transaction = new TransactionInfo(operationId, "SAGA_TRANSACTION_ERROR");
        activeTransactions.put(operationId, transaction);

        try {
            // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã –¥–ª—è Saga –¥–µ–º–æ
            List<com.kefir.logistics.launcher_service.model.enums.ServiceType> requiredServices =
                    Arrays.asList(
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE,
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.COLLECTOR_SERVICE
                    );

            transaction.steps.add("1. üöÄ –ó–∞–ø—É—Å–∫ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");

            // 2. –ó–∞–ø—É—Å–∫–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã
            List<ServiceStatusDTO> startupResults =
                    serviceOrchestrator.startServicesForDemo(requiredServices);

            // 3. –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–∞–ø—É—Å—Ç–∏–ª—Å—è –ª–∏ Saga
            boolean sagaRunning = false;
            for (ServiceStatusDTO status : startupResults) {
                if (status.getServiceType() == com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE) {
                    sagaRunning = status.getState() != null && status.getState().isRunning();
                    break;
                }
            }

            if (!sagaRunning) {
                transaction.steps.add("‚ö†Ô∏è Saga —Å–µ—Ä–≤–∏—Å –Ω–µ –∑–∞–ø—É—â–µ–Ω, –ø—ã—Ç–∞–µ–º—Å—è –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ...");
                ServiceStatusDTO sagaStatus = serviceOrchestrator.startService(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE
                );
                startupResults.add(sagaStatus);
            }

            // 4. –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–ø—É—Å–∫ Saga —Å–µ—Ä–≤–∏—Å–∞
            transaction.steps.add("2. ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –∑–∞–ø—É—Å–∫–∞ Saga —Å–µ—Ä–≤–∏—Å–∞ (5 —Å–µ–∫—É–Ω–¥)...");
            Thread.sleep(5000);

            // 5. –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å Saga
            boolean sagaAvailable = isPortOccupied(8090);
            transaction.steps.add("3. üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Saga –Ω–∞ –ø–æ—Ä—Ç—É 8090: " + (sagaAvailable ? "‚úÖ –î–æ—Å—Ç—É–ø–µ–Ω" : "‚ùå –ù–µ–¥–æ—Å—Ç—É–ø–µ–Ω"));

            if (!sagaAvailable) {
                throw new RuntimeException("Transaction Saga Service –Ω–µ –¥–æ—Å—Ç—É–ø–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8090");
            }

            // 6. –¢–µ—Å—Ç–∏—Ä—É–µ–º –ø–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ Saga
            transaction.steps.add("4. üîó –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ Saga API");

            // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã Saga
            String[] sagaEndpoints = {
                    "http://localhost:8090/actuator/health",
                    "http://localhost:8090/health",
                    "http://localhost:8090/"
            };

            boolean sagaResponds = false;
            for (String endpoint : sagaEndpoints) {
                try {
                    ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);
                    if (response.getStatusCode().is2xxSuccessful()) {
                        sagaResponds = true;
                        transaction.steps.add("   ‚úÖ Saga –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞: " + endpoint);
                        break;
                    }
                } catch (Exception e) {
                    // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–±–æ–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
                }
            }

            if (!sagaResponds) {
                transaction.steps.add("   ‚ö†Ô∏è Saga –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã");
            }

            // 7. –ò–º–∏—Ç–∏—Ä—É–µ–º —Å—Ü–µ–Ω–∞—Ä–∏–π –∏–∑ –º–∏—Å—Å–∏–∏
            transaction.steps.add("5. üé≠ –ò–º–∏—Ç–∞—Ü–∏—è —Ä–µ–∞–ª—å–Ω–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è:");
            transaction.steps.add("   - üì¶ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ —á–µ—Ä–µ–∑ –∫–æ—Ä–∑–∏–Ω—É");
            transaction.steps.add("   - üè≠ –°–±–æ—Ä—â–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä–∫—É –Ω–∞ —Å–∫–ª–∞–¥–µ");
            transaction.steps.add("   - ‚ö†Ô∏è –û–®–ò–ë–ö–ê: –û–¥–∏–Ω —Ç–æ–≤–∞—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç");
            transaction.steps.add("   - üìû –°–±–æ—Ä—â–∏–∫ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –≤ –æ—Ñ–∏—Å");
            transaction.steps.add("   - üë®‚Äçüíº –û—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–º");
            transaction.steps.add("   - üí∞ –¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è Saga –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è");
            transaction.steps.add("   - üîÑ –°–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è");
            transaction.steps.add("   - üöö –ü—Ä–æ–±–ª–µ–º–∞: —Å–±–æ—Ä –ø–æ —Ä–∞–∑–Ω—ã–º —Å–∫–ª–∞–¥–∞–º (1 —á–∞—Å –≤–º–µ—Å—Ç–æ 15 –º–∏–Ω—É—Ç)");

            // 8. –°–æ–∑–¥–∞–µ–º –æ—Ç–≤–µ—Ç–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π
            DemoScenarioDTO scenario = new DemoScenarioDTO();
            scenario.setTitle("–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–∞—è Saga: –†–µ–∞–ª—å–Ω–∞—è –æ—à–∏–±–∫–∞ –ª–æ–≥–∏—Å—Ç–∏–∫–∏");
            scenario.setDescription("–°—Ü–µ–Ω–∞—Ä–∏–π –∏–∑ –º–∏—Å—Å–∏–∏: –∫–ª–∏–µ–Ω—Ç –∑–∞–∫–∞–∑—ã–≤–∞–µ—Ç —Ç–æ–≤–∞—Ä—ã, —Å–±–æ—Ä—â–∏–∫ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ —Ç–æ–≤–∞—Ä–∞, " +
                    "–æ—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è, —Å–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è, " +
                    "–≤–æ–∑–Ω–∏–∫–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º–∞ —Å–±–æ—Ä–∞ —Ç–æ–≤–∞—Ä–æ–≤ –ø–æ —Ä–∞–∑–Ω—ã–º —Å–∫–ª–∞–¥–∞–º");
            scenario.setOperationId(operationId);
            scenario.setStatus("COMPLETED");
            scenario.setStartTime(LocalDateTime.now());
            scenario.setEndTime(LocalDateTime.now());
            scenario.setRunning(false);
            scenario.setExecutionTimeSeconds(15);
            scenario.setSteps(Arrays.asList(
                    "‚úÖ –ó–∞–ø—É—Å–∫ Transaction Saga Service",
                    "‚úÖ –ó–∞–ø—É—Å–∫ Warehouse Service",
                    "‚úÖ –ó–∞–ø—É—Å–∫ Cart Service",
                    "‚úÖ –ó–∞–ø—É—Å–∫ Collector Service",
                    "üì¶ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ –≤ –∫–æ—Ä–∑–∏–Ω–µ",
                    "üè≠ –°–±–æ—Ä—â–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ –Ω–∞ —Å–±–æ—Ä–∫—É",
                    "‚ö†Ô∏è –û–±–Ω–∞—Ä—É–∂–µ–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä –Ω–∞ —Å–∫–ª–∞–¥–µ",
                    "üìû –°–±–æ—Ä—â–∏–∫ –æ—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –≤ –æ—Ñ–∏—Å",
                    "üë®‚Äçüíº –û—Ñ–∏—Å–º–µ–Ω —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º –ø–æ —Ç–µ–ª–µ—Ñ–æ–Ω—É",
                    "‚úÖ –ö–ª–∏–µ–Ω—Ç –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–∞–µ—Ç —Å–±–æ—Ä–∫—É –±–µ–∑ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–µ–≥–æ —Ç–æ–≤–∞—Ä–∞",
                    "üí∞ Transaction Saga –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –ø–µ—Ä–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é —á–∞—Å—Ç–∏—á–Ω–æ",
                    "üíµ –î–µ–Ω—å–≥–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –∫–ª–∏–µ–Ω—Ç—É –∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä",
                    "üîÑ –°–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–ª—å–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤",
                    "üè≠ –°–±–æ—Ä—â–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä–∫—É –∑–∞–Ω–æ–≤–æ",
                    "üöö –ü–†–û–ë–õ–ï–ú–ê: –¢–æ–≤–∞—Ä—ã –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —Å–∫–ª–∞–¥–∞—Ö",
                    "‚è∞ –í—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏ —É–≤–µ–ª–∏—á–∏–≤–∞–µ—Ç—Å—è –¥–æ 1 —á–∞—Å–∞",
                    "üìä –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏ –ø—Ä–æ—Ü–µ—Å—Å–∞"
            ));

            // 9. –°–æ–∑–¥–∞–µ–º —Ç–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
            Map<String, Object> testData = new HashMap<>();
            testData.put("orderId", "ORDER_" + System.currentTimeMillis());
            testData.put("customerId", "CUST_001");
            testData.put("missingItem", "–¢–æ–≤–∞—Ä #12345");
            testData.put("remainingItems", Arrays.asList("–¢–æ–≤–∞—Ä #67890", "–¢–æ–≤–∞—Ä #54321"));
            testData.put("originalDeliveryTime", "15 –º–∏–Ω—É—Ç");
            testData.put("actualDeliveryTime", "1 —á–∞—Å");
            testData.put("transactionStatus", "PARTIALLY_COMPLETED");
            testData.put("newTransactionCreated", true);

            scenario.setTestData(testData);
            scenario.setMetrics(Map.of(
                    "sagaAvailable", sagaAvailable,
                    "sagaResponds", sagaResponds,
                    "requiredServices", requiredServices.size(),
                    "startupTime", "5 —Å–µ–∫—É–Ω–¥",
                    "scenarioDuration", "15 —Å–µ–∫—É–Ω–¥"
            ));

            // 10. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            transaction.status = "COMPLETED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("demoScenario", scenario);
            transaction.data.put("requiredServices", requiredServices);
            transaction.data.put("startupResults", startupResults);
            transaction.data.put("sagaAvailable", sagaAvailable);
            transaction.data.put("sagaResponds", sagaResponds);

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –î–µ–º–æ Transaction Saga —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ");
            logger.info("   –°—Ü–µ–Ω–∞—Ä–∏–π: {}", scenario.getTitle());
            logger.info("   –ü—Ä–æ–±–ª–µ–º–∞: {}", "–°–±–æ—Ä –ø–æ —Ä–∞–∑–Ω—ã–º —Å–∫–ª–∞–¥–∞–º –ø—Ä–∏ –æ—à–∏–±–∫–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏");
            logger.info("   –†–µ—à–µ–Ω–∏–µ: {}", "–ü–æ–ª–Ω—ã–π –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ —á–µ—Ä–µ–∑ Saga");

            return ResponseEntity.ok(scenario);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –¥–µ–º–æ Saga: {}", e.getMessage(), e);

            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("error", e.getMessage());
            failedTransactions.incrementAndGet();

            lastErrors.put("DEMO_SAGA_ERROR",
                    new ErrorInfo("SAGA_DEMO_FAILED", e.getMessage(), "runSagaTransactionErrorDemo", e));

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @PostMapping("/mission-scenario")
    @Operation(summary = "–ó–∞–ø—É—Å—Ç–∏—Ç—å –ø–æ–ª–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π –∏–∑ –º–∏—Å—Å–∏–∏")
    public ResponseEntity<Map<String, Object>> runMissionScenario() {
        logger.info("üéØ –ó–ê–ü–£–°–ö –ü–û–õ–ù–û–ì–û –°–¶–ï–ù–ê–†–ò–Ø –ò–ó –ú–ò–°–°–ò–ò –ü–†–ò–õ–û–ñ–ï–ù–ò–Ø");

        Map<String, Object> result = new LinkedHashMap<>();
        List<String> steps = Collections.synchronizedList(new ArrayList<>());

        String operationId = "MISSION_" + System.currentTimeMillis();
        TransactionInfo transaction = new TransactionInfo(operationId, "FULL_MISSION_SCENARIO");
        activeTransactions.put(operationId, transaction);

        try {
            result.put("mission", "–†–µ—à–µ–Ω–∏–µ –ø—Ä–æ–±–ª–µ–º—ã –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–æ–π –æ—à–∏–±–∫–∏");
            result.put("operationId", operationId);
            result.put("timestamp", LocalDateTime.now());

            // –®–∞–≥ 1: –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
            steps.add("1. üöÄ –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤ KEFIR");
            transaction.steps.add("1. üöÄ –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤");

            List<ServiceStatusDTO> services = serviceOrchestrator.startAllServices();
            long runningServices = services.stream()
                    .filter(s -> s.getState() != null && s.getState().isRunning())
                    .count();

            steps.add("   ‚úÖ –ó–∞–ø—É—â–µ–Ω–æ " + runningServices + "/" + services.size() + " —Å–µ—Ä–≤–∏—Å–æ–≤");
            transaction.steps.add("   ‚úÖ –ó–∞–ø—É—â–µ–Ω–æ " + runningServices + "/" + services.size() + " —Å–µ—Ä–≤–∏—Å–æ–≤");

            // –®–∞–≥ 2: –ü—Ä–æ–≤–µ—Ä–∫–∞ Saga
            steps.add("2. üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Transaction Saga Service");
            transaction.steps.add("2. üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Transaction Saga Service");

            boolean sagaReady = isPortOccupied(8090);
            if (sagaReady) {
                steps.add("   ‚úÖ Transaction Saga –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8090");
                transaction.steps.add("   ‚úÖ Transaction Saga –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8090");
            } else {
                steps.add("   ‚ö†Ô∏è Saga –Ω–µ –∑–∞–ø—É—â–µ–Ω! –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Ä—É—á–Ω—É—é...");
                transaction.steps.add("   ‚ö†Ô∏è Saga –Ω–µ –∑–∞–ø—É—â–µ–Ω! –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Ä—É—á–Ω—É—é...");

                ServiceStatusDTO sagaStatus = serviceOrchestrator.startService(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE
                );
                Thread.sleep(5000);
                sagaReady = isPortOccupied(8090);

                if (sagaReady) {
                    steps.add("   ‚úÖ Saga —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω");
                    transaction.steps.add("   ‚úÖ Saga —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω");
                } else {
                    steps.add("   ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å Saga");
                    transaction.steps.add("   ‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å Saga");
                }
            }

            // –®–∞–≥ 3: –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –ø–æ–ª–Ω—É—é –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é
            steps.add("3. ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏ (10 —Å–µ–∫—É–Ω–¥)...");
            transaction.steps.add("3. ‚è≥ –û–∂–∏–¥–∞–Ω–∏–µ –ø–æ–ª–Ω–æ–π –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏");
            Thread.sleep(10000);

            // –®–∞–≥ 4: –ó–∞–ø—É—Å–∫ –ø–æ–ª–Ω–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è –≤ —Ñ–æ–Ω–µ
            steps.add("4. üé¨ –ó–∞–ø—É—Å–∫ —Å—Ü–µ–Ω–∞—Ä–∏—è –º–∏—Å—Å–∏–∏ –≤ —Ñ–æ–Ω–æ–≤–æ–º —Ä–µ–∂–∏–º–µ");
            transaction.steps.add("4. üé¨ –ó–∞–ø—É—Å–∫ —Å—Ü–µ–Ω–∞—Ä–∏—è –º–∏—Å—Å–∏–∏");

            result.put("steps", new ArrayList<>(steps));
            result.put("status", "IN_PROGRESS");
            result.put("message", "–°—Ü–µ–Ω–∞—Ä–∏–π –º–∏—Å—Å–∏–∏ –∑–∞–ø—É—â–µ–Ω. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤.");
            result.put("backgroundJobId", operationId + "_JOB");

            // –ó–∞–ø—É—Å—Ç–∏—Ç—å –≤ —Ñ–æ–Ω–µ –ø–æ–ª–Ω—ã–π —Å—Ü–µ–Ω–∞—Ä–∏–π
            scheduler.submit(() -> {
                try {
                    executeFullMissionScenario(operationId, transaction);
                } catch (Exception e) {
                    logger.error("–û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è –º–∏—Å—Å–∏–∏: {}", e.getMessage());
                    transaction.steps.add("‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è: " + e.getMessage());
                    transaction.status = "FAILED";
                    transaction.endTime = LocalDateTime.now();
                }
            });

            transaction.data.put("initialResult", result);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –∑–∞–ø—É—Å–∫–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è –º–∏—Å—Å–∏–∏: {}", e.getMessage(), e);

            steps.add("‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: " + e.getMessage());
            result.put("steps", steps);
            result.put("status", "FAILED");
            result.put("error", e.getMessage());
            result.put("timestamp", LocalDateTime.now());

            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("error", e.getMessage());
            failedTransactions.incrementAndGet();

            lastErrors.put("MISSION_SCENARIO_FAILED",
                    new ErrorInfo("MISSION_FAILED", e.getMessage(), "runMissionScenario", e));
        }

        return ResponseEntity.ok(result);
    }

    @GetMapping("/saga-status")
    @Operation(summary = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—Ç–∞—Ç—É—Å Transaction Saga")
    public ResponseEntity<Map<String, Object>> checkSagaStatus() {
        logger.debug("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞ Transaction Saga Service");

        Map<String, Object> status = new LinkedHashMap<>();
        List<String> checks = new ArrayList<>();

        // –ë–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä—Ç–∞
        boolean portOpen = isPortOccupied(8090);
        status.put("portOpen", portOpen);
        status.put("port", 8090);
        status.put("serviceName", "Transaction Saga Service");
        status.put("serviceId", "TransactionSaga");

        checks.add("–ü–æ—Ä—Ç 8090: " + (portOpen ? "‚úÖ –û—Ç–∫—Ä—ã—Ç" : "‚ùå –ó–∞–∫—Ä—ã—Ç"));

        if (portOpen) {
            // –ü—Ä–æ–±—É–µ–º —Ä–∞–∑–Ω—ã–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã Saga
            String[] endpoints = {
                    "http://localhost:8090/actuator/health",
                    "http://localhost:8090/health",
                    "http://localhost:8090/api/health",
                    "http://localhost:8090/api/transactions/status",
                    "http://localhost:8090/"
            };

            Map<String, Object> endpointStatus = new LinkedHashMap<>();

            for (String endpoint : endpoints) {
                try {
                    long startTime = System.currentTimeMillis();
                    ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);
                    long responseTime = System.currentTimeMillis() - startTime;

                    String endpointName = endpoint.replace("http://localhost:8090", "");
                    if (endpointName.isEmpty()) endpointName = "/";

                    Map<String, Object> endpointInfo = new LinkedHashMap<>();
                    endpointInfo.put("statusCode", response.getStatusCode().value());
                    endpointInfo.put("responseTimeMs", responseTime);
                    endpointInfo.put("available", true);

                    endpointStatus.put(endpointName, endpointInfo);

                    checks.add(endpointName + ": ‚úÖ " + response.getStatusCode().value() + " (" + responseTime + "ms)");

                } catch (Exception e) {
                    String endpointName = endpoint.replace("http://localhost:8090", "");
                    if (endpointName.isEmpty()) endpointName = "/";

                    Map<String, Object> endpointInfo = new LinkedHashMap<>();
                    endpointInfo.put("available", false);
                    endpointInfo.put("error", e.getMessage());

                    endpointStatus.put(endpointName, endpointInfo);

                    checks.add(endpointName + ": ‚ùå " + e.getMessage());
                }
            }

            status.put("endpoints", endpointStatus);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —á–µ—Ä–µ–∑ ServiceOrchestrator
            try {
                boolean sagaRunning = serviceOrchestrator.isServiceRunning(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE
                );
                status.put("orchestratorStatus", sagaRunning ? "RUNNING" : "STOPPED");
                checks.add("ServiceOrchestrator: " + (sagaRunning ? "‚úÖ –ó–∞–ø—É—â–µ–Ω" : "‚ùå –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω"));
            } catch (Exception e) {
                status.put("orchestratorCheckError", e.getMessage());
                checks.add("ServiceOrchestrator: ‚ö†Ô∏è " + e.getMessage());
            }
        }

        status.put("checks", checks);
        status.put("timestamp", LocalDateTime.now());

        // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        List<String> recommendations = new ArrayList<>();
        if (!portOpen) {
            recommendations.add("Transaction Saga Service –Ω–µ –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8090");
            recommendations.add("–ó–∞–ø—É—Å—Ç–∏—Ç–µ —Å–µ—Ä–≤–∏—Å: cd C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\TransactionSaga && mvn spring-boot:run");
            recommendations.add("–ò–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ API –¥–ª—è –∑–∞–ø—É—Å–∫–∞: POST /api/v1/demo/services/start?service=SAGA_SERVICE");
        } else if (status.containsKey("endpoints")) {
            @SuppressWarnings("unchecked")
            Map<String, Object> endpoints = (Map<String, Object>) status.get("endpoints");

            long availableEndpoints = 0;
            for (Object endpointObj : endpoints.values()) {
                if (endpointObj instanceof Map) {
                    @SuppressWarnings("unchecked")
                    Map<String, Object> endpointInfo = (Map<String, Object>) endpointObj;
                    Object availableObj = endpointInfo.get("available");
                    if (availableObj instanceof Boolean && (Boolean) availableObj) {
                        availableEndpoints++;
                    }
                }
            }

            if (availableEndpoints == 0) {
                recommendations.add("Saga –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ API –∑–∞–ø—Ä–æ—Å—ã");
                recommendations.add("–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –ª–æ–≥–∏ —Å–µ—Ä–≤–∏—Å–∞ TransactionSaga");
            } else {
                recommendations.add("Saga —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ /api/v1/demo/saga-transaction-error –¥–ª—è –¥–µ–º–æ");
            }
        }

        status.put("recommendations", recommendations);

        logger.info("üìä –°—Ç–∞—Ç—É—Å Saga: –ø–æ—Ä—Ç {}, —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤ –¥–æ—Å—Ç—É–ø–Ω–æ: {}",
                portOpen ? "–æ—Ç–∫—Ä—ã—Ç" : "–∑–∞–∫—Ä—ã—Ç",
                status.containsKey("endpoints") ?
                        ((Map<?, ?>) status.get("endpoints")).values().stream()
                                .filter(e -> {
                                    if (e instanceof Map) {
                                        Object available = ((Map<?, ?>) e).get("available");
                                        return available instanceof Boolean && (Boolean) available;
                                    }
                                    return false;
                                })
                                .count() : 0);

        return ResponseEntity.ok(status);
    }

    private ResponseEntity<DemoScenarioDTO> runDemoScenarioBase(String scenarioType, String operationType) {
        String operationId = "DEMO_" + operationType + "_" + System.currentTimeMillis();
        TransactionInfo transaction = new TransactionInfo(operationId, operationType);
        activeTransactions.put(operationId, transaction);

        try {
            // 1. –û–ø—Ä–µ–¥–µ–ª—è–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
            List<com.kefir.logistics.launcher_service.model.enums.ServiceType> requiredServices =
                    determineRequiredServicesForDemo(scenarioType);

            transaction.steps.add("1. üîç –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤");

            // 2. –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤
            List<ServiceStatusDTO> startupResults =
                    serviceOrchestrator.startServicesForDemo(requiredServices);

            transaction.steps.add("2. üöÄ –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤");

            // 3. –ó–∞–ø—É—Å–∫–∞–µ–º –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–π
            transaction.steps.add("3. üé¨ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è");
            DemoScenarioDTO scenario = getScenarioResponse(scenarioType);

            if (scenario == null) {
                throw new IllegalArgumentException("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º—ã–π —Ç–∏–ø —Å—Ü–µ–Ω–∞—Ä–∏—è: " + scenarioType);
            }

            // 4. –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            transaction.status = "COMPLETED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("demoScenario", scenario);
            transaction.data.put("requiredServices", requiredServices);
            transaction.data.put("startupResults", startupResults);

            totalTransactions.incrementAndGet();

            logger.info("‚úÖ –î–µ–º–æ {} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ", scenarioType);
            return ResponseEntity.ok(scenario);

        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—É—Å–∫–µ –¥–µ–º–æ: {}", e.getMessage(), e);

            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("error", e.getMessage());
            failedTransactions.incrementAndGet();

            lastErrors.put("DEMO_" + operationType,
                    new ErrorInfo("DEMO_START_FAILED", e.getMessage(), "runDemoScenarioBase", e));

            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).build();
        }
    }

    @GetMapping("/scenarios")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å –≤—Å–µ –¥–æ—Å—Ç—É–ø–Ω—ã–µ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–∏")
    public ResponseEntity<List<DemoScenarioDTO>> getAllScenarios() {
        logger.debug("üìã –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –≤—Å–µ—Ö —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤");
        return ResponseEntity.ok(demoScenarioService.getAllScenarios());
    }

    @GetMapping("/active/{scenarioType}")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è")
    public ResponseEntity<DemoScenarioDTO> getActiveScenario(@PathVariable String scenarioType) {
        DemoScenarioDTO scenario = demoScenarioService.getActiveScenario(scenarioType);
        if (scenario != null) {
            return ResponseEntity.ok(scenario);
        }
        return ResponseEntity.notFound().build();
    }

    // ============ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–û–ï –£–ü–†–ê–í–õ–ï–ù–ò–ï –ü–û–†–¢–ê–ú–ò ============

    @PostMapping("/release-ports")
    @Operation(summary = "–û—Å–≤–æ–±–æ–¥–∏—Ç—å —Ç–æ–ª—å–∫–æ –≤–Ω–µ—à–Ω–∏–µ –∑–∞–Ω—è—Ç—ã–µ –ø–æ—Ä—Ç—ã")
    public ResponseEntity<Map<String, Object>> releaseExternalPorts() {
        logger.info("üîç –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ —Ç–æ–ª—å–∫–æ –í–ù–ï–®–ù–ò–• –∑–∞–Ω—è—Ç—ã—Ö –ø–æ—Ä—Ç–æ–≤");

        String operationId = "RELEASE_EXTERNAL_PORTS_" + System.currentTimeMillis();
        TransactionInfo transaction = new TransactionInfo(operationId, "EXTERNAL_PORT_RELEASE");
        activeTransactions.put(operationId, transaction);

        Map<String, Object> response = new LinkedHashMap<>();
        List<String> releasedPorts = Collections.synchronizedList(new ArrayList<>());
        List<String> managedPorts = Collections.synchronizedList(new ArrayList<>());

        try {
            transaction.steps.add("1. üîç –ü–æ–∏—Å–∫ –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –Ω–∞ –ø–æ—Ä—Ç–∞—Ö KEFIR");

            int totalChecked = 0;
            int externalPorts = 0;

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥—ã–π –ø–æ—Ä—Ç
            for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
                String serviceName = entry.getKey();
                int port = entry.getValue();

                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –ª–∞—É–Ω—á–µ—Ä-—Å–µ—Ä–≤–∏—Å
                if ("Launcher Service".equals(serviceName)) {
                    continue;
                }

                totalChecked++;

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ—Ä—Ç –Ω–∞—à–∏–º –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
                boolean isManaged = isPortManagedByOrchestrator(port, serviceName);

                if (isManaged) {
                    managedPorts.add(port + " (" + serviceName + ")");
                    logger.debug("‚úÖ –ü–æ—Ä—Ç {} ({}) —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º", port, serviceName);
                } else {
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–Ω—è—Ç –ª–∏ –ø–æ—Ä—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º
                    boolean occupied = isPortOccupied(port);

                    if (occupied) {
                        externalPorts++;
                        logger.info("‚ö†Ô∏è –ü–æ—Ä—Ç {} ({}) –∑–∞–Ω—è—Ç –≤–Ω–µ—à–Ω–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º, –æ—Å–≤–æ–±–æ–∂–¥–∞–µ–º...", port, serviceName);

                        boolean released = releasePortIfNeeded(port, serviceName);
                        if (released) {
                            releasedPorts.add(port + " (" + serviceName + ")");
                            logger.info("‚úÖ –ü–æ—Ä—Ç {} ({}) –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω", port, serviceName);
                            killedProcesses.incrementAndGet();
                        } else {
                            logger.warn("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {} ({})", port, serviceName);
                        }
                    } else {
                        logger.debug("‚úÖ –ü–æ—Ä—Ç {} ({}) —Å–≤–æ–±–æ–¥–µ–Ω", port, serviceName);
                    }
                }
            }

            // –§–æ—Ä–º–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç
            response.put("operationId", operationId);
            response.put("action", "external-ports-release");
            response.put("status", releasedPorts.isEmpty() ? "NO_EXTERNAL_PORTS" : "EXTERNAL_PORTS_RELEASED");
            response.put("releasedPorts", new ArrayList<>(releasedPorts));
            response.put("managedPorts", new ArrayList<>(managedPorts));
            response.put("totalChecked", totalChecked);
            response.put("externalPortsFound", externalPorts);
            response.put("releasedCount", releasedPorts.size());
            response.put("timestamp", System.currentTimeMillis());
            response.put("message", releasedPorts.isEmpty() ?
                    "–í—Å–µ –ø–æ—Ä—Ç—ã KEFIR —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º –∏–ª–∏ —Å–≤–æ–±–æ–¥–Ω—ã" :
                    "–û—Å–≤–æ–±–æ–∂–¥–µ–Ω–æ " + releasedPorts.size() + " –≤–Ω–µ—à–Ω–∏—Ö –ø–æ—Ä—Ç–æ–≤");

            transaction.status = "COMPLETED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("result", response);
            transaction.steps.add("‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–∞ –ø—Ä–æ–≤–µ—Ä–∫–∞ –≤–Ω–µ—à–Ω–∏—Ö –ø–æ—Ä—Ç–æ–≤");

            logger.info("üìä –û—Å–≤–æ–±–æ–∂–¥–µ–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤: {}/{} –≤–Ω–µ—à–Ω–∏—Ö –ø–æ—Ä—Ç–æ–≤ –æ—Å–≤–æ–±–æ–∂–¥–µ–Ω–æ",
                    releasedPorts.size(), externalPorts);

        } catch (Exception e) {
            logger.error("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –ø–æ—Ä—Ç–æ–≤: {}", e.getMessage(), e);
            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            response.put("error", e.getMessage());
            lastErrors.put("PORT_RELEASE_CRITICAL",
                    new ErrorInfo("CRITICAL_PORT_ERROR", e.getMessage(), "releaseExternalPorts", e));
        }

        return ResponseEntity.ok(response);
    }

    @GetMapping("/check-ports")
    @Operation(summary = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ –ø–æ—Ä—Ç–æ–≤ –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤")
    public ResponseEntity<Map<String, Object>> checkPortsStatus() {
        logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –ø–æ—Ä—Ç–æ–≤ KEFIR");

        Map<String, Object> response = new LinkedHashMap<>();
        Map<String, Map<String, Object>> portStatus = new LinkedHashMap<>();

        int occupiedPorts = 0;
        int freePorts = 0;
        int managedPorts = 0;

        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            String serviceName = entry.getKey();
            int port = entry.getValue();

            Map<String, Object> statusInfo = new LinkedHashMap<>();
            statusInfo.put("port", port);
            statusInfo.put("serviceName", serviceName);

            // –õ–∞—É–Ω—á–µ—Ä –≤—Å–µ–≥–¥–∞ —Å—á–∏—Ç–∞–µ—Ç—Å—è –∑–∞–ø—É—â–µ–Ω–Ω—ã–º
            if ("Launcher Service".equals(serviceName)) {
                statusInfo.put("status", "LAUNCHER");
                statusInfo.put("managed", true);
                managedPorts++;
                portStatus.put(serviceName, statusInfo);
                continue;
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —É–ø—Ä–∞–≤–ª—è–µ—Ç—Å—è –ª–∏ –ø–æ—Ä—Ç –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º
            boolean isManaged = isPortManagedByOrchestrator(port, serviceName);
            boolean occupied = isPortOccupied(port);

            statusInfo.put("occupied", occupied);
            statusInfo.put("managed", isManaged);

            if (isManaged) {
                statusInfo.put("status", "MANAGED");
                managedPorts++;
            } else if (occupied) {
                statusInfo.put("status", "EXTERNAL");
                occupiedPorts++;
            } else {
                statusInfo.put("status", "FREE");
                freePorts++;
            }

            portStatus.put(serviceName, statusInfo);
        }

        response.put("portStatus", portStatus);
        response.put("totalPorts", KEFIR_SERVICES.size());
        response.put("occupiedPorts", occupiedPorts);
        response.put("freePorts", freePorts);
        response.put("managedPorts", managedPorts);
        response.put("timestamp", System.currentTimeMillis());
        response.put("recommendation", getPortManagementRecommendation(occupiedPorts, managedPorts));

        logger.info("üìä –°—Ç–∞—Ç—É—Å –ø–æ—Ä—Ç–æ–≤: {}/{} —É–ø—Ä–∞–≤–ª—è–µ–º—ã—Ö, {}/{} –≤–Ω–µ—à–Ω–∏—Ö, {}/{} —Å–≤–æ–±–æ–¥–Ω–æ",
                managedPorts, KEFIR_SERVICES.size() - 1, occupiedPorts, freePorts);

        return ResponseEntity.ok(response);
    }

    // ============ SERVICE MANAGEMENT ENDPOINTS ============

    @PostMapping("/services/stop-all")
    @Operation(summary = "–û—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—Å–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã")
    public ResponseEntity<Map<String, Object>> stopAllServices() {
        logger.info("üõë –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –≤—Å–µ—Ö –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤...");

        Map<String, Object> result = stopAllRunningServices();
        return ResponseEntity.ok(result);
    }

    @GetMapping("/services/running")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–ø—É—â–µ–Ω–Ω—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤")
    public ResponseEntity<Map<String, Object>> getRunningServices() {
        Map<String, Object> response = new LinkedHashMap<>();

        List<Map<String, Object>> services = new ArrayList<>();
        runningServices.forEach((name, info) -> {
            if ("RUNNING".equals(info.status)) {
                Map<String, Object> serviceInfo = new LinkedHashMap<>();
                serviceInfo.put("name", info.name);
                serviceInfo.put("port", info.port);
                serviceInfo.put("startTime", info.startTime);
                serviceInfo.put("pid", info.pid);
                services.add(serviceInfo);
            }
        });

        response.put("runningServices", services);
        response.put("count", services.size());
        response.put("timestamp", LocalDateTime.now());

        return ResponseEntity.ok(response);
    }

    // ============ –£–¢–ò–õ–ò–¢–ù–´–ï –≠–ù–î–ü–û–ò–ù–¢–´ ============

    @GetMapping("/health")
    @Operation(summary = "–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–¥–æ—Ä–æ–≤—å–µ DemoController")
    public ResponseEntity<Map<String, Object>> health() {
        Map<String, Object> health = new LinkedHashMap<>();

        Runtime runtime = Runtime.getRuntime();
        long usedMemoryMB = (runtime.totalMemory() - runtime.freeMemory()) / (1024 * 1024);
        long maxMemoryMB = runtime.maxMemory() / (1024 * 1024);
        int memoryUsagePercent = maxMemoryMB > 0 ? (int)(usedMemoryMB * 100 / maxMemoryMB) : 0;

        health.put("status", "UP");
        health.put("startTime", startTime);
        health.put("uptime", getUptime());
        health.put("runningServices", runningServices.size());
        health.put("killedProcesses", killedProcesses.get());
        health.put("totalTransactions", totalTransactions.get());
        health.put("failedTransactions", failedTransactions.get());
        health.put("successRate", totalTransactions.get() > 0 ?
                String.format("%.1f%%", (1 - (double)failedTransactions.get() / totalTransactions.get()) * 100) : "100%");
        health.put("memoryUsageMB", usedMemoryMB);
        health.put("maxMemoryMB", maxMemoryMB);
        health.put("memoryUsagePercent", memoryUsagePercent + "%");
        health.put("timestamp", LocalDateTime.now());

        return ResponseEntity.ok(health);
    }

    @GetMapping("/status")
    @Operation(summary = "–ü–æ–ª—É—á–∏—Ç—å –ø–æ–ª–Ω—ã–π —Å—Ç–∞—Ç—É—Å —Å–∏—Å—Ç–µ–º—ã")
    public ResponseEntity<Map<String, Object>> getSystemStatus() {
        Map<String, Object> status = new LinkedHashMap<>();

        // 1. –°—Ç–∞—Ç—É—Å –¥–µ–º–æ-–∫–æ–Ω—Ç—Ä–æ–ª–ª–µ—Ä–∞
        status.put("demoController", Map.of(
                "uptime", getUptime(),
                "startTime", startTime,
                "activeTransactions", activeTransactions.size(),
                "lastErrors", lastErrors.size()
        ));

        // 2. –°—Ç–∞—Ç—É—Å —Å–µ—Ä–≤–∏—Å–æ–≤
        Map<String, Object> servicesStatus = new LinkedHashMap<>();
        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            String serviceName = entry.getKey();
            int port = entry.getValue();

            if ("Launcher Service".equals(serviceName)) {
                servicesStatus.put(serviceName, Map.of("status", "RUNNING", "port", port));
                continue;
            }

            boolean isManaged = isPortManagedByOrchestrator(port, serviceName);
            boolean occupied = isPortOccupied(port);

            servicesStatus.put(serviceName, Map.of(
                    "port", port,
                    "occupied", occupied,
                    "managed", isManaged,
                    "status", isManaged ? "MANAGED" : (occupied ? "EXTERNAL" : "FREE")
            ));
        }
        status.put("services", servicesStatus);

        // 3. –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        status.put("statistics", Map.of(
                "totalTransactions", totalTransactions.get(),
                "failedTransactions", failedTransactions.get(),
                "killedProcesses", killedProcesses.get(),
                "successRate", totalTransactions.get() > 0 ?
                        String.format("%.1f%%", (1 - (double)failedTransactions.get() / totalTransactions.get()) * 100) : "100%"
        ));

        // 4. –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        status.put("recommendations", getSystemRecommendations());

        status.put("timestamp", LocalDateTime.now());

        return ResponseEntity.ok(status);
    }

    @GetMapping("/diagnostics")
    @Operation(summary = "–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–∏—Å—Ç–µ–º—ã")
    public ResponseEntity<Map<String, Object>> runDiagnostics() {
        logger.info("üîß –ó–∞–ø—É—Å–∫ –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏ —Å–∏—Å—Ç–µ–º—ã...");

        Map<String, Object> diagnostics = new LinkedHashMap<>();
        List<Map<String, Object>> serviceChecks = new ArrayList<>();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            String serviceName = entry.getKey();
            int port = entry.getValue();

            Map<String, Object> check = new LinkedHashMap<>();
            check.put("service", serviceName);
            check.put("port", port);

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä—Ç–∞
            boolean portOpen = isPortOccupied(port);
            check.put("portOpen", portOpen);

            // –ï—Å–ª–∏ –ø–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç, –ø—Ä–æ–±—É–µ–º –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è
            if (portOpen && !"Launcher Service".equals(serviceName)) {
                try {
                    String[] endpoints = {
                            "http://localhost:" + port + "/actuator/health",
                            "http://localhost:" + port + "/health",
                            "http://localhost:" + port + "/",
                            "http://localhost:" + port + "/api/ping"
                    };

                    boolean anyEndpointResponds = false;
                    for (String endpoint : endpoints) {
                        try {
                            ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);
                            String endpointKey = endpoint.replace("http://localhost:" + port, "");
                            if (endpointKey.isEmpty()) endpointKey = "/";
                            check.put("endpoint_" + endpointKey,
                                    response.getStatusCode().value());
                            anyEndpointResponds = true;
                        } catch (Exception e) {
                            // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º
                        }
                    }
                    check.put("anyEndpointResponds", anyEndpointResponds);
                } catch (Exception e) {
                    check.put("checkError", e.getMessage());
                }
            }

            serviceChecks.add(check);
        }

        diagnostics.put("serviceChecks", serviceChecks);
        diagnostics.put("timestamp", LocalDateTime.now());

        // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
        List<String> recommendations = new ArrayList<>();
        long unhealthyServices = serviceChecks.stream()
                .filter(check -> !(boolean)check.getOrDefault("portOpen", false))
                .count();

        if (unhealthyServices > 0) {
            recommendations.add("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ " + unhealthyServices + " —Å–µ—Ä–≤–∏—Å–æ–≤ —Å –∑–∞–∫—Ä—ã—Ç—ã–º–∏ –ø–æ—Ä—Ç–∞–º–∏");
        }

        diagnostics.put("recommendations", recommendations);

        return ResponseEntity.ok(diagnostics);
    }

    // ============ –ü–†–ò–í–ê–¢–ù–´–ï –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ============

    private List<com.kefir.logistics.launcher_service.model.enums.ServiceType> determineRequiredServicesForDemo(String scenarioType) {
        switch (scenarioType.toLowerCase()) {
            case "cascade-errors":
                return Arrays.asList(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.COLLECTOR_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.OFFICE_SERVICE
                );
            case "normal-process":
                return Arrays.asList(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.DELIVERY_SERVICE
                );
            case "single-missing":
                return Arrays.asList(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.COLLECTOR_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.OFFICE_SERVICE
                );
            case "saga-transaction-error":
                return Arrays.asList(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SAGA_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.COLLECTOR_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.OFFICE_SERVICE
                );
            default:
                // –ü–æ —É–º–æ–ª—á–∞–Ω–∏—é –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –Ω–∞–±–æ—Ä
                return Arrays.asList(
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.SKLAD_SERVICE,
                        com.kefir.logistics.launcher_service.model.enums.ServiceType.BACKET_SERVICE
                );
        }
    }

    private boolean isValidScenarioType(String scenarioType) {
        return Arrays.asList("cascade-errors", "normal-process", "single-missing",
                        "client-demands-all", "nightmare-scenario", "saga-transaction-error")
                .contains(scenarioType.toLowerCase());
    }

    private DemoScenarioDTO getScenarioResponse(String scenarioType) {
        switch (scenarioType.toLowerCase()) {
            case "cascade-errors":
                return demoScenarioService.runCascadeErrorsDemo();
            case "normal-process":
                return demoScenarioService.runNormalProcessDemo();
            case "single-missing":
                return demoScenarioService.runSingleMissingItemDemo();
            case "saga-transaction-error":
                // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π DTO –¥–ª—è —ç—Ç–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è
                DemoScenarioDTO sagaScenario = new DemoScenarioDTO();
                sagaScenario.setTitle("–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏–æ–Ω–Ω–∞—è Saga: –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–±–æ—Ä–µ –∑–∞–∫–∞–∑–∞");
                sagaScenario.setDescription("–°—Ü–µ–Ω–∞—Ä–∏–π –∏–∑ –º–∏—Å—Å–∏–∏: —Å–±–æ—Ä—â–∏–∫ —Å—Ç–∞–ª–∫–∏–≤–∞–µ—Ç—Å—è —Å –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–º —Ç–æ–≤–∞—Ä–æ–º, " +
                        "–æ—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º, —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –ø—Ä–µ—Ä—ã–≤–∞–µ—Ç—Å—è");
                sagaScenario.setStartTime(LocalDateTime.now());
                sagaScenario.setRunning(true);
                sagaScenario.setOperationId("DEMO_SAGA_" + System.currentTimeMillis());
                sagaScenario.setStatus("STARTED");
                return sagaScenario;
            case "client-demands-all":
                // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π DTO –¥–ª—è —ç—Ç–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è
                DemoScenarioDTO clientScenario = new DemoScenarioDTO();
                clientScenario.setTitle("–ö–ª–∏–µ–Ω—Ç —Ç—Ä–µ–±—É–µ—Ç –≤—Å–µ —Ç–æ–≤–∞—Ä—ã");
                clientScenario.setDescription("–°—Ü–µ–Ω–∞—Ä–∏–π, –∫–æ–≥–¥–∞ –∫–ª–∏–µ–Ω—Ç —Ç—Ä–µ–±—É–µ—Ç –¥–æ—Å—Ç–∞–≤–∫—É –≤—Å–µ—Ö –æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö —Ç–æ–≤–∞—Ä–æ–≤");
                clientScenario.setStartTime(LocalDateTime.now());
                clientScenario.setRunning(true);
                clientScenario.setOperationId("DEMO_CLIENT_DEMANDS_ALL_" + System.currentTimeMillis());
                clientScenario.setStatus("STARTED");
                return clientScenario;
            case "nightmare-scenario":
                // –°–æ–∑–¥–∞–µ–º –±–∞–∑–æ–≤—ã–π DTO –¥–ª—è —ç—Ç–æ–≥–æ —Å—Ü–µ–Ω–∞—Ä–∏—è
                DemoScenarioDTO nightmareScenario = new DemoScenarioDTO();
                nightmareScenario.setTitle("–ù–æ—á–Ω–æ–π –∫–æ—à–º–∞—Ä (–º–∞–≥–∞–∑–∏–Ω—ã –∑–∞–∫—Ä—ã—Ç—ã)");
                nightmareScenario.setDescription("–°—Ü–µ–Ω–∞—Ä–∏–π, –∫–æ–≥–¥–∞ —Å–∫–ª–∞–¥—ã –∑–∞–∫—Ä—ã—Ç—ã –∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ –Ω–∞–π—Ç–∏ —Ç–æ–≤–∞—Ä—ã");
                nightmareScenario.setStartTime(LocalDateTime.now());
                nightmareScenario.setRunning(true);
                nightmareScenario.setOperationId("DEMO_NIGHTMARE_" + System.currentTimeMillis());
                nightmareScenario.setStatus("STARTED");
                return nightmareScenario;
            default:
                return null;
        }
    }

    private boolean isPortManagedByOrchestrator(int port, String serviceName) {
        try {
            // –ü—ã—Ç–∞–µ–º—Å—è –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å ServiceType –ø–æ –ø–æ—Ä—Ç—É
            com.kefir.logistics.launcher_service.model.enums.ServiceType serviceType =
                    com.kefir.logistics.launcher_service.model.enums.ServiceType.fromPort(port);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∑–∞–ø—É—â–µ–Ω –ª–∏ —ç—Ç–æ—Ç —Å–µ—Ä–≤–∏—Å —á–µ—Ä–µ–∑ –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä
            return serviceOrchestrator.isServiceRunning(serviceType);
        } catch (IllegalArgumentException e) {
            // –ï—Å–ª–∏ –Ω–µ –Ω–∞—à–ª–∏ ServiceType –ø–æ –ø–æ—Ä—Ç—É, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ –∏–º–µ–Ω–∏
            String serviceId = mapServiceNameToId(serviceName);
            if (serviceId != null) {
                try {
                    com.kefir.logistics.launcher_service.model.enums.ServiceType serviceType =
                            com.kefir.logistics.launcher_service.model.enums.ServiceType.fromId(serviceId);
                    return serviceOrchestrator.isServiceRunning(serviceType);
                } catch (Exception ex) {
                    return false;
                }
            }
            return false;
        } catch (Exception e) {
            logger.debug("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–æ—Ä—Ç–æ–º {}: {}", port, e.getMessage());
            return false;
        }
    }

    private String mapServiceNameToId(String serviceName) {
        Map<String, String> mapping = new HashMap<>();
        mapping.put("API Gateway", "ApiGateWay");
        mapping.put("Authentication Service", "AUTH");
        mapping.put("User Management Service", "USER");
        mapping.put("Warehouse Service", "Sklad");
        mapping.put("Shopping Cart Service", "backet-service");
        mapping.put("Office Management Service", "Office");
        mapping.put("Collector Service", "COLLECTOR");
        mapping.put("Delivery Service", "Delivery");
        mapping.put("Transaction Saga Service", "TransactionSaga");

        return mapping.get(serviceName);
    }

    private String getPortManagementRecommendation(int occupiedPorts, int managedPorts) {
        if (occupiedPorts > 0 && managedPorts == 0) {
            return "–ï—Å—Ç—å –≤–Ω–µ—à–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å—ã –Ω–∞ –ø–æ—Ä—Ç–∞—Ö KEFIR. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç—ã.";
        } else if (occupiedPorts == 0 && managedPorts == 0) {
            return "–í—Å–µ –ø–æ—Ä—Ç—ã —Å–≤–æ–±–æ–¥–Ω—ã. –ú–æ–∂–Ω–æ –∑–∞–ø—É—Å–∫–∞—Ç—å —Å–µ—Ä–≤–∏—Å—ã.";
        } else if (managedPorts > 0) {
            return "–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –ø–æ—Ä—Ç—ã —É–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –æ—Ä–∫–µ—Å—Ç—Ä–∞—Ç–æ—Ä–æ–º. –ó–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –Ω–µ —Ç—Ä–µ–±—É–µ—Ç—Å—è.";
        } else {
            return "–°—Ç–∞—Ç—É—Å –ø–æ—Ä—Ç–æ–≤ –≤ –Ω–æ—Ä–º–µ.";
        }
    }

    private List<String> getSystemRecommendations() {
        List<String> recommendations = new ArrayList<>();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤
        int externalPorts = 0;
        for (Map.Entry<String, Integer> entry : KEFIR_SERVICES.entrySet()) {
            if ("Launcher Service".equals(entry.getKey())) continue;

            if (isPortOccupied(entry.getValue()) && !isPortManagedByOrchestrator(entry.getValue(), entry.getKey())) {
                externalPorts++;
            }
        }

        if (externalPorts > 0) {
            recommendations.add("–û–±–Ω–∞—Ä—É–∂–µ–Ω–æ " + externalPorts + " –≤–Ω–µ—à–Ω–∏—Ö –ø—Ä–æ—Ü–µ—Å—Å–æ–≤ –Ω–∞ –ø–æ—Ä—Ç–∞—Ö KEFIR. –†–µ–∫–æ–º–µ–Ω–¥—É–µ—Ç—Å—è –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å /api/v1/demo/release-ports");
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
        if (!isPortOccupied(8080)) {
            recommendations.add("API Gateway (–ø–æ—Ä—Ç 8080) –Ω–µ –∑–∞–ø—É—â–µ–Ω. –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Å–µ—Ä–≤–∏—Å.");
        }

        if (!isPortOccupied(8097)) {
            recommendations.add("Auth Service (–ø–æ—Ä—Ç 8097) –Ω–µ –∑–∞–ø—É—â–µ–Ω. –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Å–µ—Ä–≤–∏—Å.");
        }

        // –û–°–û–ë–ï–ù–ù–û –í–ê–ñ–ù–û: –ü—Ä–æ–≤–µ—Ä—è–µ–º Saga Service
        if (!isPortOccupied(8090)) {
            recommendations.add("‚ö†Ô∏è Transaction Saga Service (–ø–æ—Ä—Ç 8090) –Ω–µ –∑–∞–ø—É—â–µ–Ω. –ë–ï–ó –ù–ï–ì–û –ù–ï–í–û–ó–ú–û–ñ–ù–û –í–´–ü–û–õ–ù–ò–¢–¨ –ú–ò–°–°–ò–Æ!");
            recommendations.add("   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: cd C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\TransactionSaga");
            recommendations.add("   –ö–æ–º–∞–Ω–¥–∞: mvn spring-boot:run -Dserver.port=8090");
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–≥—Ä—É–∑–∫—É
        Runtime runtime = Runtime.getRuntime();
        long memoryUsagePercent = (runtime.totalMemory() - runtime.freeMemory()) * 100 / runtime.maxMemory();
        if (memoryUsagePercent > 80) {
            recommendations.add("–í—ã—Å–æ–∫–∞—è –∑–∞–≥—Ä—É–∑–∫–∞ –ø–∞–º—è—Ç–∏: " + memoryUsagePercent + "%. –†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ —É–≤–µ–ª–∏—á–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏.");
        }

        if (recommendations.isEmpty()) {
            recommendations.add("–°–∏—Å—Ç–µ–º–∞ –≤ –Ω–æ—Ä–º–µ. –í—Å–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã.");
        }

        return recommendations;
    }

    private void startBackgroundTasks() {
        // –ó–∞–¥–∞—á–∞ –¥–ª—è –ø–µ—Ä–∏–æ–¥–∏—á–µ—Å–∫–æ–π –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ—Ä—Ç–æ–≤
        scheduler.scheduleAtFixedRate(() -> {
            try {
                checkCriticalPorts();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø–æ—Ä—Ç–æ–≤: {}", e.getMessage());
            }
        }, 1, 5, TimeUnit.MINUTES);

        // –ó–∞–¥–∞—á–∞ –¥–ª—è –æ—á–∏—Å—Ç–∫–∏ —Å—Ç–∞—Ä—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
        scheduler.scheduleAtFixedRate(() -> {
            try {
                cleanupOldTransactions();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ –æ—á–∏—Å—Ç–∫–∏ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π: {}", e.getMessage());
            }
        }, 10, 10, TimeUnit.MINUTES);

        // –ó–∞–¥–∞—á–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–∏—Å–æ–≤
        scheduler.scheduleAtFixedRate(() -> {
            try {
                checkServicesHealth();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è: {}", e.getMessage());
            }
        }, 2, 3, TimeUnit.MINUTES);

        // –ó–∞–¥–∞—á–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ Saga Service (–û–°–û–ë–ï–ù–ù–û –í–ê–ñ–ù–û!)
        scheduler.scheduleAtFixedRate(() -> {
            try {
                checkSagaService();
            } catch (Exception e) {
                logger.error("–û—à–∏–±–∫–∞ –≤ —Ñ–æ–Ω–æ–≤–æ–π –∑–∞–¥–∞—á–µ –ø—Ä–æ–≤–µ—Ä–∫–∏ Saga: {}", e.getMessage());
            }
        }, 30, 60, TimeUnit.SECONDS);

        logger.info("üöÄ –§–æ–Ω–æ–≤—ã–µ –∑–∞–¥–∞—á–∏ –∑–∞–ø—É—â–µ–Ω—ã");
    }

    private void scheduleAutoStart(String scenarioType, long delayMs) {
        scheduler.schedule(() -> {
            try {
                logger.info("‚è∞ –ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è: {}", scenarioType);

                // –í—ã–∑—ã–≤–∞–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –º–µ—Ç–æ–¥ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Ç–∏–ø–∞ —Å—Ü–µ–Ω–∞—Ä–∏—è
                switch (scenarioType.toLowerCase()) {
                    case "cascade-errors":
                        runCascadeErrorsDemo();
                        break;
                    case "normal-process":
                        runNormalProcessDemo();
                        break;
                    case "single-missing":
                        runSingleMissingItemDemo();
                        break;
                    case "saga-transaction-error":
                        runSagaTransactionErrorDemo();
                        break;
                    default:
                        logger.warn("–ê–≤—Ç–æ–∑–∞–ø—É—Å–∫ –¥–ª—è —Å—Ü–µ–Ω–∞—Ä–∏—è {} –Ω–µ —Ä–µ–∞–ª–∏–∑–æ–≤–∞–Ω", scenarioType);
                        break;
                }
            } catch (Exception e) {
                logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∞–≤—Ç–æ–∑–∞–ø—É—Å–∫–µ —Å—Ü–µ–Ω–∞—Ä–∏—è {}: {}", scenarioType, e.getMessage());
            }
        }, delayMs, TimeUnit.MILLISECONDS);
    }

    private Map<String, Object> stopAllRunningServices() {
        Map<String, Object> result = new LinkedHashMap<>();
        List<String> stoppedServices = new ArrayList<>();

        runningServices.forEach((name, info) -> {
            if (info.process != null && info.process.isAlive()) {
                try {
                    info.process.destroy();
                    if (info.process.waitFor(5, TimeUnit.SECONDS)) {
                        info.status = "STOPPED";
                        info.process = null;
                        stoppedServices.add(name);
                        logger.info("‚úÖ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: {}", name);
                    } else {
                        info.process.destroyForcibly();
                        logger.warn("‚ö†Ô∏è –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: {}", name);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–µ—Ä–≤–∏—Å–∞ {}: {}", name, e.getMessage());
                }
            }
        });

        result.put("stoppedServices", stoppedServices);
        result.put("count", stoppedServices.size());
        result.put("timestamp", LocalDateTime.now());

        return result;
    }

    private boolean releasePortIfNeeded(int port, String serviceName) {
        if (!isPortOccupied(port)) {
            return true;
        }

        String pid = findProcessIdOnPort(port);
        if (pid != null && !pid.isEmpty()) {
            try {
                String killCmd = getKillCommand(pid);
                Process process = Runtime.getRuntime().exec(killCmd);
                int exitCode = process.waitFor();

                if (exitCode == 0) {
                    killedProcesses.incrementAndGet();
                    Thread.sleep(1000);
                    return !isPortOccupied(port);
                }
            } catch (Exception e) {
                logger.warn("–ù–µ —É–¥–∞–ª–æ—Å—å —É–±–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å {} –Ω–∞ –ø–æ—Ä—Ç—É {}: {}", pid, port, e.getMessage());
            }
        }

        return false;
    }

    private String getServiceNameByPort(int port) {
        return KEFIR_SERVICES.entrySet().stream()
                .filter(entry -> entry.getValue() == port)
                .map(Map.Entry::getKey)
                .findFirst()
                .orElse("Unknown Service");
    }

    private void createDirectories() {
        try {
            Path reportDir = getReportDirectory();
            if (!Files.exists(reportDir)) {
                Files.createDirectories(reportDir);
                logger.info("–°–æ–∑–¥–∞–Ω–∞ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è –æ—Ç—á–µ—Ç–æ–≤: {}", reportDir);
            }
        } catch (IOException e) {
            logger.error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏: {}", e.getMessage(), e);
        }
    }

    private void checkCriticalPorts() {
        int[] criticalPorts = {8080, 8090, 8097}; // API Gateway, Saga, Auth

        for (int port : criticalPorts) {
            boolean occupied = isPortOccupied(port);
            String serviceName = getServiceNameByPort(port);

            logger.debug("–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ—Ä—Ç–∞ {} ({}): {}", port, serviceName, occupied ? "–∑–∞–Ω—è—Ç" : "—Å–≤–æ–±–æ–¥–µ–Ω");
        }
    }

    private void checkSagaService() {
        boolean sagaRunning = isPortOccupied(8090);

        if (sagaRunning) {
            try {
                // –ü—ã—Ç–∞–µ–º—Å—è –ø–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å Saga
                ResponseEntity<String> response = restTemplate.getForEntity(
                        "http://localhost:8090/actuator/health",
                        String.class
                );

                if (response.getStatusCode().is2xxSuccessful()) {
                    logger.debug("‚úÖ Transaction Saga Service —Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–æ—Ä–º–∞–ª—å–Ω–æ");
                } else {
                    logger.warn("‚ö†Ô∏è Saga —Å–µ—Ä–≤–∏—Å –∑–∞–ø—É—â–µ–Ω, –Ω–æ health check –≤–µ—Ä–Ω—É–ª {}", response.getStatusCode());
                }
            } catch (Exception e) {
                logger.warn("‚ö†Ô∏è Saga —Å–µ—Ä–≤–∏—Å –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ health check: {}", e.getMessage());
            }
        } else {
            logger.warn("‚ö†Ô∏è Transaction Saga Service (–ø–æ—Ä—Ç 8090) –Ω–µ –∑–∞–ø—É—â–µ–Ω!");
            logger.warn("   –≠—Ç–æ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏ –≤–∞–∂–Ω–æ –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è!");
            logger.warn("   –ó–∞–ø—É—Å—Ç–∏—Ç–µ: cd C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\TransactionSaga");
            logger.warn("   –ö–æ–º–∞–Ω–¥–∞: mvn spring-boot:run -Dserver.port=8090");
        }
    }

    private void checkServicesHealth() {
        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
            int[] criticalPorts = {8080, 8090, 8097};
            int healthyCount = 0;

            for (int port : criticalPorts) {
                try (Socket socket = new Socket()) {
                    socket.connect(new InetSocketAddress("localhost", port), 2000);
                    healthyCount++;
                } catch (IOException e) {
                    String serviceName = getServiceNameByPort(port);
                    logger.warn("–ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–π —Å–µ—Ä–≤–∏—Å {} (–ø–æ—Ä—Ç {}) –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç", serviceName, port);
                }
            }

            if (healthyCount < criticalPorts.length) {
                logger.info("–¢–æ–ª—å–∫–æ {}/{} –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∑–¥–æ—Ä–æ–≤—ã", healthyCount, criticalPorts.length);
            }
        } catch (Exception e) {
            logger.debug("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–∏—Å–æ–≤: {}", e.getMessage());
        }
    }

    private void cleanupOldTransactions() {
        LocalDateTime cutoff = LocalDateTime.now().minusHours(1);
        List<String> toRemove = new ArrayList<>();

        activeTransactions.forEach((id, info) -> {
            if (info.endTime != null && info.endTime.isBefore(cutoff)) {
                toRemove.add(id);
            }
        });

        if (!toRemove.isEmpty()) {
            toRemove.forEach(activeTransactions::remove);
            logger.debug("–û—á–∏—â–µ–Ω–æ {} —Å—Ç–∞—Ä—ã—Ö —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π", toRemove.size());
        }
    }

    private void executeFullMissionScenario(String operationId, TransactionInfo transaction) {
        try {
            logger.info("=== –ù–ê–ß–ê–õ–û –°–¶–ï–ù–ê–†–ò–Ø –ú–ò–°–°–ò–ò ===");
            transaction.steps.add("üéØ –ù–∞—á–∞–ª–æ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –º–∏—Å—Å–∏–∏");

            // 1. –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞: –ø—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ Saga —Ä–∞–±–æ—Ç–∞–µ—Ç
            transaction.steps.add("1. üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ Transaction Saga");
            boolean sagaRunning = isPortOccupied(8090);

            if (!sagaRunning) {
                transaction.steps.add("   ‚ùå Saga –Ω–µ –∑–∞–ø—É—â–µ–Ω, –º–∏—Å—Å–∏—è –Ω–µ–≤–æ–∑–º–æ–∂–Ω–∞");
                throw new RuntimeException("Transaction Saga Service –Ω–µ –∑–∞–ø—É—â–µ–Ω");
            }

            transaction.steps.add("   ‚úÖ Saga –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É 8090");

            // 2. –°—Ü–µ–Ω–∞—Ä–∏–π –∏–∑ –º–∏—Å—Å–∏–∏
            transaction.steps.add("2. üìñ –í–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏—è –∏–∑ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏:");
            transaction.steps.add("   üì¶ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ —á–µ—Ä–µ–∑ –∫–æ—Ä–∑–∏–Ω—É (Backet Service)");
            Thread.sleep(2000);

            transaction.steps.add("   üè≠ –°–±–æ—Ä—â–∏–∫ –ø–æ–ª—É—á–∞–µ—Ç –∑–∞–¥–∞–Ω–∏–µ (Collector Service)");
            Thread.sleep(2000);

            transaction.steps.add("   ‚ö†Ô∏è –û–®–ò–ë–ö–ê: –û–¥–∏–Ω —Ç–æ–≤–∞—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞ —Å–∫–ª–∞–¥–µ (Sklad Service)");
            Thread.sleep(3000);

            transaction.steps.add("   üìû –°–±–æ—Ä—â–∏–∫ –æ–±—Ä–∞—â–∞–µ—Ç—Å—è –≤ –æ—Ñ–∏—Å (Office Service)");
            Thread.sleep(2000);

            transaction.steps.add("   üë®‚Äçüíº –û—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –ø–æ–∫—É–ø–∞—Ç–µ–ª–µ–º (—Ç–µ–ª–µ—Ñ–æ–Ω–Ω—ã–π –∑–≤–æ–Ω–æ–∫)");
            Thread.sleep(2000);

            transaction.steps.add("   üí∞ Transaction Saga –ø–æ–ª—É—á–∞–µ—Ç —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ");
            Thread.sleep(1000);

            transaction.steps.add("   üîÑ Saga —á–∞—Å—Ç–∏—á–Ω–æ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é");
            Thread.sleep(1000);

            transaction.steps.add("   üíµ –î–µ–Ω—å–≥–∏ –≤–æ–∑–≤—Ä–∞—â–∞—é—Ç—Å—è –∑–∞ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä");
            Thread.sleep(1000);

            transaction.steps.add("   üÜï –°–æ–∑–¥–∞–µ—Ç—Å—è –Ω–æ–≤–∞—è —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –¥–ª—è –æ—Å—Ç–∞–≤—à–∏—Ö—Å—è —Ç–æ–≤–∞—Ä–æ–≤");
            Thread.sleep(1000);

            transaction.steps.add("   üè≠ –°–±–æ—Ä—â–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä–∫—É –∑–∞–Ω–æ–≤–æ");
            Thread.sleep(2000);

            // 3. –ü—Ä–æ–±–ª–µ–º–∞ –∏–∑ –º–∏—Å—Å–∏–∏
            transaction.steps.add("3. üö® –ü–†–û–ë–õ–ï–ú–ê (–æ–ø–∏—Å–∞–Ω–Ω–∞—è –≤ –º–∏—Å—Å–∏–∏):");
            transaction.steps.add("   üè¨ –¢–æ–≤–∞—Ä—ã –Ω–∞—Ö–æ–¥—è—Ç—Å—è –Ω–∞ —Ä–∞–∑–Ω—ã—Ö —Å–∫–ª–∞–¥–∞—Ö");
            transaction.steps.add("   üöö –ö—É—Ä—å–µ—Ä –¥–æ–ª–∂–µ–Ω –æ–±—ä–µ—Ö–∞—Ç—å –Ω–µ—Å–∫–æ–ª—å–∫–æ —Å–∫–ª–∞–¥–æ–≤");
            transaction.steps.add("   ‚è∞ –í—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏: 1 –ß–ê–° –≤–º–µ—Å—Ç–æ –æ–±—ã—á–Ω—ã—Ö 15 –ú–ò–ù–£–¢");
            transaction.steps.add("   üí∏ –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∏–µ —Ä–∞—Å—Ö–æ–¥—ã");
            Thread.sleep(3000);

            // 4. –†–µ—à–µ–Ω–∏–µ –∏–∑ –º–∏—Å—Å–∏–∏
            transaction.steps.add("4. üí° –†–ï–®–ï–ù–ò–ï (–ø—Ä–µ–¥–ª–æ–∂–µ–Ω–Ω–æ–µ –≤ –º–∏—Å—Å–∏–∏):");
            transaction.steps.add("   ‚úÖ –û—Ç–º–µ–Ω—è—Ç—å —Å—Ç–∞—Ä—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –ø–æ–ª–Ω–æ—Å—Ç—å—é");
            transaction.steps.add("   ‚úÖ –°–æ–∑–¥–∞–≤–∞—Ç—å –Ω–æ–≤—É—é —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é —Å –Ω–∞—á–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏");
            transaction.steps.add("   ‚úÖ –°–±–æ—Ä—â–∏–∫ –¥–æ–ª–∂–µ–Ω –í–°–ï —Ç–æ–≤–∞—Ä—ã –ø–µ—Ä–µ–ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∑–∞–Ω–æ–≤–æ");
            transaction.steps.add("   ‚úÖ –≠—Ç–æ –∫–∞–∫ '–ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∏—Ç—å –ø—Ä–æ—Ü–µ—Å—Å' –ø—Ä–∏ –Ω–µ–∏–∑–≤–µ—Å—Ç–Ω–æ–π –æ—à–∏–±–∫–µ");
            Thread.sleep(3000);

            // 5. –î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤
            transaction.steps.add("5. üìä –î–ï–ú–û–ù–°–¢–†–ê–¶–ò–Ø –ø—Ä–µ–∏–º—É—â–µ—Å—Ç–≤ —Ä–µ—à–µ–Ω–∏—è:");
            transaction.steps.add("   üïí –≠–∫–æ–Ω–æ–º–∏—è –≤—Ä–µ–º–µ–Ω–∏: 15 –º–∏–Ω—É—Ç vs 1 —á–∞—Å");
            transaction.steps.add("   üí∞ –°–Ω–∏–∂–µ–Ω–∏–µ –ª–æ–≥–∏—Å—Ç–∏—á–µ—Å–∫–∏—Ö —Ä–∞—Å—Ö–æ–¥–æ–≤");
            transaction.steps.add("   üëç –£–ø—Ä–æ—â–µ–Ω–∏–µ –ø—Ä–æ—Ü–µ—Å—Å–∞ –¥–ª—è —Å–±–æ—Ä—â–∏–∫–æ–≤");
            transaction.steps.add("   üîí –ì–∞—Ä–∞–Ω—Ç–∏—è —Ü–µ–ª–æ—Å—Ç–Ω–æ—Å—Ç–∏ –¥–∞–Ω–Ω—ã—Ö —á–µ—Ä–µ–∑ Saga");

            // 6. –ò–º–∏—Ç–∞—Ü–∏—è API –≤—ã–∑–æ–≤–æ–≤
            transaction.steps.add("6. üîó –ò–º–∏—Ç–∞—Ü–∏—è —Ä–µ–∞–ª—å–Ω—ã—Ö API –≤—ã–∑–æ–≤–æ–≤:");

            try {
                // –ü—Ä–æ–±—É–µ–º —Å–≤—è–∑–∞—Ç—å—Å—è —Å Saga
                transaction.steps.add("   üîÑ –û—Ç–ø—Ä–∞–≤–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ –≤ Transaction Saga...");
                ResponseEntity<String> sagaResponse = restTemplate.getForEntity(
                        "http://localhost:8090/actuator/info",
                        String.class
                );

                if (sagaResponse.getStatusCode().is2xxSuccessful()) {
                    transaction.steps.add("   ‚úÖ Saga –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã");
                }
            } catch (Exception e) {
                transaction.steps.add("   ‚ö†Ô∏è Saga –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ –∑–∞–ø—Ä–æ—Å—ã, –Ω–æ —Å—Ü–µ–Ω–∞—Ä–∏–π –ø—Ä–æ–¥–æ–ª–∂–∞–µ—Ç—Å—è");
            }

            // 7. –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ
            transaction.steps.add("7. üéâ –ó–ê–í–ï–†–®–ï–ù–ò–ï –°–¶–ï–ù–ê–†–ò–Ø –ú–ò–°–°–ò–ò");
            transaction.steps.add("   ‚úÖ –ü—Ä–æ–±–ª–µ–º–∞ —É—Å–ø–µ—à–Ω–æ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞");
            transaction.steps.add("   ‚úÖ –†–µ—à–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ –∏ –æ–±–æ—Å–Ω–æ–≤–∞–Ω–æ");
            transaction.steps.add("   ‚úÖ Transaction Saga –ø–æ–∫–∞–∑–∞–ª —Å–≤–æ—é —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å");
            transaction.steps.add("   ‚úÖ –ú–∏—Å—Å–∏—è –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –í–´–ü–û–õ–ù–ï–ù–ê");

            logger.info("=== –ó–ê–í–ï–†–®–ï–ù–ò–ï –°–¶–ï–ù–ê–†–ò–Ø –ú–ò–°–°–ò–ò ===");
            logger.info("‚úÖ –ú–∏—Å—Å–∏—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∞: –ø—Ä–æ–±–ª–µ–º–∞ –ø—Ä–æ–¥–µ–º–æ–Ω—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∞, —Ä–µ—à–µ–Ω–∏–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–æ");
            logger.info("‚úÖ Transaction Saga –ø–æ–∫–∞–∑–∞–ª —Å–µ–±—è –∫–∞–∫ —ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ–µ —Ä–µ—à–µ–Ω–∏–µ");
            logger.info("‚úÖ –í—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏ —Å–æ–∫—Ä–∞—â–µ–Ω–æ —Å 1 —á–∞—Å–∞ –¥–æ 15 –º–∏–Ω—É—Ç");

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            transaction.status = "COMPLETED";
            transaction.endTime = LocalDateTime.now();
            transaction.data.put("missionCompleted", true);
            transaction.data.put("problemDemonstrated", true);
            transaction.data.put("solutionProposed", true);
            transaction.data.put("sagaEffective", true);
            transaction.data.put("deliveryTimeReduction", "1 —á–∞—Å ‚Üí 15 –º–∏–Ω—É—Ç");

            totalTransactions.incrementAndGet();

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            transaction.steps.add("‚ùå –°—Ü–µ–Ω–∞—Ä–∏–π –ø—Ä–µ—Ä–≤–∞–Ω");
            transaction.status = "INTERRUPTED";
            transaction.endTime = LocalDateTime.now();
        } catch (Exception e) {
            logger.error("‚ùå –û—à–∏–±–∫–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ü–µ–Ω–∞—Ä–∏—è –º–∏—Å—Å–∏–∏: {}", e.getMessage());
            transaction.steps.add("‚ùå –û—à–∏–±–∫–∞: " + e.getMessage());
            transaction.status = "FAILED";
            transaction.endTime = LocalDateTime.now();
            failedTransactions.incrementAndGet();
        }
    }

    private Path getReportDirectory() {
        try {
            String baseDir = reportsDirectory;
            if (baseDir.startsWith("./")) {
                baseDir = System.getProperty("user.dir") + baseDir.substring(1);
            }
            return Paths.get(baseDir).toAbsolutePath();
        } catch (Exception e) {
            return Paths.get(System.getProperty("java.io.tmpdir"), "kefir-reports");
        }
    }

    private boolean isPortOccupied(int port) {
        try (Socket socket = new Socket()) {
            socket.connect(new InetSocketAddress("localhost", port), 500);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private String findProcessIdOnPort(int port) {
        try {
            String findCmd;
            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                findCmd = "cmd /c netstat -ano | findstr :" + port + " | findstr LISTENING";
            } else {
                findCmd = "lsof -ti:" + port + " -sTCP:LISTEN";
            }

            Process process = Runtime.getRuntime().exec(findCmd);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

            String line;
            StringBuilder output = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
            process.waitFor();

            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                String[] lines = output.toString().split("\n");
                for (String netstatLine : lines) {
                    String[] parts = netstatLine.trim().split("\\s+");
                    if (parts.length >= 5) {
                        return parts[parts.length - 1];
                    }
                }
            } else {
                if (output.length() > 0) {
                    return output.toString().trim().split("\n")[0];
                }
            }

        } catch (Exception e) {
            logger.debug("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ PID –¥–ª—è –ø–æ—Ä—Ç–∞ {}: {}", port, e.getMessage());
        }
        return null;
    }

    private String getKillCommand(String pid) {
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            return "cmd /c taskkill /F /PID " + pid;
        } else {
            return "kill -9 " + pid;
        }
    }

    private String getUptime() {
        Duration uptime = Duration.between(startTime, LocalDateTime.now());
        long hours = uptime.toHours();
        long minutes = uptime.toMinutes() % 60;
        long seconds = uptime.getSeconds() % 60;

        return String.format("%d —á–∞—Å–æ–≤ %d –º–∏–Ω—É—Ç %d —Å–µ–∫—É–Ω–¥", hours, minutes, seconds);
    }
}package com.kefir.logistics.launcher.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.core.io.Resource;
import org.springframework.core.io.UrlResource;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;

@RestController
@RequestMapping("/api/v1/logs")
public class LogController {

    @GetMapping("/{serviceName}")
    public ResponseEntity<List<String>> getServiceLogs(
            @PathVariable String serviceName,
            @RequestParam(defaultValue = "100") int lines) {

        try {
            Path logFile = Paths.get("./logs/" + serviceName + ".log");
            if (Files.exists(logFile)) {
                List<String> allLines = Files.readAllLines(logFile);
                int startIndex = Math.max(0, allLines.size() - lines);
                List<String> lastLines = allLines.subList(startIndex, allLines.size());
                return ResponseEntity.ok(lastLines);
            } else {
                List<String> message = new ArrayList<>();
                message.add("Log file not found for service: " + serviceName);
                return ResponseEntity.ok(message);
            }
        } catch (IOException e) {
            List<String> error = new ArrayList<>();
            error.add("Error reading logs: " + e.getMessage());
            return ResponseEntity.internalServerError().body(error);
        }
    }

    @GetMapping("/{serviceName}/download")
    public ResponseEntity<Resource> downloadLogFile(@PathVariable String serviceName) {
        try {
            Path logFile = Paths.get("./logs/" + serviceName + ".log");
            if (Files.exists(logFile)) {
                Resource resource = new UrlResource(logFile.toUri());

                return ResponseEntity.ok()
                        .contentType(MediaType.APPLICATION_OCTET_STREAM)
                        .header(HttpHeaders.CONTENT_DISPOSITION,
                                "attachment; filename=\"" + serviceName + "-logs.log\"")
                        .body(resource);
            } else {
                return ResponseEntity.notFound().build();
            }
        } catch (IOException e) {
            return ResponseEntity.internalServerError().build();
        }
    }

    @DeleteMapping("/{serviceName}")
    public ResponseEntity<String> clearServiceLogs(@PathVariable String serviceName) {
        try {
            Path logFile = Paths.get("./logs/" + serviceName + ".log");
            if (Files.exists(logFile)) {
                Files.write(logFile, new byte[0]);
                return ResponseEntity.ok("Logs cleared for service: " + serviceName);
            } else {
                return ResponseEntity.ok("Log file not found for service: " + serviceName);
            }
        } catch (IOException e) {
            return ResponseEntity.internalServerError()
                    .body("Error clearing logs: " + e.getMessage());
        }
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.service.ServiceOrchestrator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.HashMap;
import java.util.Map;

@RestController
public class MainController {

    @Autowired
    private ApplicationContext context;

    @GetMapping("/")
    public Map<String, Object> home() {
        Map<String, Object> response = new HashMap<>();
        response.put("service", "KEFIR Launcher Service");
        response.put("version", "1.0.0");
        response.put("status", "running");
        response.put("endpoints", Map.of(
                "root", "/",
                "health", "/health",
                "autoStart", "/autostart",
                "config", "/api/v1/config/info",
                "servicesStatus", "/api/v1/services/status",
                "startAll", "/api/v1/services/start-all (POST)",
                "listServices", "/api/v1/services/list"
        ));
        response.put("timestamp", System.currentTimeMillis());
        return response;
    }

    @GetMapping("/health")
    public Map<String, String> health() {
        Map<String, String> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "launcher-service");
        response.put("time", java.time.LocalDateTime.now().toString());
        return response;
    }

    @GetMapping("/autostart")
    public Map<String, Object> autoStart() {
        Map<String, Object> response = new HashMap<>();

        new Thread(() -> {
            try {
                // –ñ–¥–µ–º 1 —Å–µ–∫—É–Ω–¥—É –ø–µ—Ä–µ–¥ —Å—Ç–∞—Ä—Ç–æ–º
                Thread.sleep(1000);

                // –ü–æ–ª—É—á–∞–µ–º ServiceOrchestrator –∏–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞ Spring
                ServiceOrchestrator orchestrator = context.getBean(ServiceOrchestrator.class);

                // –ó–∞–ø—É—Å–∫–∞–µ–º –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
                orchestrator.startAllServices();

                System.out.println("Auto-start of all services completed");

            } catch (Exception e) {
                System.err.println("Error in auto-start: " + e.getMessage());
                e.printStackTrace();
            }
        }).start();

        response.put("status", "initiated");
        response.put("message", "Auto-start of all services has been initiated");
        response.put("checkStatus", "http://localhost:8099/api/v1/services/status");
        response.put("timestamp", System.currentTimeMillis());

        return response;
    }

    @GetMapping("/ping")
    public String ping() {
        return "pong";
    }
}package com.kefir.logistics.launcher_service.controller;

import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import com.kefir.logistics.launcher_service.service.ServiceOrchestrator;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/services")
public class ServiceController {

    private final ServiceOrchestrator serviceOrchestrator;

    @Autowired
    public ServiceController(ServiceOrchestrator serviceOrchestrator) {
        this.serviceOrchestrator = serviceOrchestrator;
    }

    @GetMapping("/health")
    public ResponseEntity<Map<String, Object>> health() {
        Map<String, Object> response = new HashMap<>();
        response.put("status", "UP");
        response.put("service", "KEFIR Launcher Service");
        response.put("timestamp", System.currentTimeMillis());
        response.put("version", "1.0.0");
        return ResponseEntity.ok(response);
    }

    @PostMapping("/start-all")
    public ResponseEntity<Map<String, Object>> startAllServices() {
        List<ServiceStatusDTO> results = serviceOrchestrator.startAllServices();
        long successful = results.stream()
                .filter(status -> status.getState() != null && status.getState().isRunning())
                .count();

        Map<String, Object> response = new HashMap<>();
        response.put("message", "Services startup initiated");
        response.put("totalServices", results.size());
        response.put("successful", successful);
        response.put("failed", results.size() - successful);
        response.put("services", results);
        return ResponseEntity.ok(response);
    }

    @PostMapping("/start/{serviceName}")
    public ResponseEntity<ServiceStatusDTO> startService(@PathVariable String serviceName) {
        try {
            ServiceType serviceType = ServiceType.fromId(serviceName);
            ServiceStatusDTO result = serviceOrchestrator.startService(serviceType);
            return ResponseEntity.ok(result);
        } catch (IllegalArgumentException e) {
            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("Unknown service: " + serviceName);
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @PostMapping("/stop/{serviceName}")
    public ResponseEntity<ServiceStatusDTO> stopService(@PathVariable String serviceName) {
        try {
            ServiceType serviceType = ServiceType.fromId(serviceName);
            ServiceStatusDTO result = serviceOrchestrator.stopService(serviceType);
            return ResponseEntity.ok(result);
        } catch (IllegalArgumentException e) {
            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("Unknown service: " + serviceName);
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @PostMapping("/restart/{serviceName}")
    public ResponseEntity<ServiceStatusDTO> restartService(@PathVariable String serviceName) {
        try {
            ServiceType serviceType = ServiceType.fromId(serviceName);
            ServiceStatusDTO result = serviceOrchestrator.restartService(serviceType);
            return ResponseEntity.ok(result);
        } catch (IllegalArgumentException e) {
            ServiceStatusDTO errorResponse = new ServiceStatusDTO();
            errorResponse.setErrorMessage("Unknown service: " + serviceName);
            return ResponseEntity.badRequest().body(errorResponse);
        }
    }

    @GetMapping("/status")
    public ResponseEntity<Map<String, Object>> getAllStatus() {
        Map<ServiceType, ServiceStatusDTO> statusMap = serviceOrchestrator.getAllServiceStatuses();
        Map<String, Object> response = new HashMap<>();
        List<Map<String, Object>> services = new ArrayList<>();

        for (Map.Entry<ServiceType, ServiceStatusDTO> entry : statusMap.entrySet()) {
            Map<String, Object> serviceInfo = new HashMap<>();
            ServiceStatusDTO status = entry.getValue();

            serviceInfo.put("id", entry.getKey().getId());
            serviceInfo.put("name", entry.getKey().getDisplayName());
            serviceInfo.put("port", entry.getKey().getDefaultPort());

            if (status.getState() != null) {
                serviceInfo.put("state", status.getState().getCode());
                serviceInfo.put("stateDescription", status.getState().getDescription());
            } else {
                serviceInfo.put("state", "unknown");
                serviceInfo.put("stateDescription", "–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–æ");
            }

            serviceInfo.put("pid", status.getPid());
            serviceInfo.put("startedAt", status.getStartedAt());
            serviceInfo.put("lastChecked", status.getLastChecked());
            serviceInfo.put("errorMessage", status.getErrorMessage());

            services.add(serviceInfo);
        }

        response.put("services", services);
        response.put("total", services.size());
        response.put("timestamp", System.currentTimeMillis());

        return ResponseEntity.ok(response);
    }

    @GetMapping("/status/{serviceName}")
    public ResponseEntity<ServiceStatusDTO> getServiceStatus(@PathVariable String serviceName) {
        try {
            ServiceType serviceType = ServiceType.fromId(serviceName);
            ServiceStatusDTO status = serviceOrchestrator.getServiceStatus(serviceType);
            if (status != null) {
                return ResponseEntity.ok(status);
            }
            return ResponseEntity.notFound().build();
        } catch (IllegalArgumentException e) {
            return ResponseEntity.notFound().build();
        }
    }

    @GetMapping("/list")
    public ResponseEntity<Map<String, Object>> listAllServices() {
        Map<String, Object> response = new HashMap<>();
        List<Map<String, Object>> services = new ArrayList<>();

        for (ServiceType type : ServiceType.values()) {
            Map<String, Object> serviceInfo = new HashMap<>();
            serviceInfo.put("id", type.getId());
            serviceInfo.put("name", type.getDisplayName());
            serviceInfo.put("port", type.getDefaultPort());
            serviceInfo.put("description", type.getDisplayName());
            services.add(serviceInfo);
        }

        response.put("availableServices", services);
        response.put("count", services.size());
        response.put("timestamp", System.currentTimeMillis());

        return ResponseEntity.ok(response);
    }
}   package com.kefir.logistics.launcher_service.exception;

import com.kefir.logistics.launcher_service.model.dto.ErrorResponseDTO;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    @ExceptionHandler(ServiceLaunchException.class)
    public ResponseEntity<ErrorResponseDTO> handleServiceLaunchException(ServiceLaunchException ex) {
        logger.error("Service launch error: {}", ex.getMessage(), ex);

        ErrorResponseDTO error = new ErrorResponseDTO(
                "SERVICE_LAUNCH_FAILED",
                ex.getMessage(),
                ex.getServiceName()
        );

        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }

    @ExceptionHandler(ServiceNotFoundException.class)
    public ResponseEntity<ErrorResponseDTO> handleServiceNotFoundException(ServiceNotFoundException ex) {
        logger.warn("Service not found: {}", ex.getMessage());

        ErrorResponseDTO error = new ErrorResponseDTO(
                "SERVICE_NOT_FOUND",
                ex.getMessage(),
                ex.getServiceName()
        );

        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ErrorResponseDTO> handleIllegalArgumentException(IllegalArgumentException ex) {
        logger.warn("Invalid argument: {}", ex.getMessage());

        ErrorResponseDTO error = new ErrorResponseDTO(
                "INVALID_ARGUMENT",
                ex.getMessage(),
                null
        );

        return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponseDTO> handleGenericException(Exception ex) {
        logger.error("Unexpected error: {}", ex.getMessage(), ex);

        ErrorResponseDTO error = new ErrorResponseDTO(
                "INTERNAL_ERROR",
                "An unexpected error occurred",
                null
        );

        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}package com.kefir.logistics.launcher_service.exception;

public class ServiceLaunchException extends RuntimeException {

    private final String serviceName;
    private final String errorCode;

    public ServiceLaunchException(String serviceName, String message) {
        super("Failed to launch service '" + serviceName + "': " + message);
        this.serviceName = serviceName;
        this.errorCode = "LAUNCH_FAILED";
    }

    public ServiceLaunchException(String serviceName, String message, Throwable cause) {
        super("Failed to launch service '" + serviceName + "': " + message, cause);
        this.serviceName = serviceName;
        this.errorCode = "LAUNCH_FAILED";
    }

    public ServiceLaunchException(String serviceName, String message, String errorCode) {
        super("Failed to launch service '" + serviceName + "': " + message);
        this.serviceName = serviceName;
        this.errorCode = errorCode;
    }

    public String getServiceName() {
        return serviceName;
    }

    public String getErrorCode() {
        return errorCode;
    }
}package com.kefir.logistics.launcher_service.exception;

public class ServiceNotFoundException extends RuntimeException {

    private final String serviceName;

    public ServiceNotFoundException(String serviceName) {
        super("Service not found: " + serviceName);
        this.serviceName = serviceName;
    }

    public ServiceNotFoundException(String serviceName, String message) {
        super("Service '" + serviceName + "' not found: " + message);
        this.serviceName = serviceName;
    }

    public String getServiceName() {
        return serviceName;
    }
}package com.kefir.logistics.launcher_service.model.dto;

import com.kefir.logistics.launcher_service.model.enums.DemoScenarioType;
import java.time.LocalDateTime;
import java.util.Map;

public class DemoExecutionDTO {
    private String executionId;
    private DemoScenarioType scenarioType;
    private String scenarioTitle;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private String status; // STARTED, RUNNING, COMPLETED, FAILED, CANCELLED
    private String errorMessage;
    private int executionTimeSeconds;
    private Map<String, Object> parameters;
    private Map<String, Object> results;
    private Map<String, Object> metrics;
    private String executedBy; // –ö—Ç–æ –∑–∞–ø—É—Å—Ç–∏–ª
    private String sessionId; // ID —Å–µ—Å—Å–∏–∏

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoExecutionDTO() {
        this.executionId = "DEMO_" + System.currentTimeMillis();
        this.startTime = LocalDateTime.now();
        this.status = "STARTED";
    }

    public DemoExecutionDTO(DemoScenarioType scenarioType, String scenarioTitle) {
        this();
        this.scenarioType = scenarioType;
        this.scenarioTitle = scenarioTitle;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getExecutionId() { return executionId; }
    public void setExecutionId(String executionId) { this.executionId = executionId; }

    public DemoScenarioType getScenarioType() { return scenarioType; }
    public void setScenarioType(DemoScenarioType scenarioType) { this.scenarioType = scenarioType; }

    public String getScenarioTitle() { return scenarioTitle; }
    public void setScenarioTitle(String scenarioTitle) { this.scenarioTitle = scenarioTitle; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public int getExecutionTimeSeconds() { return executionTimeSeconds; }
    public void setExecutionTimeSeconds(int executionTimeSeconds) { this.executionTimeSeconds = executionTimeSeconds; }

    public Map<String, Object> getParameters() { return parameters; }
    public void setParameters(Map<String, Object> parameters) { this.parameters = parameters; }

    public Map<String, Object> getResults() { return results; }
    public void setResults(Map<String, Object> results) { this.results = results; }

    public Map<String, Object> getMetrics() { return metrics; }
    public void setMetrics(Map<String, Object> metrics) { this.metrics = metrics; }

    public String getExecutedBy() { return executedBy; }
    public void setExecutedBy(String executedBy) { this.executedBy = executedBy; }

    public String getSessionId() { return sessionId; }
    public void setSessionId(String sessionId) { this.sessionId = sessionId; }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    public void complete(Map<String, Object> results) {
        this.endTime = LocalDateTime.now();
        this.status = "COMPLETED";
        this.results = results;
        calculateExecutionTime();
    }

    public void fail(String errorMessage) {
        this.endTime = LocalDateTime.now();
        this.status = "FAILED";
        this.errorMessage = errorMessage;
        calculateExecutionTime();
    }

    private void calculateExecutionTime() {
        if (startTime != null && endTime != null) {
            this.executionTimeSeconds = (int) java.time.Duration.between(startTime, endTime).getSeconds();
        }
    }
}   package com.kefir.logistics.launcher_service.model.dto;

import com.kefir.logistics.launcher_service.model.enums.DemoScenarioType;
import com.kefir.logistics.launcher_service.model.enums.ErrorType;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;

public class DemoScenarioDTO {
    private DemoScenarioType scenarioType;
    private String title;
    private String description;
    private List<String> steps;
    private List<ErrorType> simulatedErrors;
    private Map<String, Object> testData;
    private LocalDateTime startTime;
    private LocalDateTime endTime;
    private boolean running;
    private Map<String, Object> results;

    // –î–û–ë–ê–í–ò–¢–¨:
    private String operationId;           // ID –æ–ø–µ—Ä–∞—Ü–∏–∏
    private String status;                // –°—Ç–∞—Ç—É—Å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    private String errorMessage;          // –°–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    private int executionTimeSeconds;     // –í—Ä–µ–º—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –≤ —Å–µ–∫—É–Ω–¥–∞—Ö
    private List<String> executedServices; // –ö–∞–∫–∏–µ —Å–µ—Ä–≤–∏—Å—ã –±—ã–ª–∏ –∑–∞–ø—É—â–µ–Ω—ã
    private Map<String, Object> metrics;  // –ú–µ—Ç—Ä–∏–∫–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoScenarioDTO() {}

    public DemoScenarioDTO(DemoScenarioType scenarioType, String title) {
        this.scenarioType = scenarioType;
        this.title = title;
        this.startTime = LocalDateTime.now();
        this.running = true;
        this.status = "STARTED";
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª–µ–π
    public DemoScenarioType getScenarioType() { return scenarioType; }
    public void setScenarioType(DemoScenarioType scenarioType) { this.scenarioType = scenarioType; }

    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public List<String> getSteps() { return steps; }
    public void setSteps(List<String> steps) { this.steps = steps; }

    public List<ErrorType> getSimulatedErrors() { return simulatedErrors; }
    public void setSimulatedErrors(List<ErrorType> simulatedErrors) { this.simulatedErrors = simulatedErrors; }

    public Map<String, Object> getTestData() { return testData; }
    public void setTestData(Map<String, Object> testData) { this.testData = testData; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }

    public boolean isRunning() { return running; }
    public void setRunning(boolean running) { this.running = running; }

    public Map<String, Object> getResults() { return results; }
    public void setResults(Map<String, Object> results) { this.results = results; }

    // –î–û–ë–ê–í–ò–¢–¨ –≥–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã –¥–ª—è –Ω–æ–≤—ã—Ö –ø–æ–ª–µ–π:
    public String getOperationId() { return operationId; }
    public void setOperationId(String operationId) { this.operationId = operationId; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public int getExecutionTimeSeconds() { return executionTimeSeconds; }
    public void setExecutionTimeSeconds(int executionTimeSeconds) { this.executionTimeSeconds = executionTimeSeconds; }

    public List<String> getExecutedServices() { return executedServices; }
    public void setExecutedServices(List<String> executedServices) { this.executedServices = executedServices; }

    public Map<String, Object> getMetrics() { return metrics; }
    public void setMetrics(Map<String, Object> metrics) { this.metrics = metrics; }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    public void complete() {
        this.endTime = LocalDateTime.now();
        this.running = false;
        this.status = "COMPLETED";

        if (this.startTime != null && this.endTime != null) {
            this.executionTimeSeconds = (int) java.time.Duration.between(startTime, endTime).getSeconds();
        }
    }

    public void fail(String errorMessage) {
        this.endTime = LocalDateTime.now();
        this.running = false;
        this.status = "FAILED";
        this.errorMessage = errorMessage;
    }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;

public class ErrorResponseDTO {

    private String errorCode;
    private String message;
    private String details;
    private LocalDateTime timestamp;
    private String serviceName;

    public ErrorResponseDTO() {
        this.timestamp = LocalDateTime.now();
    }

    public ErrorResponseDTO(String errorCode, String message, String serviceName) {
        this();
        this.errorCode = errorCode;
        this.message = message;
        this.serviceName = serviceName;
    }

    public ErrorResponseDTO(String errorCode, String message, String details, String serviceName) {
        this();
        this.errorCode = errorCode;
        this.message = message;
        this.details = details;
        this.serviceName = serviceName;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getErrorCode() { return errorCode; }
    public void setErrorCode(String errorCode) { this.errorCode = errorCode; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public String getDetails() { return details; }
    public void setDetails(String details) { this.details = details; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;

public class LogEntryDTO {

    private LocalDateTime timestamp;
    private String level;          // INFO, ERROR, WARN, DEBUG
    private String serviceName;
    private String thread;
    private String logger;
    private String message;
    private String stackTrace;     // –î–ª—è –æ—à–∏–±–æ–∫

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public LogEntryDTO() {}

    public LogEntryDTO(LocalDateTime timestamp, String level, String serviceName, String message) {
        this.timestamp = timestamp;
        this.level = level;
        this.serviceName = serviceName;
        this.message = message;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getLevel() { return level; }
    public void setLevel(String level) { this.level = level; }

    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getThread() { return thread; }
    public void setThread(String thread) { this.thread = thread; }

    public String getLogger() { return logger; }
    public void setLogger(String logger) { this.logger = logger; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public String getStackTrace() { return stackTrace; }
    public void setStackTrace(String stackTrace) { this.stackTrace = stackTrace; }

    // Builder
    public static LogEntryDTOBuilder builder() {
        return new LogEntryDTOBuilder();
    }

    public static class LogEntryDTOBuilder {
        private LocalDateTime timestamp;
        private String level;
        private String serviceName;
        private String thread;
        private String logger;
        private String message;
        private String stackTrace;

        public LogEntryDTOBuilder timestamp(LocalDateTime timestamp) {
            this.timestamp = timestamp;
            return this;
        }

        public LogEntryDTOBuilder level(String level) {
            this.level = level;
            return this;
        }

        public LogEntryDTOBuilder serviceName(String serviceName) {
            this.serviceName = serviceName;
            return this;
        }

        public LogEntryDTOBuilder thread(String thread) {
            this.thread = thread;
            return this;
        }

        public LogEntryDTOBuilder logger(String logger) {
            this.logger = logger;
            return this;
        }

        public LogEntryDTOBuilder message(String message) {
            this.message = message;
            return this;
        }

        public LogEntryDTOBuilder stackTrace(String stackTrace) {
            this.stackTrace = stackTrace;
            return this;
        }

        public LogEntryDTO build() {
            LogEntryDTO dto = new LogEntryDTO();
            dto.setTimestamp(timestamp);
            dto.setLevel(level);
            dto.setServiceName(serviceName);
            dto.setThread(thread);
            dto.setLogger(logger);
            dto.setMessage(message);
            dto.setStackTrace(stackTrace);
            return dto;
        }
    }
}package com.kefir.logistics.launcher_service.model.dto;

import com.kefir.logistics.launcher_service.model.enums.ServiceState;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;

import java.time.LocalDateTime;
import java.util.Map;

public class ServiceStatusDTO {
    private ServiceType serviceType;
    private ServiceState state;
    private Integer pid;
    private LocalDateTime startedAt;
    private LocalDateTime lastChecked;
    private String healthUrl;
    private String logPath;
    private String errorMessage;
    private Map<String, Object> metrics;
    private String version;

    // –î–û–ë–ê–í–ò–¢–¨:
    private boolean portOpen;          // –û—Ç–∫—Ä—ã—Ç –ª–∏ –ø–æ—Ä—Ç
    private int startupTimeSeconds;    // –í—Ä–µ–º—è –∑–∞–ø—É—Å–∫–∞
    private int restartCount;          // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–æ–≤
    private String lastError;          // –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞
    private LocalDateTime lastErrorTime; // –í—Ä–µ–º—è –ø–æ—Å–ª–µ–¥–Ω–µ–π –æ—à–∏–±–∫–∏

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceStatusDTO() {}

    public ServiceStatusDTO(ServiceType serviceType, ServiceState state) {
        this.serviceType = serviceType;
        this.state = state;
        this.startedAt = LocalDateTime.now();
        this.lastChecked = LocalDateTime.now();
        this.restartCount = 0;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã –¥–ª—è —Å—É—â–µ—Å—Ç–≤—É—é—â–∏—Ö –ø–æ–ª–µ–π
    public ServiceType getServiceType() { return serviceType; }
    public void setServiceType(ServiceType serviceType) { this.serviceType = serviceType; }

    public ServiceState getState() { return state; }
    public void setState(ServiceState state) { this.state = state; }

    public Integer getPid() { return pid; }
    public void setPid(Integer pid) { this.pid = pid; }

    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }

    public LocalDateTime getLastChecked() { return lastChecked; }
    public void setLastChecked(LocalDateTime lastChecked) { this.lastChecked = lastChecked; }

    public String getHealthUrl() { return healthUrl; }
    public void setHealthUrl(String healthUrl) { this.healthUrl = healthUrl; }

    public String getLogPath() { return logPath; }
    public void setLogPath(String logPath) { this.logPath = logPath; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public Map<String, Object> getMetrics() { return metrics; }
    public void setMetrics(Map<String, Object> metrics) { this.metrics = metrics; }

    public String getVersion() { return version; }
    public void setVersion(String version) { this.version = version; }

    // –î–û–ë–ê–í–ò–¢–¨ –≥–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã –¥–ª—è –Ω–æ–≤—ã—Ö –ø–æ–ª–µ–π:
    public boolean isPortOpen() { return portOpen; }
    public void setPortOpen(boolean portOpen) { this.portOpen = portOpen; }

    public int getStartupTimeSeconds() { return startupTimeSeconds; }
    public void setStartupTimeSeconds(int startupTimeSeconds) { this.startupTimeSeconds = startupTimeSeconds; }

    public int getRestartCount() { return restartCount; }
    public void setRestartCount(int restartCount) { this.restartCount = restartCount; }
    public void incrementRestartCount() { this.restartCount++; }

    public String getLastError() { return lastError; }
    public void setLastError(String lastError) {
        this.lastError = lastError;
        this.lastErrorTime = LocalDateTime.now();
    }

    public LocalDateTime getLastErrorTime() { return lastErrorTime; }
    public void setLastErrorTime(LocalDateTime lastErrorTime) { this.lastErrorTime = lastErrorTime; }

    // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ –º–µ—Ç–æ–¥—ã
    public boolean isHealthy() {
        return state != null && state.isRunning() && portOpen;
    }

    public void updateHealthCheck(boolean portOpen, String errorMessage) {
        this.lastChecked = LocalDateTime.now();
        this.portOpen = portOpen;
        if (errorMessage != null) {
            this.errorMessage = errorMessage;
            this.lastError = errorMessage;
            this.lastErrorTime = LocalDateTime.now();
        }
    }

    // Builder pattern
    public static ServiceStatusDTOBuilder builder() {
        return new ServiceStatusDTOBuilder();
    }

    public static class ServiceStatusDTOBuilder {
        private ServiceType serviceType;
        private ServiceState state;
        private Integer pid;
        private LocalDateTime startedAt;
        private LocalDateTime lastChecked;
        private String healthUrl;
        private String logPath;
        private String errorMessage;
        private Map<String, Object> metrics;
        private String version;

        public ServiceStatusDTOBuilder serviceType(ServiceType serviceType) {
            this.serviceType = serviceType;
            return this;
        }

        public ServiceStatusDTOBuilder state(ServiceState state) {
            this.state = state;
            return this;
        }

        public ServiceStatusDTOBuilder pid(Integer pid) {
            this.pid = pid;
            return this;
        }

        public ServiceStatusDTOBuilder startedAt(LocalDateTime startedAt) {
            this.startedAt = startedAt;
            return this;
        }

        public ServiceStatusDTOBuilder lastChecked(LocalDateTime lastChecked) {
            this.lastChecked = lastChecked;
            return this;
        }

        public ServiceStatusDTOBuilder healthUrl(String healthUrl) {
            this.healthUrl = healthUrl;
            return this;
        }

        public ServiceStatusDTOBuilder logPath(String logPath) {
            this.logPath = logPath;
            return this;
        }

        public ServiceStatusDTOBuilder errorMessage(String errorMessage) {
            this.errorMessage = errorMessage;
            return this;
        }

        public ServiceStatusDTOBuilder metrics(Map<String, Object> metrics) {
            this.metrics = metrics;
            return this;
        }

        public ServiceStatusDTOBuilder version(String version) {
            this.version = version;
            return this;
        }

        public ServiceStatusDTO build() {
            ServiceStatusDTO dto = new ServiceStatusDTO();
            dto.setServiceType(serviceType);
            dto.setState(state);
            dto.setPid(pid);
            dto.setStartedAt(startedAt);
            dto.setLastChecked(lastChecked);
            dto.setHealthUrl(healthUrl);
            dto.setLogPath(logPath);
            dto.setErrorMessage(errorMessage);
            dto.setMetrics(metrics);
            dto.setVersion(version);
            return dto;
        }
    }
}package com.kefir.logistics.launcher_service.model.dto;

import java.time.LocalDateTime;
import java.util.Map;
import java.util.List;

public class SystemHealthDTO {
    private String systemName;
    private String overallStatus; // UP, DOWN, DEGRADED
    private LocalDateTime checkTime;
    private Map<String, ServiceHealthDTO> services;
    private List<String> warnings;
    private List<String> errors;
    private SystemMetricsDTO metrics;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public SystemHealthDTO() {
        this.systemName = "KEFIR Logistics System";
        this.checkTime = LocalDateTime.now();
        this.overallStatus = "UP";
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getSystemName() { return systemName; }
    public void setSystemName(String systemName) { this.systemName = systemName; }

    public String getOverallStatus() { return overallStatus; }
    public void setOverallStatus(String overallStatus) { this.overallStatus = overallStatus; }

    public LocalDateTime getCheckTime() { return checkTime; }
    public void setCheckTime(LocalDateTime checkTime) { this.checkTime = checkTime; }

    public Map<String, ServiceHealthDTO> getServices() { return services; }
    public void setServices(Map<String, ServiceHealthDTO> services) { this.services = services; }

    public List<String> getWarnings() { return warnings; }
    public void setWarnings(List<String> warnings) { this.warnings = warnings; }

    public List<String> getErrors() { return errors; }
    public void setErrors(List<String> errors) { this.errors = errors; }

    public SystemMetricsDTO getMetrics() { return metrics; }
    public void setMetrics(SystemMetricsDTO metrics) { this.metrics = metrics; }
}

class ServiceHealthDTO {
    private String serviceName;
    private String status; // UP, DOWN, UNKNOWN
    private int responseTimeMs;
    private LocalDateTime lastCheck;
    private String healthEndpoint;
    private Map<String, Object> details;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceHealthDTO() {}

    public ServiceHealthDTO(String serviceName, String status) {
        this.serviceName = serviceName;
        this.status = status;
        this.lastCheck = LocalDateTime.now();
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public int getResponseTimeMs() { return responseTimeMs; }
    public void setResponseTimeMs(int responseTimeMs) { this.responseTimeMs = responseTimeMs; }

    public LocalDateTime getLastCheck() { return lastCheck; }
    public void setLastCheck(LocalDateTime lastCheck) { this.lastCheck = lastCheck; }

    public String getHealthEndpoint() { return healthEndpoint; }
    public void setHealthEndpoint(String healthEndpoint) { this.healthEndpoint = healthEndpoint; }

    public Map<String, Object> getDetails() { return details; }
    public void setDetails(Map<String, Object> details) { this.details = details; }
}

class SystemMetricsDTO {
    private int totalServices;
    private int healthyServices;
    private int unhealthyServices;
    private double healthPercentage;
    private long totalMemoryMB;
    private long usedMemoryMB;
    private double memoryUsagePercentage;
    private int cpuUsagePercentage;
    private int activeThreads;
    private int totalTransactions;
    private int failedTransactions;
    private double successRate;

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public int getTotalServices() { return totalServices; }
    public void setTotalServices(int totalServices) { this.totalServices = totalServices; }

    public int getHealthyServices() { return healthyServices; }
    public void setHealthyServices(int healthyServices) { this.healthyServices = healthyServices; }

    public int getUnhealthyServices() { return unhealthyServices; }
    public void setUnhealthyServices(int unhealthyServices) { this.unhealthyServices = unhealthyServices; }

    public double getHealthPercentage() { return healthPercentage; }
    public void setHealthPercentage(double healthPercentage) { this.healthPercentage = healthPercentage; }

    public long getTotalMemoryMB() { return totalMemoryMB; }
    public void setTotalMemoryMB(long totalMemoryMB) { this.totalMemoryMB = totalMemoryMB; }

    public long getUsedMemoryMB() { return usedMemoryMB; }
    public void setUsedMemoryMB(long usedMemoryMB) { this.usedMemoryMB = usedMemoryMB; }

    public double getMemoryUsagePercentage() { return memoryUsagePercentage; }
    public void setMemoryUsagePercentage(double memoryUsagePercentage) { this.memoryUsagePercentage = memoryUsagePercentage; }

    public int getCpuUsagePercentage() { return cpuUsagePercentage; }
    public void setCpuUsagePercentage(int cpuUsagePercentage) { this.cpuUsagePercentage = cpuUsagePercentage; }

    public int getActiveThreads() { return activeThreads; }
    public void setActiveThreads(int activeThreads) { this.activeThreads = activeThreads; }

    public int getTotalTransactions() { return totalTransactions; }
    public void setTotalTransactions(int totalTransactions) { this.totalTransactions = totalTransactions; }

    public int getFailedTransactions() { return failedTransactions; }
    public void setFailedTransactions(int failedTransactions) { this.failedTransactions = failedTransactions; }

    public double getSuccessRate() { return successRate; }
    public void setSuccessRate(double successRate) { this.successRate = successRate; }
}package com.kefir.logistics.launcher_service.model.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;
import java.time.Duration;

@Entity
@Table(name = "demo_executions")
public class DemoExecutionEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "demo_scenario_id", nullable = false)
    private Long demoScenarioId;

    @Column(name = "execution_time", nullable = false)
    private LocalDateTime executionTime;

    @Column(name = "duration_seconds")
    private Long durationSeconds;

    @Column(name = "status", nullable = false)
    private String status; // SUCCESS, FAILED, PARTIAL

    @Column(name = "error_message", length = 2000)
    private String errorMessage;

    @Column(name = "executed_by")
    private String executedBy;

    @Column(name = "metrics", columnDefinition = "TEXT")
    private String metrics; // JSON —Å –º–µ—Ç—Ä–∏–∫–∞–º–∏

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoExecutionEntity() {
        this.executionTime = LocalDateTime.now();
    }

    public DemoExecutionEntity(Long demoScenarioId, String status) {
        this();
        this.demoScenarioId = demoScenarioId;
        this.status = status;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public Long getDemoScenarioId() { return demoScenarioId; }
    public void setDemoScenarioId(Long demoScenarioId) { this.demoScenarioId = demoScenarioId; }

    public LocalDateTime getExecutionTime() { return executionTime; }
    public void setExecutionTime(LocalDateTime executionTime) { this.executionTime = executionTime; }

    public Long getDurationSeconds() { return durationSeconds; }
    public void setDurationSeconds(Long durationSeconds) { this.durationSeconds = durationSeconds; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public String getExecutedBy() { return executedBy; }
    public void setExecutedBy(String executedBy) { this.executedBy = executedBy; }

    public String getMetrics() { return metrics; }
    public void setMetrics(String metrics) { this.metrics = metrics; }

    // –ú–µ—Ç–æ–¥ –¥–ª—è —Ä–∞—Å—á–µ—Ç–∞ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏
    public void calculateDuration(LocalDateTime endTime) {
        if (endTime != null && executionTime != null) {
            this.durationSeconds = Duration.between(executionTime, endTime).getSeconds();
        }
    }
}package com.kefir.logistics.launcher_service.model.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "demo_scenarios")
public class DemoScenarioEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "scenario_type", nullable = false)
    private String scenarioType;

    @Column(name = "scenario_name", nullable = false)
    private String scenarioName;

    @Column(name = "description", length = 2000)
    private String description;

    @Column(name = "start_time")
    private LocalDateTime startTime;

    @Column(name = "end_time")
    private LocalDateTime endTime;

    @Column(name = "status")
    private String status; // CREATED, RUNNING, COMPLETED, FAILED

    @Column(name = "result_data", columnDefinition = "TEXT")
    private String resultData; // JSON —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏

    @Column(name = "created_by")
    private String createdBy;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public DemoScenarioEntity() {
        this.createdAt = LocalDateTime.now();
        this.status = "CREATED";
    }

    public DemoScenarioEntity(String scenarioType, String scenarioName) {
        this();
        this.scenarioType = scenarioType;
        this.scenarioName = scenarioName;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getScenarioType() { return scenarioType; }
    public void setScenarioType(String scenarioType) { this.scenarioType = scenarioType; }

    public String getScenarioName() { return scenarioName; }
    public void setScenarioName(String scenarioName) { this.scenarioName = scenarioName; }

    public String getDescription() { return description; }
    public void setDescription(String description) { this.description = description; }

    public LocalDateTime getStartTime() { return startTime; }
    public void setStartTime(LocalDateTime startTime) { this.startTime = startTime; }

    public LocalDateTime getEndTime() { return endTime; }
    public void setEndTime(LocalDateTime endTime) { this.endTime = endTime; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getResultData() { return resultData; }
    public void setResultData(String resultData) { this.resultData = resultData; }

    public String getCreatedBy() { return createdBy; }
    public void setCreatedBy(String createdBy) { this.createdBy = createdBy; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}package com.kefir.logistics.launcher_service.model.entity;

import jakarta.persistence.*;
import java.time.LocalDateTime;

@Entity
@Table(name = "service_logs")
@TableGenerator(name = "log_gen", table = "id_gen", pkColumnName = "gen_name",
        valueColumnName = "gen_value", pkColumnValue = "log_gen", initialValue = 1, allocationSize = 100)
public class ServiceLogEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "log_gen")
    private Long id;

    @Column(name = "service_id", nullable = false)
    private String serviceId;

    @Column(name = "log_level", nullable = false)
    private String logLevel; // INFO, ERROR, WARN, DEBUG

    @Column(name = "message", length = 4000, nullable = false)
    private String message;

    @Column(name = "timestamp", nullable = false)
    private LocalDateTime timestamp;

    @Column(name = "thread_name")
    private String threadName;

    @Column(name = "logger_name")
    private String loggerName;

    @Column(name = "stack_trace", columnDefinition = "TEXT")
    private String stackTrace;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceLogEntity() {
        this.timestamp = LocalDateTime.now();
    }

    public ServiceLogEntity(String serviceId, String logLevel, String message) {
        this();
        this.serviceId = serviceId;
        this.logLevel = logLevel;
        this.message = message;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getServiceId() { return serviceId; }
    public void setServiceId(String serviceId) { this.serviceId = serviceId; }

    public String getLogLevel() { return logLevel; }
    public void setLogLevel(String logLevel) { this.logLevel = logLevel; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }

    public LocalDateTime getTimestamp() { return timestamp; }
    public void setTimestamp(LocalDateTime timestamp) { this.timestamp = timestamp; }

    public String getThreadName() { return threadName; }
    public void setThreadName(String threadName) { this.threadName = threadName; }

    public String getLoggerName() { return loggerName; }
    public void setLoggerName(String loggerName) { this.loggerName = loggerName; }

    public String getStackTrace() { return stackTrace; }
    public void setStackTrace(String stackTrace) { this.stackTrace = stackTrace; }
}package com.kefir.logistics.launcher_service.model.entity;


import jakarta.persistence.*;

import java.time.LocalDateTime;

@Entity
@Table(name = "service_status_history")
public class ServiceStatusEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "service_id", nullable = false)
    private String serviceId;

    @Column(name = "service_name", nullable = false)
    private String serviceName;

    @Column(name = "status", nullable = false)
    private String status;

    @Column(name = "pid")
    private Integer pid;

    @Column(name = "started_at")
    private LocalDateTime startedAt;

    @Column(name = "stopped_at")
    private LocalDateTime stoppedAt;

    @Column(name = "error_message", length = 1000)
    private String errorMessage;

    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    // –ö–æ–Ω—Å—Ç—Ä—É–∫—Ç–æ—Ä—ã
    public ServiceStatusEntity() {
        this.createdAt = LocalDateTime.now();
    }

    public ServiceStatusEntity(String serviceId, String serviceName, String status) {
        this();
        this.serviceId = serviceId;
        this.serviceName = serviceName;
        this.status = status;
    }

    // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
    public Long getId() { return id; }
    public void setId(Long id) { this.id = id; }

    public String getServiceId() { return serviceId; }
    public void setServiceId(String serviceId) { this.serviceId = serviceId; }

    public String getServiceName() { return serviceName; }
    public void setServiceName(String serviceName) { this.serviceName = serviceName; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public Integer getPid() { return pid; }
    public void setPid(Integer pid) { this.pid = pid; }

    public LocalDateTime getStartedAt() { return startedAt; }
    public void setStartedAt(LocalDateTime startedAt) { this.startedAt = startedAt; }

    public LocalDateTime getStoppedAt() { return stoppedAt; }
    public void setStoppedAt(LocalDateTime stoppedAt) { this.stoppedAt = stoppedAt; }

    public String getErrorMessage() { return errorMessage; }
    public void setErrorMessage(String errorMessage) { this.errorMessage = errorMessage; }

    public LocalDateTime getCreatedAt() { return createdAt; }
    public void setCreatedAt(LocalDateTime createdAt) { this.createdAt = createdAt; }
}package com.kefir.logistics.launcher_service.model.enums;

public enum DemoScenarioType {
    NORMAL_PROCESS("–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–∫–∞–∑–∞"),
    SINGLE_MISSING_ITEM("–û–¥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä"),
    CASCADE_ERRORS("–ö–∞—Å–∫–∞–¥–Ω—ã–µ –æ—à–∏–±–∫–∏ (–ì–ª–∞–≤–Ω—ã–π –¥–µ–º–æ)"),
    CLIENT_DEMANDS_ALL("–ö–ª–∏–µ–Ω—Ç —Ç—Ä–µ–±—É–µ—Ç –≤—Å–µ —Ç–æ–≤–∞—Ä—ã"),
    NIGHTMARE_SCENARIO("–ù–æ—á–Ω–æ–π –∫–æ—à–º–∞—Ä (–º–∞–≥–∞–∑–∏–Ω—ã –∑–∞–∫—Ä—ã—Ç—ã)");

    private final String description;

    DemoScenarioType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}package com.kefir.logistics.launcher_service.model.enums;

public enum ErrorType {
    PRODUCT_NOT_FOUND("–¢–æ–≤–∞—Ä –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –Ω–∞ —Å–∫–ª–∞–¥–µ"),
    LOW_STOCK("–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–≤–∞—Ä–∞"),
    TRANSACTION_TIMEOUT("–¢–∞–π–º–∞—É—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏"),
    WAREHOUSE_CLOSED("–°–∫–ª–∞–¥ –∑–∞–∫—Ä—ã—Ç"),
    DELIVERY_FAILED("–û—à–∏–±–∫–∞ –¥–æ—Å—Ç–∞–≤–∫–∏"),
    PAYMENT_FAILED("–û—à–∏–±–∫–∞ –æ–ø–ª–∞—Ç—ã");

    private final String description;

    ErrorType(String description) {
        this.description = description;
    }

    public String getDescription() {
        return description;
    }
}package com.kefir.logistics.launcher_service.model.enums;

public enum ServiceState {
    STOPPED("stopped", "–û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", false),
    STARTING("starting", "–ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è", false),
    RUNNING("running", "–†–∞–±–æ—Ç–∞–µ—Ç", true),
    FAILED("failed", "–û—à–∏–±–∫–∞", false),
    RESTARTING("restarting", "–ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ—Ç—Å—è", false),
    HEALTHY("healthy", "–ó–¥–æ—Ä–æ–≤", true),
    UNHEALTHY("unhealthy", "–ù–µ –∑–¥–æ—Ä–æ–≤", false);

    private final String code;
    private final String description;
    private final boolean active;

    ServiceState(String code, String description, boolean active) {
        this.code = code;
        this.description = description;
        this.active = active;
    }

    public String getCode() {
        return code;
    }

    public String getDescription() {
        return description;
    }

    public boolean isActive() {
        return active;
    }

    public boolean isRunning() {
        return this == RUNNING || this == HEALTHY;
    }

    public boolean isStopped() {
        return this == STOPPED;
    }

    public boolean isFailed() {
        return this == FAILED || this == UNHEALTHY;
    }
}package com.kefir.logistics.launcher_service.model.enums;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonValue;
import com.kefir.logistics.launcher_service.config.ApplicationProperties;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Scope;
import org.springframework.stereotype.Component;

import jakarta.annotation.PostConstruct;

public enum ServiceType {
    AUTH_SERVICE("AUTH", 8097, "Auth", "Authentication Service"),
    USER_SERVICE("USER", 8081, "User", "User Management Service"),
    SKLAD_SERVICE("Sklad", 8082, "Sklad", "Warehouse Service"),
    BACKET_SERVICE("backet-service", 8083, "Backet", "Shopping Cart Service"),
    OFFICE_SERVICE("Office", 8085, "Office", "Office Management Service"),
    COLLECTOR_SERVICE("COLLECTOR", 8086, "Collector", "Collector Service"),
    DELIVERY_SERVICE("Delivery", 8088, "Delivery", "Delivery Service"),
    SAGA_SERVICE("TransactionSaga", 8090, "TransactionSaga", "Transaction Saga Service"),
    API_GATEWAY("ApiGateWay", 8080, "ApiGateWay", "API Gateway");

    private String id;
    private int port;
    private String directory;
    private String displayName;

    ServiceType(String id, int port, String directory, String displayName) {
        this.id = id;
        this.port = port;
        this.directory = directory;
        this.displayName = displayName;
    }

    @JsonValue
    public String getId() {
        return id;
    }

    public int getPort() {
        return port;
    }
public int getDefaultPort(){
        return port;
}
    public String getDirectory() {
        return directory;
    }

    public String getDisplayName() {
        return displayName;
    }

    // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ª–Ω–æ–≥–æ –ø—É—Ç–∏ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
    public String getFullDirectory(ApplicationProperties appProperties) {
        if (appProperties != null && appProperties.getServiceConfig(this.id) != null) {
            ApplicationProperties.ServiceConfig config = appProperties.getServiceConfig(this.id);
            return config.getDirectory() != null ? config.getDirectory() : this.directory;
        }
        return this.directory;
    }

    // –°—Ç–∞—Ç–∏—á–µ—Å–∫–∏–π –º–µ—Ç–æ–¥ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –ø–æ—Ä—Ç–∞ –∏–∑ –∫–æ–Ω—Ñ–∏–≥–∞
    public int getConfiguredPort(ApplicationProperties appProperties) {
        if (appProperties != null && appProperties.getServiceConfig(this.id) != null) {
            ApplicationProperties.ServiceConfig config = appProperties.getServiceConfig(this.id);
            return config.getPort() > 0 ? config.getPort() : this.port;
        }
        return this.port;
    }

    @JsonCreator
    public static ServiceType fromId(String id) {
        for (ServiceType type : values()) {
            if (type.id.equalsIgnoreCase(id)) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unknown service: " + id);
    }

    public static ServiceType fromPort(int port) {
        for (ServiceType type : values()) {
            if (type.port == port) {
                return type;
            }
        }
        throw new IllegalArgumentException("Unknown port: " + port);
    }
}package com.kefir.logistics.launcher_service.service;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextRefreshedEvent;
import org.springframework.stereotype.Component;

@Component
public class DemoAutoStarter implements ApplicationListener<ContextRefreshedEvent> {
    private static final Logger logger = LoggerFactory.getLogger(DemoAutoStarter.class);
    private static boolean alreadyStarted = false;

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    @Autowired
    private ApplicationContext applicationContext;

    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        if (!alreadyStarted) {
            alreadyStarted = true;

            logger.info("=== –ê–í–¢–û–°–¢–ê–†–¢ –°–ò–°–¢–ï–ú–´ KEFIR LOGISTICS ===");

            // –ó–∞–ø—É—Å–∫ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ —Å –∑–∞–¥–µ—Ä–∂–∫–æ–π
            new Thread(() -> {
                try {
                    // –ñ–¥–µ–º 5 —Å–µ–∫—É–Ω–¥ –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ –ª–∞—É–Ω—á–µ—Ä–∞
                    Thread.sleep(5000);

                    logger.info("üöÄ –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –º–∏–∫—Ä–æ—Å–µ—Ä–≤–∏—Å–æ–≤...");
                    serviceOrchestrator.startAllServices();

                    // –î–µ–º–æ –∑–∞–ø—É—Å—Ç–∏—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∏–∑ ServiceOrchestrator

                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    logger.error("–ê–≤—Ç–æ—Å—Ç–∞—Ä—Ç –ø—Ä–µ—Ä–≤–∞–Ω");
                } catch (Exception e) {
                    logger.error("–û—à–∏–±–∫–∞ –∞–≤—Ç–æ—Å—Ç–∞—Ä—Ç–∞: {}", e.getMessage(), e);
                }
            }).start();
        }
    }
}package com.kefir.logistics.launcher_service.service;

import com.kefir.logistics.launcher_service.model.dto.DemoScenarioDTO;
import com.kefir.logistics.launcher_service.model.enums.DemoScenarioType;
import com.kefir.logistics.launcher_service.model.enums.ErrorType;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;
import java.time.LocalDateTime;
import java.util.*;

@Service
public class DemoScenarioService {

    private static final Logger logger = LoggerFactory.getLogger(DemoScenarioService.class);

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    private final Map<String, DemoScenarioDTO> activeScenarios = new HashMap<>();

    /**
     * –ì–ª–∞–≤–Ω—ã–π –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–π: –ö–∞—Å–∫–∞–¥–Ω—ã–µ –æ—à–∏–±–∫–∏ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤
     */
    public DemoScenarioDTO runCascadeErrorsDemo() {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ –¥–µ–º–æ: –ö–ê–°–ö–ê–î–ù–´–ï –û–®–ò–ë–ö–ò");

        DemoScenarioDTO scenario = createCascadeErrorsScenario();
        activeScenarios.put(scenario.getScenarioType().name(), scenario);

        // –ó–∞–ø—É—Å–∫–∞–µ–º –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
        new Thread(() -> executeCascadeErrorsScenario(scenario)).start();

        return scenario;
    }

    private DemoScenarioDTO createCascadeErrorsScenario() {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(DemoScenarioType.CASCADE_ERRORS);
        scenario.setTitle("–ö–∞—Å–∫–∞–¥–Ω—ã–µ –æ—à–∏–±–∫–∏ –ø—Ä–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤");
        scenario.setDescription("–î–µ–º–æ–Ω—Å—Ç—Ä–∞—Ü–∏—è —Ä–µ–∞–ª—å–Ω–æ–π –ø—Ä–æ–±–ª–µ–º—ã –ª–æ–≥–∏—Å—Ç–∏–∫–∏: " +
                "–æ–¥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä –≤—ã–∑—ã–≤–∞–µ—Ç —Ü–µ–ø–æ—á–∫—É –ø—Ä–æ–±–ª–µ–º, –ø—Ä–∏–≤–æ–¥—è—â—É—é " +
                "–∫ –¥–æ—Å—Ç–∞–≤–∫–µ —Ç–æ–ª—å–∫–æ 2 –∏–∑ 6 —Ç–æ–≤–∞—Ä–æ–≤ –∫–ª–∏–µ–Ω—Ç—É.");
        scenario.setStartTime(LocalDateTime.now());
        scenario.setRunning(true);

        // –®–∞–≥–∏ —Å—Ü–µ–Ω–∞—Ä–∏—è
        List<String> steps = new ArrayList<>();
        steps.add("1Ô∏è‚É£ –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞: –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –¥–µ—Ñ–∏—Ü–∏—Ç—ã —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("2Ô∏è‚É£ –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ –Ω–∞ 6 —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("3Ô∏è‚É£ –°–∏—Å—Ç–µ–º–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç '–≤—Å–µ —Ç–æ–≤–∞—Ä—ã –≤ –Ω–∞–ª–∏—á–∏–∏' (–ª–æ–∂—å!)");
        steps.add("4Ô∏è‚É£ –°–±–æ—Ä—â–∏–∫ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç –æ—Ç—Å—É—Ç—Å—Ç–≤–∏–µ –π–æ–≥—É—Ä—Ç–∞");
        steps.add("5Ô∏è‚É£ 15-–º–∏–Ω—É—Ç–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ: –æ—Ñ–∏—Å —Å–≤—è–∑—ã–≤–∞–µ—Ç—Å—è —Å –∫–ª–∏–µ–Ω—Ç–æ–º");
        steps.add("6Ô∏è‚É£ –ö–ê–¢–ê–°–¢–†–û–§–ê: –ó–∞ —ç—Ç–æ –≤—Ä–µ–º—è –¥—Ä—É–≥–∏–µ –∫–ª–∏–µ–Ω—Ç—ã –∑–∞–±–∏—Ä–∞—é—Ç —Ç–æ–≤–∞—Ä—ã");
        steps.add("7Ô∏è‚É£ –†–µ–∑—É–ª—å—Ç–∞—Ç: –ö–ª–∏–µ–Ω—Ç –ø–æ–ª—É—á–∞–µ—Ç —Ç–æ–ª—å–∫–æ 2 –∏–∑ 6 —Ç–æ–≤–∞—Ä–æ–≤");
        steps.add("8Ô∏è‚É£ –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏: 1,689 —Ä—É–± –∏–∑ 2,184 —Ä—É–±");
        scenario.setSteps(steps);

        // –°–∏–º—É–ª–∏—Ä—É–µ–º—ã–µ –æ—à–∏–±–∫–∏
        List<ErrorType> errors = Arrays.asList(
                ErrorType.PRODUCT_NOT_FOUND,
                ErrorType.LOW_STOCK,
                ErrorType.TRANSACTION_TIMEOUT
        );
        scenario.setSimulatedErrors(errors);

        // –¢–µ—Å—Ç–æ–≤—ã–µ –¥–∞–Ω–Ω—ã–µ
        Map<String, Object> testData = new HashMap<>();
        testData.put("orderId", "ORDER-" + System.currentTimeMillis());
        testData.put("clientId", "CLIENT-DEMO-001");
        testData.put("collectorId", "COLLECTOR-DEMO-001");
        testData.put("products", Arrays.asList("–ú–æ–ª–æ–∫–æ", "–•–ª–µ–±", "–ô–æ–≥—É—Ä—Ç", "–Ø–π—Ü–∞", "–°—ã—Ä", "–ú–∞—Å–ª–æ"));
        testData.put("quantities", Arrays.asList(2, 1, 4, 10, 5, 3));
        scenario.setTestData(testData);

        return scenario;
    }

    private void executeCascadeErrorsScenario(DemoScenarioDTO scenario) {
        try {
            logger.info("=== –ù–ê–ß–ê–õ–û –î–ï–ú–û: –ö–ê–°–ö–ê–î–ù–´–ï –û–®–ò–ë–ö–ò ===");

            // –®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–æ–≤–∫–∞ —Å–µ—Ä–≤–∏—Å–æ–≤
            scenario.getSteps().set(0, "‚úÖ " + scenario.getSteps().get(0));
            logger.info("–®–∞–≥ 1: –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º —Å–µ—Ä–≤–∏—Å—ã...");

            // –ó–∞–ø—É—Å–∫–∞–µ–º –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
            serviceOrchestrator.startService(ServiceType.SKLAD_SERVICE);           // ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
            serviceOrchestrator.startService(ServiceType.BACKET_SERVICE);          // ‚Üê —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω–æ
            serviceOrchestrator.startService(ServiceType.COLLECTOR_SERVICE);       // ‚Üê –ò–°–ü–†–ê–í–õ–ï–ù–û
            serviceOrchestrator.startService(ServiceType.OFFICE_SERVICE);

            Thread.sleep(5000);

            // –®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –¥–µ—Ñ–∏—Ü–∏—Ç—ã
            scenario.getSteps().set(1, "‚úÖ " + scenario.getSteps().get(1));
            logger.info("–®–∞–≥ 2: –°–æ–∑–¥–∞–µ–º —Å–∫—Ä—ã—Ç—ã–µ –¥–µ—Ñ–∏—Ü–∏—Ç—ã —Ç–æ–≤–∞—Ä–æ–≤...");
            logger.info("  - –ô–æ–≥—É—Ä—Ç: 0 —à—Ç (—è–≤–Ω—ã–π –¥–µ—Ñ–∏—Ü–∏—Ç)");
            logger.info("  - –Ø–π—Ü–∞: 1 –∏–∑ 10 (—Å–∫—Ä—ã—Ç—ã–π –¥–µ—Ñ–∏—Ü–∏—Ç)");
            logger.info("  - –°—ã—Ä: 2 –∏–∑ 5 (—Å–∫—Ä—ã—Ç—ã–π –¥–µ—Ñ–∏—Ü–∏—Ç)");

            Thread.sleep(3000);

            // –®–∞–≥ 3: –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑
            scenario.getSteps().set(2, "‚úÖ " + scenario.getSteps().get(2));
            logger.info("–®–∞–≥ 3: –ö–ª–∏–µ–Ω—Ç —Å–æ–∑–¥–∞–µ—Ç –∑–∞–∫–∞–∑ –Ω–∞ 6 —Ç–æ–≤–∞—Ä–æ–≤...");
            logger.info("  –°–∏—Å—Ç–µ–º–∞ –Ω–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç: '–í—Å–µ —Ç–æ–≤–∞—Ä—ã –≤ –Ω–∞–ª–∏—á–∏–∏'");

            Thread.sleep(3000);

            // –®–∞–≥ 4: –°–±–æ—Ä—â–∏–∫ –æ–±–Ω–∞—Ä—É–∂–∏–≤–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É
            scenario.getSteps().set(3, "‚úÖ " + scenario.getSteps().get(3));
            logger.info("–®–∞–≥ 4: –°–±–æ—Ä—â–∏–∫ –Ω–∞—á–∏–Ω–∞–µ—Ç —Å–±–æ—Ä–∫—É...");
            logger.info("  - –ú–æ–ª–æ–∫–æ ‚úì");
            logger.info("  - –•–ª–µ–± ‚úì");
            logger.info("  - –ô–æ–≥—É—Ä—Ç ‚ùå –ù–ï –ù–ê–ô–î–ï–ù!");

            // –°–∏–º—É–ª–∏—Ä—É–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –≤ –æ—Ñ–∏—Å
            logger.info("  üì® –£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ –æ—Ñ–∏—Å");

            Thread.sleep(3000);

            // –®–∞–≥ 5: –û–∂–∏–¥–∞–Ω–∏–µ –∏ –∑–≤–æ–Ω–æ–∫ –∫–ª–∏–µ–Ω—Ç—É
            scenario.getSteps().set(4, "‚úÖ " + scenario.getSteps().get(4));
            logger.info("–®–∞–≥ 5: 15-–º–∏–Ω—É—Ç–Ω–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ...");
            logger.info("  üìû –û—Ñ–∏—Å –∑–≤–æ–Ω–∏—Ç –∫–ª–∏–µ–Ω—Ç—É: '–ô–æ–≥—É—Ä—Ç–∞ –Ω–µ—Ç. –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å?'");
            logger.info("  üë§ –ö–ª–∏–µ–Ω—Ç: '–î–∞, –ø—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –±–µ–∑ –π–æ–≥—É—Ä—Ç–∞'");

            Thread.sleep(2000);

            // –®–∞–≥ 6: –ö–∞—Ç–∞—Å—Ç—Ä–æ—Ñ–∞ - –¥—Ä—É–≥–∏–µ –∫–ª–∏–µ–Ω—Ç—ã –∑–∞–±–∏—Ä–∞—é—Ç —Ç–æ–≤–∞—Ä—ã
            scenario.getSteps().set(5, "üî• " + scenario.getSteps().get(5));
            logger.info("–®–∞–≥ 6: –ö–ê–¢–ê–°–¢–†–û–§–ê –≤–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è!");
            logger.info("  –î—Ä—É–≥–∏–µ –∫–ª–∏–µ–Ω—Ç—ã –∑–∞–±—Ä–∞–ª–∏ —Ç–æ–≤–∞—Ä—ã:");
            logger.info("  - –Ø–π—Ü–∞: –±—ã–ª–æ 10, —Å—Ç–∞–ª–æ 3 (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç 7)");
            logger.info("  - –°—ã—Ä: –±—ã–ª–æ 5, —Å—Ç–∞–ª–æ 1 (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç 4)");
            logger.info("  - –ú–∞—Å–ª–æ: –±—ã–ª–æ 3, —Å—Ç–∞–ª–æ 1 (–Ω–µ —Ö–≤–∞—Ç–∞–µ—Ç 2)");

            Thread.sleep(3000);

            // –®–∞–≥ 7: –ü–ª–∞—á–µ–≤–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç
            scenario.getSteps().set(6, "üí• " + scenario.getSteps().get(6));
            logger.info("–®–∞–≥ 7: –ò–¢–û–ì–û–í–´–ô –†–ï–ó–£–õ–¨–¢–ê–¢:");
            logger.info("  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê");
            logger.info("  ‚îÇ  –û–ñ–ò–î–ê–õ–û–°–¨: 6 —Ç–æ–≤–∞—Ä–æ–≤      ‚îÇ");
            logger.info("  ‚îÇ  –ü–û–õ–£–ß–ï–ù–û: 2 —Ç–æ–≤–∞—Ä–∞        ‚îÇ");
            logger.info("  ‚îÇ  –£–°–ü–ï–®–ù–û–°–¢–¨: 33%           ‚îÇ");
            logger.info("  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò");
            logger.info("  –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ: —Ç–æ–ª—å–∫–æ –ú–æ–ª–æ–∫–æ –∏ –•–ª–µ–±");

            // –®–∞–≥ 8: –§–∏–Ω–∞–Ω—Å–æ–≤—ã–µ –ø–æ—Ç–µ—Ä–∏
            scenario.getSteps().set(7, "üí∞ " + scenario.getSteps().get(7));
            Map<String, Object> results = new HashMap<>();
            results.put("totalOrderValue", 2184.87);
            results.put("deliveredValue", 335.48);
            results.put("losses", 1849.39);
            results.put("lossPercentage", 84.6);
            results.put("timeLost", "45+ –º–∏–Ω—É—Ç");
            results.put("clientSatisfaction", "–†–ê–ó–ì–ù–ï–í–ê–ù");

            scenario.setResults(results);

            logger.info("–®–∞–≥ 8: –§–ò–ù–ê–ù–°–û–í–´–ï –ü–û–¢–ï–†–ò:");
            logger.info("  - –°—Ç–æ–∏–º–æ—Å—Ç—å –∑–∞–∫–∞–∑–∞: 2,184.87 —Ä—É–±");
            logger.info("  - –î–æ—Å—Ç–∞–≤–ª–µ–Ω–æ –Ω–∞: 335.48 —Ä—É–±");
            logger.info("  - –ü–û–¢–ï–†–ò: 1,849.39 —Ä—É–± (84.6%)");
            logger.info("  - –í—Ä–µ–º—è: 45+ –º–∏–Ω—É—Ç");
            logger.info("  - –ö–ª–∏–µ–Ω—Ç: –†–ê–ó–ì–ù–ï–í–ê–ù");

            // –ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å—Ü–µ–Ω–∞—Ä–∏—è
            scenario.setEndTime(LocalDateTime.now());
            scenario.setRunning(false);

            logger.info("=== –ó–ê–í–ï–†–®–ï–ù–ò–ï –î–ï–ú–û ===");
            logger.info("üìä –î–µ–º–æ —É—Å–ø–µ—à–Ω–æ –∑–∞–≤–µ—Ä—à–µ–Ω–æ –∑–∞ {} —Å–µ–∫—É–Ω–¥",
                    java.time.Duration.between(scenario.getStartTime(), scenario.getEndTime()).getSeconds());

        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
            logger.error("–î–µ–º–æ –ø—Ä–µ—Ä–≤–∞–Ω–æ: {}", e.getMessage());
            scenario.setRunning(false);
        }
    }

    /**
     * –î—Ä—É–≥–∏–µ –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏–∏
     */
    public DemoScenarioDTO runNormalProcessDemo() {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(DemoScenarioType.NORMAL_PROCESS);
        scenario.setTitle("–ù–æ—Ä–º–∞–ª—å–Ω—ã–π –ø—Ä–æ—Ü–µ—Å—Å –∑–∞–∫–∞–∑–∞");
        scenario.setDescription("–£—Å–ø–µ—à–Ω—ã–π –∑–∞–∫–∞–∑ –±–µ–∑ –æ—à–∏–±–æ–∫");
        // ... —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        return scenario;
    }

    public DemoScenarioDTO runSingleMissingItemDemo() {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(DemoScenarioType.SINGLE_MISSING_ITEM);
        scenario.setTitle("–û–¥–∏–Ω –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—â–∏–π —Ç–æ–≤–∞—Ä");
        scenario.setDescription("–ö–ª–∏–µ–Ω—Ç —Å–æ–≥–ª–∞—à–∞–µ—Ç—Å—è –Ω–∞ –∑–∞–∫–∞–∑ –±–µ–∑ –æ–¥–Ω–æ–≥–æ —Ç–æ–≤–∞—Ä–∞");
        // ... —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è
        return scenario;
    }

    public List<DemoScenarioDTO> getAllScenarios() {
        return Arrays.asList(
                createCascadeErrorsScenario(),
                createScenario(DemoScenarioType.NORMAL_PROCESS),
                createScenario(DemoScenarioType.SINGLE_MISSING_ITEM),
                createScenario(DemoScenarioType.CLIENT_DEMANDS_ALL),
                createScenario(DemoScenarioType.NIGHTMARE_SCENARIO)
        );
    }

    private DemoScenarioDTO createScenario(DemoScenarioType type) {
        DemoScenarioDTO scenario = new DemoScenarioDTO();
        scenario.setScenarioType(type);
        scenario.setTitle(type.getDescription());
        scenario.setRunning(false);
        return scenario;
    }

    public DemoScenarioDTO getActiveScenario(String scenarioType) {
        return activeScenarios.get(scenarioType);
    }
}package com.kefir.logistics.launcher_service.service;

import com.kefir.logistics.launcher_service.model.dto.LogEntryDTO;
import com.kefir.logistics.launcher_service.model.entity.ServiceLogEntity;
import org.springframework.stereotype.Service;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

@Service
public class LogStreamingService {

    private static final Pattern LOG_PATTERN = Pattern.compile(
            "(\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}\\.\\d{3}) (\\w+) (\\[.*?\\]) (\\[.*?\\]) (.*)"
    );

    private static final DateTimeFormatter LOG_DATE_FORMAT =
            DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss.SSS");

    public List<LogEntryDTO> getServiceLogs(String serviceName, int maxLines) {
        List<LogEntryDTO> logs = new ArrayList<>();
        File logFile = new File("./logs/" + serviceName + ".log");

        if (!logFile.exists()) {
            // –ï—Å–ª–∏ —Ñ–∞–π–ª–∞ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ–± —ç—Ç–æ–º
            LogEntryDTO entry = LogEntryDTO.builder()
                    .timestamp(LocalDateTime.now())
                    .level("WARN")
                    .serviceName(serviceName)
                    .message("Log file not found: " + logFile.getAbsolutePath())
                    .build();
            logs.add(entry);
            return logs;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            List<String> lines = new ArrayList<>();
            String line;

            // –ß–∏—Ç–∞–µ–º –≤—Å–µ —Å—Ç—Ä–æ–∫–∏
            while ((line = reader.readLine()) != null) {
                lines.add(line);
            }

            // –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ maxLines —Å—Ç—Ä–æ–∫
            int startIndex = Math.max(0, lines.size() - maxLines);
            for (int i = startIndex; i < lines.size(); i++) {
                LogEntryDTO logEntry = parseLogLine(lines.get(i), serviceName);
                if (logEntry != null) {
                    logs.add(logEntry);
                }
            }

        } catch (IOException e) {
            LogEntryDTO errorEntry = LogEntryDTO.builder()
                    .timestamp(LocalDateTime.now())
                    .level("ERROR")
                    .serviceName(serviceName)
                    .message("Error reading log file: " + e.getMessage())
                    .build();
            logs.add(errorEntry);
        }

        return logs;
    }

    public List<LogEntryDTO> searchLogs(String serviceName, String searchTerm,
                                        LocalDateTime from, LocalDateTime to) {
        List<LogEntryDTO> results = new ArrayList<>();
        File logFile = new File("./logs/" + serviceName + ".log");

        if (!logFile.exists()) {
            return results;
        }

        try (BufferedReader reader = new BufferedReader(new FileReader(logFile))) {
            String line;

            while ((line = reader.readLine()) != null) {
                LogEntryDTO logEntry = parseLogLine(line, serviceName);
                if (logEntry != null) {
                    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –≤—Ä–µ–º–µ–Ω–∏
                    boolean timeMatch = true;
                    if (from != null && logEntry.getTimestamp().isBefore(from)) {
                        timeMatch = false;
                    }
                    if (to != null && logEntry.getTimestamp().isAfter(to)) {
                        timeMatch = false;
                    }

                    // –§–∏–ª—å—Ç—Ä–∞—Ü–∏—è –ø–æ –ø–æ–∏—Å–∫–æ–≤–æ–º—É –∑–∞–ø—Ä–æ—Å—É
                    boolean textMatch = true;
                    if (searchTerm != null && !searchTerm.isEmpty()) {
                        textMatch = logEntry.getMessage().toLowerCase()
                                .contains(searchTerm.toLowerCase());
                    }

                    if (timeMatch && textMatch) {
                        results.add(logEntry);
                    }
                }
            }

        } catch (IOException e) {
            // –õ–æ–≥–∏—Ä—É–µ–º –æ—à–∏–±–∫—É, –Ω–æ –Ω–µ –ø–∞–¥–∞–µ–º
            System.err.println("Error searching logs: " + e.getMessage());
        }

        return results;
    }

    private LogEntryDTO parseLogLine(String logLine, String serviceName) {
        try {
            Matcher matcher = LOG_PATTERN.matcher(logLine);
            if (matcher.matches()) {
                LocalDateTime timestamp = LocalDateTime.parse(matcher.group(1), LOG_DATE_FORMAT);
                String level = matcher.group(2);
                String thread = matcher.group(3).replace("[", "").replace("]", "");
                String logger = matcher.group(4).replace("[", "").replace("]", "");
                String message = matcher.group(5);

                return LogEntryDTO.builder()
                        .timestamp(timestamp)
                        .level(level)
                        .serviceName(serviceName)
                        .thread(thread)
                        .logger(logger)
                        .message(message)
                        .build();
            }
        } catch (Exception e) {
            // –ï—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—Ä–æ—Å—Ç—É—é –∑–∞–ø–∏—Å—å
            return LogEntryDTO.builder()
                    .timestamp(LocalDateTime.now())
                    .level("INFO")
                    .serviceName(serviceName)
                    .message(logLine)
                    .build();
        }

        return null;
    }

    public ServiceLogEntity convertToEntity(LogEntryDTO dto) {
        ServiceLogEntity entity = new ServiceLogEntity();
        entity.setServiceId(dto.getServiceName());
        entity.setLogLevel(dto.getLevel());
        entity.setMessage(dto.getMessage());
        entity.setTimestamp(dto.getTimestamp());
        entity.setThreadName(dto.getThread());
        entity.setLoggerName(dto.getLogger());
        entity.setStackTrace(dto.getStackTrace());
        return entity;
    }

    public LogEntryDTO convertToDTO(ServiceLogEntity entity) {
        return LogEntryDTO.builder()
                .timestamp(entity.getTimestamp())
                .level(entity.getLogLevel())
                .serviceName(entity.getServiceId())
                .thread(entity.getThreadName())
                .logger(entity.getLoggerName())
                .message(entity.getMessage())
                .stackTrace(entity.getStackTrace())
                .build();
    }
}   package ru.kefir.service;

import org.springframework.stereotype.Service;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;

@Service
public class ProcessManagerService {

    private final Map<Integer, Process> runningProcesses = new HashMap<>();
    private final Map<Integer, Integer> portToPidMap = new HashMap<>();

    public Process startService(String command, int port) throws IOException {
        Process process = Runtime.getRuntime().exec(command);
        runningProcesses.put(port, process);

        // –°–æ—Ö—Ä–∞–Ω—è–µ–º PID (–Ω—É–∂–Ω–æ –¥–ª—è Windows)
        try {
            // –ü–æ–ª—É—á–∞–µ–º PID –ø—Ä–æ—Ü–µ—Å—Å–∞
            long pid = process.pid();
            portToPidMap.put(port, (int) pid);
        } catch (UnsupportedOperationException e) {
            // –ù–∞ –Ω–µ–∫–æ—Ç–æ—Ä—ã—Ö —Å–∏—Å—Ç–µ–º–∞—Ö pid() –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è
            portToPidMap.put(port, -1);
        }

        return process;
    }

    public boolean stopService(int port) {
        Process process = runningProcesses.get(port);
        if (process != null) {
            process.destroy();
            try {
                if (process.isAlive()) {
                    process.destroyForcibly();
                }
            } catch (Exception e) {
                // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º
            }
            runningProcesses.remove(port);
            portToPidMap.remove(port);
            return true;
        }
        return false;
    }

    public void stopAllServices() {
        for (Integer port : runningProcesses.keySet()) {
            stopService(port);
        }
        runningProcesses.clear();
        portToPidMap.clear();
    }

    public Map<Integer, Process> getRunningProcesses() {
        return new HashMap<>(runningProcesses);
    }
}package com.kefir.logistics.launcher_service.service;


import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.model.enums.ServiceState;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;

import java.io.IOException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.ConcurrentHashMap;

@Service
public class ServiceMonitor {

    private static final Logger logger = LoggerFactory.getLogger(ServiceMonitor.class);

    @Autowired
    private ServiceOrchestrator serviceOrchestrator;

    private final Map<ServiceType, ServiceHealthInfo> healthCache = new ConcurrentHashMap<>();

    @PostConstruct
    public void init() {
        logger.info("Service Monitor initialized");

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∫—ç—à –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
        for (ServiceType serviceType : ServiceType.values()) {
            healthCache.put(serviceType, new ServiceHealthInfo());
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤ –∫–∞–∂–¥—ã–µ 30 —Å–µ–∫—É–Ω–¥
     */
    @Scheduled(fixedDelay = 30000)
    public void checkAllServicesHealth() {
        logger.debug("Running scheduled health check for all services");

        for (ServiceType serviceType : ServiceType.values()) {
            ServiceHealthInfo healthInfo = checkServiceHealth(serviceType);
            healthCache.put(serviceType, healthInfo);

            // –ï—Å–ª–∏ —Å–µ—Ä–≤–∏—Å –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç
            ServiceStatusDTO status = serviceOrchestrator.getServiceStatus(serviceType);
            if (status != null && status.getState().isRunning() && !healthInfo.isHealthy()) {
                logger.warn("Service {} is running but not responding (HTTP: {})",
                        serviceType.getDisplayName(), healthInfo.getLastHttpStatus());

                // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π restart:
                // if (healthInfo.getConsecutiveFailures() > 3) {
                //     logger.info("Auto-restarting service {} due to health failures",
                //         serviceType.getDisplayName());
                //     serviceOrchestrator.restartService(serviceType);
                // }
            }
        }
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ —Å–µ—Ä–≤–∏—Å–∞
     */
    public ServiceHealthInfo checkServiceHealth(ServiceType serviceType) {
        ServiceHealthInfo healthInfo = healthCache.getOrDefault(serviceType, new ServiceHealthInfo());
        healthInfo.setLastCheckTime(LocalDateTime.now());

        try {
            // –ü—Ä–æ–±—É–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
            List<String> endpoints = Arrays.asList(
                    String.format("http://localhost:%d/actuator/health", serviceType.getPort()),
                    String.format("http://localhost:%d/actuator/info", serviceType.getPort()),
                    String.format("http://localhost:%d", serviceType.getPort())
            );

            boolean isHealthy = false;
            String response = null;
            int httpStatus = 0;

            for (String endpoint : endpoints) {
                try {
                    URL url = new URL(endpoint);
                    HttpURLConnection connection = (HttpURLConnection) url.openConnection();
                    connection.setRequestMethod("GET");
                    connection.setConnectTimeout(5000);
                    connection.setReadTimeout(5000);

                    httpStatus = connection.getResponseCode();

                    if (httpStatus >= 200 && httpStatus < 300) {
                        isHealthy = true;
                        response = "HTTP " + httpStatus;
                        break;
                    }

                    connection.disconnect();

                } catch (IOException e) {
                    // –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π endpoint
                    continue;
                }
            }

            healthInfo.setHealthy(isHealthy);
            healthInfo.setLastHttpStatus(httpStatus);
            healthInfo.setLastResponse(response);

            if (isHealthy) {
                healthInfo.setConsecutiveFailures(0);
                healthInfo.setLastSuccessTime(LocalDateTime.now());
                logger.debug("Service {} is healthy (HTTP: {})",
                        serviceType.getDisplayName(), httpStatus);
            } else {
                healthInfo.incrementFailures();
                logger.warn("Service {} is unhealthy (HTTP: {})",
                        serviceType.getDisplayName(), httpStatus);
            }

        } catch (Exception e) {
            logger.error("Error checking health for {}: {}",
                    serviceType.getDisplayName(), e.getMessage());
            healthInfo.setHealthy(false);
            healthInfo.setLastResponse("Error: " + e.getMessage());
            healthInfo.incrementFailures();
        }

        return healthInfo;
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –∑–¥–æ—Ä–æ–≤—å—è –¥–ª—è –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
     */
    public Map<ServiceType, ServiceHealthInfo> getAllServicesHealth() {
        Map<ServiceType, ServiceHealthInfo> result = new HashMap<>();

        for (ServiceType serviceType : ServiceType.values()) {
            ServiceHealthInfo healthInfo = healthCache.get(serviceType);
            if (healthInfo == null ||
                    healthInfo.getLastCheckTime() == null ||
                    healthInfo.getLastCheckTime().isBefore(LocalDateTime.now().minusMinutes(1))) {

                // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã–µ —É—Å—Ç–∞—Ä–µ–ª–∏, –æ–±–Ω–æ–≤–ª—è–µ–º
                healthInfo = checkServiceHealth(serviceType);
            }
            result.put(serviceType, healthInfo);
        }

        return result;
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç –∞–≥—Ä–µ–≥–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
     */
    public Map<String, Object> getHealthSummary() {
        Map<ServiceType, ServiceHealthInfo> healthData = getAllServicesHealth();

        int totalServices = ServiceType.values().length;
        int healthyServices = 0;
        int unhealthyServices = 0;
        int unknownServices = 0;

        List<Map<String, Object>> detailedStatus = new ArrayList<>();

        for (Map.Entry<ServiceType, ServiceHealthInfo> entry : healthData.entrySet()) {
            ServiceHealthInfo healthInfo = entry.getValue();

            if (healthInfo.isHealthy()) {
                healthyServices++;
            } else if (healthInfo.getConsecutiveFailures() > 0) {
                unhealthyServices++;
            } else {
                unknownServices++;
            }

            Map<String, Object> serviceStatus = new HashMap<>();
            serviceStatus.put("service", entry.getKey().getDisplayName());
            serviceStatus.put("healthy", healthInfo.isHealthy());
            serviceStatus.put("lastCheck", healthInfo.getLastCheckTime());
            serviceStatus.put("responseTime", healthInfo.getResponseTime());
            serviceStatus.put("consecutiveFailures", healthInfo.getConsecutiveFailures());

            detailedStatus.add(serviceStatus);
        }

        Map<String, Object> summary = new HashMap<>();
        summary.put("timestamp", LocalDateTime.now());
        summary.put("totalServices", totalServices);
        summary.put("healthyServices", healthyServices);
        summary.put("unhealthyServices", unhealthyServices);
        summary.put("unknownServices", unknownServices);
        summary.put("healthPercentage", totalServices > 0 ?
                (healthyServices * 100.0 / totalServices) : 0);
        summary.put("detailedStatus", detailedStatus);

        return summary;
    }

    /**
     * –í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π –∫–ª–∞—Å—Å –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ –∑–¥–æ—Ä–æ–≤—å–µ —Å–µ—Ä–≤–∏—Å–∞
     */
    public static class ServiceHealthInfo {
        private boolean healthy = false;
        private LocalDateTime lastCheckTime;
        private LocalDateTime lastSuccessTime;
        private int consecutiveFailures = 0;
        private int lastHttpStatus = 0;
        private String lastResponse;
        private long responseTime; // –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö

        // –ì–µ—Ç—Ç–µ—Ä—ã –∏ —Å–µ—Ç—Ç–µ—Ä—ã
        public boolean isHealthy() { return healthy; }
        public void setHealthy(boolean healthy) { this.healthy = healthy; }

        public LocalDateTime getLastCheckTime() { return lastCheckTime; }
        public void setLastCheckTime(LocalDateTime lastCheckTime) { this.lastCheckTime = lastCheckTime; }

        public LocalDateTime getLastSuccessTime() { return lastSuccessTime; }
        public void setLastSuccessTime(LocalDateTime lastSuccessTime) { this.lastSuccessTime = lastSuccessTime; }

        public int getConsecutiveFailures() { return consecutiveFailures; }
        public void setConsecutiveFailures(int consecutiveFailures) { this.consecutiveFailures = consecutiveFailures; }
        public void incrementFailures() { this.consecutiveFailures++; }

        public int getLastHttpStatus() { return lastHttpStatus; }
        public void setLastHttpStatus(int lastHttpStatus) { this.lastHttpStatus = lastHttpStatus; }

        public String getLastResponse() { return lastResponse; }
        public void setLastResponse(String lastResponse) { this.lastResponse = lastResponse; }

        public long getResponseTime() { return responseTime; }
        public void setResponseTime(long responseTime) { this.responseTime = responseTime; }
    }
}package com.kefir.logistics.launcher_service.service;

import com.kefir.logistics.launcher_service.model.dto.ServiceStatusDTO;
import com.kefir.logistics.launcher_service.model.enums.ServiceState;
import com.kefir.logistics.launcher_service.model.enums.ServiceType;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.net.InetSocketAddress;
import java.net.Socket;
import java.time.LocalDateTime;
import java.util.*;
import java.util.concurrent.*;

@Service
public class ServiceOrchestrator {
    private static final Logger logger = LoggerFactory.getLogger(ServiceOrchestrator.class);

    @Autowired
    private com.kefir.logistics.launcher_service.config.ApplicationProperties appProperties;

    @Value("${app.autoStart:false}")
    private boolean autoStartEnabled;

    @Value("${app.startup.delay.ms:3000}")
    private int startupDelayMs;

    private final Map<ServiceType, Process> runningProcesses = new ConcurrentHashMap<>();
    private final Map<ServiceType, ServiceStatusDTO> serviceStatuses = new ConcurrentHashMap<>();
    private final ExecutorService executorService = Executors.newCachedThreadPool();
    private final RestTemplate restTemplate = new RestTemplate();

    @PostConstruct
    public void init() {
        logger.info("=== SERVICE ORCHESTRATOR INITIALIZATION ===");
        initializeServiceStatuses();

        // –ê–≤—Ç–æ—Å—Ç–∞—Ä—Ç —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —è–≤–Ω–æ –≤–∫–ª—é—á–µ–Ω –≤ –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏
        if (autoStartEnabled) {
            new Thread(() -> {
                try {
                    Thread.sleep(startupDelayMs);
                    logger.info("=== AUTO-STARTING ALL SERVICES (config: app.autoStart=true) ===");
                    startAllServices();
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }).start();
        } else {
            logger.info("–ê–≤—Ç–æ—Å—Ç–∞—Ä—Ç –æ—Ç–∫–ª—é—á–µ–Ω (app.autoStart=false). –°–µ—Ä–≤–∏—Å—ã –±—É–¥—É—Ç –∑–∞–ø—É—Å–∫–∞—Ç—å—Å—è –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—é.");
        }
    }

    private void initializeServiceStatuses() {
        for (ServiceType type : ServiceType.values()) {
            int port = getServicePort(type);
            ServiceStatusDTO status = ServiceStatusDTO.builder()
                    .serviceType(type)
                    .state(ServiceState.STOPPED)
                    .healthUrl("http://localhost:" + port + "/actuator/health")
                    .logPath("./logs/" + type.getId() + ".log")
                    .lastChecked(LocalDateTime.now())
                    .build();

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç —Å–µ—Ä–≤–∏—Å —É–∂–µ –∑–∞–ø—É—â–µ–Ω
            if (isPortOpen(port)) {
                status.setState(ServiceState.RUNNING);
                status.setLastChecked(LocalDateTime.now());
                logger.info("–°–µ—Ä–≤–∏—Å {} (–ø–æ—Ä—Ç {}) —É–∂–µ –∑–∞–ø—É—â–µ–Ω", type.getDisplayName(), port);
            }

            serviceStatuses.put(type, status);
        }
        logger.info("–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–æ {} —Å—Ç–∞—Ç—É—Å–æ–≤ —Å–µ—Ä–≤–∏—Å–æ–≤", ServiceType.values().length);
    }

    // ============ –ü–£–ë–õ–ò–ß–ù–´–ï –ú–ï–¢–û–î–´ –î–õ–Ø –ü–†–û–í–ï–†–ö–ò –°–¢–ê–¢–£–°–û–í ============

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø—É—â–µ–Ω—ã –ª–∏ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
     */
    public boolean areAllServicesRunning() {
        return serviceStatuses.values().stream()
                .allMatch(status -> status.getState() != null && status.getState().isRunning());
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç, –∑–∞–ø—É—â–µ–Ω –ª–∏ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π —Å–µ—Ä–≤–∏—Å
     */
    public boolean isServiceRunning(ServiceType serviceType) {
        ServiceStatusDTO status = serviceStatuses.get(serviceType);
        return status != null && status.getState() != null && status.getState().isRunning();
    }

    /**
     * –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∑–¥–æ—Ä–æ–≤—å–µ —Å–µ—Ä–≤–∏—Å–∞ (HTTP –ø—Ä–æ–≤–µ—Ä–∫–∞)
     */
    public boolean isServiceHealthy(ServiceType serviceType) {
        try {
            ServiceStatusDTO status = serviceStatuses.get(serviceType);
            if (status == null || status.getState() == null || !status.getState().isRunning()) {
                logger.debug("–°–µ—Ä–≤–∏—Å {} –Ω–µ –∑–∞–ø—É—â–µ–Ω –∏–ª–∏ —Å—Ç–∞—Ç—É—Å –Ω–µ–∏–∑–≤–µ—Å—Ç–µ–Ω", serviceType.getDisplayName());
                return false;
            }

            int port = getServicePort(serviceType);

            // 1. –°–Ω–∞—á–∞–ª–∞ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –æ—Ç–∫—Ä—ã—Ç –ª–∏ –ø–æ—Ä—Ç (–±–∞–∑–æ–≤–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞)
            if (!isPortOpen(port)) {
                logger.warn("–ü–æ—Ä—Ç {} (—Å–µ—Ä–≤–∏—Å {}) –Ω–µ –æ—Ç–∫—Ä—ã—Ç", port, serviceType.getDisplayName());
                return false;
            }

            // 2. –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã—Ö —ç–Ω–¥–ø–æ–∏–Ω—Ç–æ–≤
            String[] endpoints = {
                    "http://localhost:" + port + "/actuator/health",
                    "http://localhost:" + port + "/actuator/info",
                    "http://localhost:" + port + "/health",
                    "http://localhost:" + port + "/info",
                    "http://localhost:" + port + "/api/health",
                    "http://localhost:" + port + "/api/info",
                    "http://localhost:" + port + "/",  // –∫–æ—Ä–Ω–µ–≤–æ–π —ç–Ω–¥–ø–æ–∏–Ω—Ç
                    "http://localhost:" + port + "/api/ping"
            };

            for (String endpoint : endpoints) {
                try {
                    logger.debug("–ü—Ä–æ–≤–µ—Ä–∫–∞ —ç–Ω–¥–ø–æ–∏–Ω—Ç–∞: {}", endpoint);
                    ResponseEntity<String> response = restTemplate.getForEntity(endpoint, String.class);

                    if (response.getStatusCode().is2xxSuccessful()) {
                        logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} –æ—Ç–≤–µ—á–∞–µ—Ç –Ω–∞ {}", serviceType.getDisplayName(), endpoint);
                        return true;
                    } else {
                        logger.debug("–°–µ—Ä–≤–∏—Å {} –æ—Ç–≤–µ—Ç–∏–ª –∫–æ–¥–æ–º {} –Ω–∞ {}",
                                serviceType.getDisplayName(), response.getStatusCode(), endpoint);
                        // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –ø—Ä–æ–±–æ–≤–∞—Ç—å –¥—Ä—É–≥–∏–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã
                    }
                } catch (Exception e) {
                    // –ò–≥–Ω–æ—Ä–∏—Ä—É–µ–º –∏ –ø—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â–∏–π —ç–Ω–¥–ø–æ–∏–Ω—Ç
                    logger.trace("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è –∫ {}: {}", endpoint, e.getMessage());
                }
            }

            // 3. –ï—Å–ª–∏ –≤—Å–µ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª–∏, –Ω–æ –ø–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç - —Å—á–∏—Ç–∞–µ–º –∑–¥–æ—Ä–æ–≤—ã–º
            logger.warn("–°–µ—Ä–≤–∏—Å {} –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {}, –Ω–æ —ç–Ω–¥–ø–æ–∏–Ω—Ç—ã –Ω–µ –æ—Ç–≤–µ—á–∞—é—Ç",
                    serviceType.getDisplayName(), port);
            return true; // –í–æ–∑–≤—Ä–∞—â–∞–µ–º true, –µ—Å–ª–∏ –ø–æ—Ä—Ç –æ—Ç–∫—Ä—ã—Ç (—Å–µ—Ä–≤–∏—Å —Ä–∞–±–æ—Ç–∞–µ—Ç, –Ω–æ –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω)

        } catch (Exception e) {
            logger.warn("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ –∑–¥–æ—Ä–æ–≤—å—è —Å–µ—Ä–≤–∏—Å–∞ {}: {}",
                    serviceType.getDisplayName(), e.getMessage());
            return false;
        }
    }

    /**
     * –ü–æ–ª—É—á–∞–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–µ—Ä–≤–∏—Å–æ–≤, —Ç—Ä–µ–±—É—é—â–∏—Ö –∑–∞–ø—É—Å–∫–∞
     */
    public List<ServiceType> getServicesRequiringStartup(List<ServiceType> requiredServices) {
        List<ServiceType> servicesToStart = new ArrayList<>();

        for (ServiceType service : requiredServices) {
            if (!isServiceRunning(service) || !isServiceHealthy(service)) {
                servicesToStart.add(service);
                logger.info("–°–µ—Ä–≤–∏—Å {} —Ç—Ä–µ–±—É–µ—Ç –∑–∞–ø—É—Å–∫–∞ (running: {}, healthy: {})",
                        service.getDisplayName(),
                        isServiceRunning(service),
                        isServiceHealthy(service));
            }
        }

        return servicesToStart;
    }

    // ============ –û–ü–¢–ò–ú–ò–ó–ò–†–û–í–ê–ù–ù–´–ô –ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–û–í ============

    /**
     * –ó–∞–ø—É—Å–∫–∞–µ—Ç —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
     */
    public List<ServiceStatusDTO> startRequiredServices(List<ServiceType> servicesToStart) {
        logger.info("üöÄ –ó–∞–ø—É—Å–∫ {} –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã—Ö —Å–µ—Ä–≤–∏—Å–æ–≤...", servicesToStart.size());
        List<ServiceStatusDTO> results = new ArrayList<>();

        for (ServiceType serviceType : servicesToStart) {
            try {
                logger.info("‚è≥ –ó–∞–ø—É—Å–∫ {}...", serviceType.getDisplayName());
                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                // –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –ø–∞—É–∑–∞: 2 —Å–µ–∫—É–Ω–¥—ã –º–µ–∂–¥—É –∑–∞–ø—É—Å–∫–∞–º–∏
                if (servicesToStart.size() > 1) {
                    Thread.sleep(2000);
                }

            } catch (Exception e) {
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å {}: {}", serviceType.getDisplayName(), e.getMessage());
                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .build();
                results.add(errorStatus);
            }
        }

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        long successful = results.stream()
                .filter(s -> s.getState() != null && s.getState().isRunning())
                .count();

        logger.info("üìä –ó–∞–ø—É—Å–∫ –∑–∞–≤–µ—Ä—à–µ–Ω: {}/{} —É—Å–ø–µ—à–Ω–æ", successful, results.size());
        return results;
    }

    /**
     * –ò–Ω—Ç–µ–ª–ª–µ–∫—Ç—É–∞–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ-—Å—Ü–µ–Ω–∞—Ä–∏—è
     */
    public List<ServiceStatusDTO> startServicesForDemo(List<ServiceType> demoRequiredServices) {
        logger.info("üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ...");

        // 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º, –∫–∞–∫–∏–µ —Å–µ—Ä–≤–∏—Å—ã —É–∂–µ –∑–∞–ø—É—â–µ–Ω—ã –∏ –∑–¥–æ—Ä–æ–≤—ã
        List<ServiceType> servicesToStart = getServicesRequiringStartup(demoRequiredServices);

        if (servicesToStart.isEmpty()) {
            logger.info("‚úÖ –í—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã —É–∂–µ –∑–∞–ø—É—â–µ–Ω—ã –∏ –∑–¥–æ—Ä–æ–≤—ã");
            return Collections.emptyList();
        }

        logger.info("üöÄ –¢—Ä–µ–±—É–µ—Ç—Å—è –∑–∞–ø—É—Å–∫ {} —Å–µ—Ä–≤–∏—Å–æ–≤: {}",
                servicesToStart.size(),
                servicesToStart.stream().map(ServiceType::getDisplayName).toList());

        // 2. –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ —Å–µ—Ä–≤–∏—Å—ã
        return startRequiredServices(servicesToStart);
    }

    /**
     * –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ (–±–µ–∑ –ø—Ä–æ–≤–µ—Ä–∫–∏ –∑–¥–æ—Ä–æ–≤—å—è)
     */
    public List<ServiceStatusDTO> forceStartServicesForDemo(List<ServiceType> demoRequiredServices) {
        logger.info("‚ö° –ü–†–ò–ù–£–î–ò–¢–ï–õ–¨–ù–´–ô –∑–∞–ø—É—Å–∫ —Å–µ—Ä–≤–∏—Å–æ–≤ –¥–ª—è –¥–µ–º–æ...");
        List<ServiceStatusDTO> results = new ArrayList<>();

        for (ServiceType serviceType : demoRequiredServices) {
            try {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
                if (isServiceRunning(serviceType)) {
                    logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} —É–∂–µ –∑–∞–ø—É—â–µ–Ω, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º", serviceType.getDisplayName());
                    results.add(serviceStatuses.get(serviceType));
                    continue;
                }

                logger.info("‚ö° –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω—ã–π –∑–∞–ø—É—Å–∫ {}...", serviceType.getDisplayName());
                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                // –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∑–∞–ø—É—Å–∫
                Thread.sleep(3000);

            } catch (Exception e) {
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –∑–∞–ø—É—Å—Ç–∏—Ç—å {}: {}",
                        serviceType.getDisplayName(), e.getMessage());
                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .build();
                results.add(errorStatus);
            }
        }

        // –î–∞–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é –≤—Å–µ—Ö —Å–µ—Ä–≤–∏—Å–æ–≤
        try {
            logger.info("‚è≥ –î–∞–µ–º –≤—Ä–µ–º—è –Ω–∞ –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—é —Å–µ—Ä–≤–∏—Å–æ–≤ (10 —Å–µ–∫—É–Ω–¥)...");
            Thread.sleep(10000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        return results;
    }

    public ServiceStatusDTO startService(ServiceType serviceType) {
        String displayName = getServiceDisplayName(serviceType);
        logger.info("üöÄ –ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–ê: {}", displayName);

        try {
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω –ª–∏ —É–∂–µ —Å–µ—Ä–≤–∏—Å
            if (isServiceRunning(serviceType)) {
                logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} —É–∂–µ –∑–∞–ø—É—â–µ–Ω", displayName);

                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∑–¥–æ—Ä–æ–≤—å–µ
                if (isServiceHealthy(serviceType)) {
                    logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} –∑–¥–æ—Ä–æ–≤, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø—É—Å–∫", displayName);
                    return serviceStatuses.get(serviceType);
                } else {
                    logger.warn("‚ö†Ô∏è –°–µ—Ä–≤–∏—Å {} –∑–∞–ø—É—â–µ–Ω, –Ω–æ –Ω–µ –∑–¥–æ—Ä–æ–≤. –ü–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º...", displayName);
                    stopService(serviceType);
                    Thread.sleep(1000);
                }
            }

            updateServiceStatus(serviceType, ServiceState.STARTING, null);

            String directory = getServiceDirectory(serviceType);
            int port = getServicePort(serviceType);

            logger.info("üìÅ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è: {}", directory);
            logger.info("üîå –ü–æ—Ä—Ç: {}", port);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
            File serviceDir = new File(directory);
            if (!serviceDir.exists()) {
                String errorMsg = "‚ùå –î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞: " + directory;
                logger.error(errorMsg);
                updateServiceStatus(serviceType, ServiceState.FAILED, null, errorMsg);
                return serviceStatuses.get(serviceType);
            }

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–Ω—è—Ç –ª–∏ –ø–æ—Ä—Ç –¥—Ä—É–≥–∏–º –ø—Ä–æ—Ü–µ—Å—Å–æ–º
            if (isPortOpen(port)) {
                logger.warn("‚ö†Ô∏è –ü–æ—Ä—Ç {} –∑–∞–Ω—è—Ç. –ü—ã—Ç–∞–µ–º—Å—è –æ—Å–≤–æ–±–æ–¥–∏—Ç—å...", port);
                if (!releasePortIfNeeded(port, displayName)) {
                    String errorMsg = "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç " + port;
                    updateServiceStatus(serviceType, ServiceState.FAILED, null, errorMsg);
                    return serviceStatuses.get(serviceType);
                }
                Thread.sleep(1000);
            }

            // –°–æ–±–∏—Ä–∞–µ–º –∫–æ–º–∞–Ω–¥—É –¥–ª—è Windows
            List<String> command = new ArrayList<>();
            command.add("cmd");
            command.add("/c");
            command.add("cd");
            command.add("/d");
            command.add(directory);
            command.add("&&");
            command.add("echo");
            command.add("=== Starting " + displayName + " on port " + port + " ===");
            command.add("&&");
            command.add("mvn");
            command.add("spring-boot:run");
            command.add("-Dserver.port=" + port);
            command.add("-DskipTests");

            logger.debug("üíª –ö–æ–º–∞–Ω–¥–∞: {}", String.join(" ", command));

            // –ó–∞–ø—É—Å–∫–∞–µ–º –ø—Ä–æ—Ü–µ—Å—Å
            ProcessBuilder processBuilder = new ProcessBuilder(command);
            processBuilder.directory(serviceDir);
            processBuilder.redirectErrorStream(true);

            Process process = processBuilder.start();
            runningProcesses.put(serviceType, process);

            // –ß–∏—Ç–∞–µ–º –≤—ã–≤–æ–¥ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
            startOutputReader(serviceType, process);

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ø–µ—à–Ω–æ—Å—Ç—å –∑–∞–ø—É—Å–∫–∞ —á–µ—Ä–µ–∑ 15 —Å–µ–∫—É–Ω–¥ (—É–≤–µ–ª–∏—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è)
            executorService.submit(() -> {
                try {
                    Thread.sleep(15000); // –£–≤–µ–ª–∏—á–µ–Ω–Ω–æ–µ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è

                    if (process.isAlive()) {
                        if (isPortOpen(port)) {
                            updateServiceStatus(serviceType, ServiceState.RUNNING, process.pid());
                            logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω –Ω–∞ –ø–æ—Ä—Ç—É {}", displayName, port);
                            startHealthMonitoring(serviceType);
                        } else {
                            // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞
                            logger.warn("–ü–æ—Ä—Ç {} –Ω–µ –æ—Ç–∫—Ä—ã—Ç, –ø—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ—Ü–µ—Å—Å...", port);
                            try {
                                String pid = String.valueOf(process.pid());
                                logger.info("–ü—Ä–æ—Ü–µ—Å—Å {} –∂–∏–≤: {}, exitCode: {}",
                                        pid, process.isAlive(),
                                        process.isAlive() ? "N/A" : process.exitValue());
                            } catch (Exception ex) {
                                logger.warn("–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ –ø—Ä–æ—Ü–µ—Å—Å–µ: {}", ex.getMessage());
                            }

                            updateServiceStatus(serviceType, ServiceState.FAILED, null,
                                    "–ü–æ—Ä—Ç " + port + " –Ω–µ –æ—Ç–≤–µ—á–∞–µ—Ç —á–µ—Ä–µ–∑ 15 —Å–µ–∫—É–Ω–¥");
                            logger.error("‚ùå –°–µ—Ä–≤–∏—Å {} –∑–∞–ø—É—â–µ–Ω, –Ω–æ –ø–æ—Ä—Ç {} –Ω–µ –æ—Ç–∫—Ä—ã—Ç", displayName, port);
                        }
                    } else {
                        updateServiceStatus(serviceType, ServiceState.FAILED, null,
                                "–ü—Ä–æ—Ü–µ—Å—Å –Ω–µ–æ–∂–∏–¥–∞–Ω–Ω–æ –∑–∞–≤–µ—Ä—à–∏–ª—Å—è");
                        logger.error("‚ùå –ü—Ä–æ—Ü–µ—Å—Å —Å–µ—Ä–≤–∏—Å–∞ {} –∑–∞–≤–µ—Ä—à–∏–ª—Å—è", displayName);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            });

            return serviceStatuses.get(serviceType);

        } catch (Exception e) {
            logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å —Å–µ—Ä–≤–∏—Å {}: {}", displayName, e.getMessage(), e);
            updateServiceStatus(serviceType, ServiceState.FAILED, null, e.getMessage());
            return serviceStatuses.get(serviceType);
        }
    }

    // ============ –ú–ï–¢–û–î–´ –î–õ–Ø –£–ü–†–ê–í–õ–ï–ù–ò–Ø –í–°–ï–ú–ò –°–ï–†–í–ò–°–ê–ú–ò ============

    /**
     * –ó–∞–ø—É—Å–∫–∞–µ—Ç –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã –≤ –æ–ø—Ç–∏–º–∞–ª—å–Ω–æ–º –ø–æ—Ä—è–¥–∫–µ
     */
    public List<ServiceStatusDTO> startAllServices() {
        logger.info("üöÄüöÄüöÄ –ó–ê–ü–£–°–ö –í–°–ï–• –°–ï–†–í–ò–°–û–í KEFIR üöÄüöÄüöÄ");

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–ø—É—â–µ–Ω—ã –ª–∏ —É–∂–µ –≤—Å–µ —Å–µ—Ä–≤–∏—Å—ã
        if (areAllServicesRunning()) {
            logger.info("‚úÖ –í—Å–µ —Å–µ—Ä–≤–∏—Å—ã —É–∂–µ –∑–∞–ø—É—â–µ–Ω—ã, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º –∑–∞–ø—É—Å–∫");
            return new ArrayList<>(serviceStatuses.values());
        }

        // –û–ø—Ç–∏–º–∞–ª—å–Ω—ã–π –ø–æ—Ä—è–¥–æ–∫ –∑–∞–ø—É—Å–∫–∞
        ServiceType[] startupOrder = {
                ServiceType.AUTH_SERVICE,      // 1. Auth (–±–∞–∑–æ–≤—ã–π —Å–µ—Ä–≤–∏—Å)
                ServiceType.USER_SERVICE,      // 2. User
                ServiceType.SKLAD_SERVICE,     // 3. Warehouse
                ServiceType.BACKET_SERVICE,    // 4. Cart
                ServiceType.OFFICE_SERVICE,    // 5. Office
                ServiceType.COLLECTOR_SERVICE, // 6. Collector
                ServiceType.DELIVERY_SERVICE,  // 7. Delivery
                ServiceType.SAGA_SERVICE,      // 8. Saga
                ServiceType.API_GATEWAY        // 9. Gateway (–ø–æ—Å–ª–µ–¥–Ω–∏–π)
        };

        List<ServiceStatusDTO> results = new ArrayList<>();

        for (ServiceType serviceType : startupOrder) {
            try {
                // –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —É–∂–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ –∏ –∑–¥–æ—Ä–æ–≤—ã–µ —Å–µ—Ä–≤–∏—Å—ã
                if (isServiceRunning(serviceType) && isServiceHealthy(serviceType)) {
                    logger.info("‚úÖ {} —É–∂–µ –∑–∞–ø—É—â–µ–Ω –∏ –∑–¥–æ—Ä–æ–≤, –ø—Ä–æ–ø—É—Å–∫–∞–µ–º",
                            serviceType.getDisplayName());
                    results.add(serviceStatuses.get(serviceType));
                    continue;
                }

                logger.info("‚è≥ –ó–∞–ø—É—Å–∫ {}...", serviceType.getDisplayName());
                ServiceStatusDTO result = startService(serviceType);
                results.add(result);

                // –ü–∞—É–∑–∞ 3 —Å–µ–∫—É–Ω–¥—ã –º–µ–∂–¥—É –∑–∞–ø—É—Å–∫–∞–º–∏
                Thread.sleep(3000);

            } catch (Exception e) {
                logger.error("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å {}: {}", serviceType.getDisplayName(), e.getMessage());
                ServiceStatusDTO errorStatus = ServiceStatusDTO.builder()
                        .serviceType(serviceType)
                        .state(ServiceState.FAILED)
                        .errorMessage(e.getMessage())
                        .build();
                results.add(errorStatus);
            }
        }

        // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        long successful = results.stream()
                .filter(s -> s.getState() != null && s.getState().isRunning())
                .count();

        logger.info("=========================================");
        logger.info("üöÄ –ó–ê–ü–£–°–ö –ó–ê–í–ï–†–®–ï–ù");
        logger.info("‚úÖ –£—Å–ø–µ—à–Ω–æ: {}", successful);
        logger.info("‚ùå –ù–µ—É–¥–∞—á–Ω–æ: {}", results.size() - successful);
        logger.info("üìä –í—Å–µ–≥–æ: {}", results.size());
        logger.info("=========================================");

        return results;
    }

    /**
     * –û—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç –≤—Å–µ –∑–∞–ø—É—â–µ–Ω–Ω—ã–µ —Å–µ—Ä–≤–∏—Å—ã
     */
    public Map<String, Object> stopAllRunningServices() {
        logger.info("üõë –û–°–¢–ê–ù–û–í–ö–ê –í–°–ï–• –ó–ê–ü–£–©–ï–ù–ù–´–• –°–ï–†–í–ò–°–û–í");

        Map<String, Object> result = new LinkedHashMap<>();
        List<String> stoppedServices = new ArrayList<>();

        runningProcesses.forEach((serviceType, process) -> {
            if (process != null && process.isAlive()) {
                try {
                    String displayName = getServiceDisplayName(serviceType);
                    process.destroy();

                    if (process.waitFor(5, TimeUnit.SECONDS)) {
                        updateServiceStatus(serviceType, ServiceState.STOPPED, null);
                        stoppedServices.add(displayName);
                        logger.info("‚úÖ –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: {}", displayName);
                    } else {
                        process.destroyForcibly();
                        updateServiceStatus(serviceType, ServiceState.FAILED, null, "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
                        logger.warn("‚ö†Ô∏è –ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω —Å–µ—Ä–≤–∏—Å: {}", displayName);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    logger.error("‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–µ—Ä–≤–∏—Å–∞: {}", e.getMessage());
                }
            }
        });

        runningProcesses.clear();
        result.put("stoppedServices", stoppedServices);
        result.put("count", stoppedServices.size());
        result.put("timestamp", LocalDateTime.now());

        return result;
    }

    // ============ –í–°–ü–û–ú–û–ì–ê–¢–ï–õ–¨–ù–´–ï –ú–ï–¢–û–î–´ ============

    private String getServiceDirectory(ServiceType serviceType) {
        Map<String, String> dirMap = new HashMap<>();
        dirMap.put("AUTH", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\Auth");
        dirMap.put("USER", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\User");
        dirMap.put("Sklad", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\Sklad");
        dirMap.put("backet-service", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\Backet");
        dirMap.put("Office", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\Office");
        dirMap.put("COLLECTOR", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\Collector");
        dirMap.put("Delivery", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\Delivery");
        dirMap.put("TransactionSaga", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\TransactionSaga");
        dirMap.put("ApiGateWay", "C:\\Users\\2oleg\\Downloads\\Telegram Desktop\\Kefir\\Backend\\ApiGateWay");

        String dir = dirMap.get(serviceType.getId());
        logger.debug("–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è {}: {}", serviceType.getId(), dir);
        return dir;
    }

    private int getServicePort(ServiceType serviceType) {
        return serviceType.getDefaultPort();
    }

    private String getServiceDisplayName(ServiceType serviceType) {
        return serviceType.getDisplayName();
    }

    private boolean isPortOpen(int port) {
        try (Socket socket = new Socket()) {
            socket.connect(new InetSocketAddress("localhost", port), 2000);
            return true;
        } catch (IOException e) {
            return false;
        }
    }

    private boolean releasePortIfNeeded(int port, String serviceName) {
        if (!isPortOpen(port)) {
            return true;
        }

        try {
            String pid = findProcessIdOnPort(port);
            if (pid != null && !pid.isEmpty()) {
                String killCmd = getKillCommand(pid);
                Process process = Runtime.getRuntime().exec(killCmd);
                int exitCode = process.waitFor();

                if (exitCode == 0) {
                    Thread.sleep(1000);
                    return !isPortOpen(port);
                }
            }
        } catch (Exception e) {
            logger.warn("–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Å–≤–æ–±–æ–¥–∏—Ç—å –ø–æ—Ä—Ç {} ({}): {}", port, serviceName, e.getMessage());
        }

        return false;
    }

    private String findProcessIdOnPort(int port) {
        try {
            String findCmd;
            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                findCmd = "cmd /c netstat -ano | findstr :" + port + " | findstr LISTENING";
            } else {
                findCmd = "lsof -ti:" + port + " -sTCP:LISTEN";
            }

            Process process = Runtime.getRuntime().exec(findCmd);
            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));

            String line;
            StringBuilder output = new StringBuilder();
            while ((line = reader.readLine()) != null) {
                output.append(line).append("\n");
            }
            process.waitFor();

            if (System.getProperty("os.name").toLowerCase().contains("win")) {
                String[] lines = output.toString().split("\n");
                for (String netstatLine : lines) {
                    String[] parts = netstatLine.trim().split("\\s+");
                    if (parts.length >= 5) {
                        return parts[parts.length - 1];
                    }
                }
            } else {
                if (output.length() > 0) {
                    return output.toString().trim().split("\n")[0];
                }
            }

        } catch (Exception e) {
            logger.debug("–ù–µ —É–¥–∞–ª–æ—Å—å –Ω–∞–π—Ç–∏ PID –¥–ª—è –ø–æ—Ä—Ç–∞ {}: {}", port, e.getMessage());
        }
        return null;
    }

    private String getKillCommand(String pid) {
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            return "cmd /c taskkill /F /PID " + pid;
        } else {
            return "kill -9 " + pid;
        }
    }

    private void startOutputReader(ServiceType serviceType, Process process) {
        executorService.submit(() -> {
            try (BufferedReader reader = new BufferedReader(
                    new InputStreamReader(process.getInputStream()))) {

                String line;
                while ((line = reader.readLine()) != null) {
                    logger.debug("[{}] {}", serviceType.getId(), line);

                    if (line.contains("Started") && line.contains("seconds")) {
                        logger.info("üéâ Spring Boot –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ {} —É—Å–ø–µ—à–Ω–æ –∑–∞–ø—É—â–µ–Ω–æ",
                                serviceType.getDisplayName());
                    }

                    if (line.contains("ERROR") || line.contains("Failed to start")) {
                        logger.warn("‚ö† –û—à–∏–±–∫–∞ –≤ –≤—ã–≤–æ–¥–µ —Å–µ—Ä–≤–∏—Å–∞ {}: {}", serviceType.getDisplayName(), line);
                    }
                }
            } catch (IOException e) {
                logger.error("–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –≤—ã–≤–æ–¥–∞ –ø—Ä–æ—Ü–µ—Å—Å–∞: {}", e.getMessage());
            }
        });
    }

    private void startHealthMonitoring(ServiceType serviceType) {
        executorService.submit(() -> {
            int port = getServicePort(serviceType);
            String displayName = getServiceDisplayName(serviceType);

            while (runningProcesses.containsKey(serviceType)) {
                try {
                    Thread.sleep(15000); // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—ã–µ 15 —Å–µ–∫—É–Ω–¥

                    if (!isServiceHealthy(serviceType)) {
                        logger.warn("‚ö† –°–µ—Ä–≤–∏—Å {} (–ø–æ—Ä—Ç {}) –Ω–µ –∑–¥–æ—Ä–æ–≤, –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫–∞–µ–º...",
                                displayName, port);
                        restartService(serviceType);
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                    break;
                }
            }
        });
    }

    private void updateServiceStatus(ServiceType serviceType, ServiceState state,
                                     Long pid, String... errorMessage) {
        ServiceStatusDTO status = serviceStatuses.get(serviceType);
        if (status != null) {
            status.setState(state);
            if (pid != null) {
                status.setPid(pid.intValue());
            }
            if (errorMessage.length > 0) {
                status.setErrorMessage(errorMessage[0]);
            }
            if (state == ServiceState.RUNNING) {
                status.setStartedAt(LocalDateTime.now());
            }
            status.setLastChecked(LocalDateTime.now());
        }
    }

    public ServiceStatusDTO stopService(ServiceType serviceType) {
        String displayName = getServiceDisplayName(serviceType);
        logger.info("üõë –û–°–¢–ê–ù–û–í–ö–ê –°–ï–†–í–ò–°–ê: {}", displayName);

        Process process = runningProcesses.get(serviceType);
        if (process != null && process.isAlive()) {
            process.destroy();
            try {
                if (process.waitFor(10, TimeUnit.SECONDS)) {
                    runningProcesses.remove(serviceType);
                    updateServiceStatus(serviceType, ServiceState.STOPPED, null);
                    logger.info("‚úÖ –°–µ—Ä–≤–∏—Å {} —É—Å–ø–µ—à–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", displayName);
                } else {
                    process.destroyForcibly();
                    updateServiceStatus(serviceType, ServiceState.FAILED, null, "–ü—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω");
                    logger.warn("‚ö† –°–µ—Ä–≤–∏—Å {} –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω", displayName);
                }
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                logger.error("‚ùå –ü—Ä–µ—Ä–≤–∞–Ω–æ –ø—Ä–∏ –æ—Å—Ç–∞–Ω–æ–≤–∫–µ —Å–µ—Ä–≤–∏—Å–∞ {}", displayName);
            }
        }

        return serviceStatuses.get(serviceType);
    }

    public ServiceStatusDTO restartService(ServiceType serviceType) {
        String displayName = getServiceDisplayName(serviceType);
        logger.info("üîÑ –ü–ï–†–ï–ó–ê–ü–£–°–ö –°–ï–†–í–ò–°–ê: {}", displayName);

        stopService(serviceType);

        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }

        return startService(serviceType);
    }

    public Map<ServiceType, ServiceStatusDTO> getAllServiceStatuses() {
        return new HashMap<>(serviceStatuses);
    }

    public ServiceStatusDTO getServiceStatus(ServiceType serviceType) {
        return serviceStatuses.get(serviceType);
    }
}package com.kefir.logistics.launcher_service;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.scheduling.annotation.EnableScheduling;

@SpringBootApplication
@EnableScheduling
public class LauncherServiceApplication {
    public static void main(String[] args) {
        SpringApplication.run(LauncherServiceApplication.class, args);
    }
}server:
  port: 8099
  servlet:
    context-path: /

spring:
  application:
    name: launcher-service
  datasource:
    url: jdbc:h2:file:./data/launcherdb
    driver-class-name: org.h2.Driver
    username: sa
    password:
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: true
    properties:
      hibernate:
        dialect: org.hibernate.dialect.H2Dialect
  h2:
    console:
      enabled: true
      path: /h2-console
  main:
    banner-mode: off

launcher:
  base-dir: "../"
  logs-dir: "./logs"
  startup-delay-ms: 5000
  health-check-timeout-sec: 30
  auto-restart: true
  services:
    AUTH:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Auth"
      port: 8097
      display-name: "Auth Service"
    USER:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/User"
      port: 8081
      display-name: "User Service"
    Sklad:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Sklad"
      port: 8082
      display-name: "Warehouse Service"
    backet-service:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Backet"
      port: 8083
      display-name: "Shopping Cart Service"
    Office:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Office"
      port: 8085
      display-name: "Office Service"
    COLLECTOR:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Collector"
      port: 8086
      display-name: "Collector Service"
    Delivery:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/Delivery"
      port: 8088
      display-name: "Delivery Service"
    TransactionSaga:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/TransactionSaga"
      port: 8090
      display-name: "Transaction Saga"
    ApiGateWay:
      directory: "C:/Users/2oleg/Downloads/Telegram Desktop/Kefir/Backend/ApiGateWay"
      port: 8080
      display-name: "API Gateway"
  auto-start: true
  auto-start-delay-ms: 5000
  auto-demo-delay-ms: 35000
  min-services-for-demo: 7
logging:
  level:
    com.kefir.logistics.launcher_service: INFO
    org.springframework.web: INFO
  file:
    name: logs/launcher-service.log
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{36} - %msg%n"<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
         http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.kefir.logistics</groupId>
    <artifactId>launcher-service</artifactId>
    <version>1.0.0</version>
    <packaging>jar</packaging>

    <name>Kefir Launcher Service</name>
    <description>Orchestration service for KEFIR Logistics with demo scenarios</description>

    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.1.5</version>
        <relativePath/>
    </parent>

    <properties>
        <java.version>17</java.version>
        <springdoc.version>2.2.0</springdoc.version>
    </properties>

    <dependencies>
        <!-- Spring Boot Starters -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-actuator</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-data-jpa</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-validation</artifactId>
        </dependency>

        <!-- Configuration Properties Support -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- Database -->
        <dependency>
            <groupId>com.h2database</groupId>
            <artifactId>h2</artifactId>
            <scope>runtime</scope>
        </dependency>

        <!-- Documentation -->
        <dependency>
            <groupId>org.springdoc</groupId>
            <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
            <version>${springdoc.version}</version>
        </dependency>

        <!-- JSON -->
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.datatype</groupId>
            <artifactId>jackson-datatype-jsr310</artifactId>
        </dependency>
        <dependency>
            <groupId>jakarta.annotation</groupId>
            <artifactId>jakarta.annotation-api</artifactId>
            <version>2.1.1</version>
        </dependency>
        <!-- Logging -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
        </dependency>
        <dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-databind</artifactId>
        </dependency>
        <!-- Testing -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <mainClass>com.kefir.logistics.launcher_service.LauncherServiceApplication</mainClass>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
