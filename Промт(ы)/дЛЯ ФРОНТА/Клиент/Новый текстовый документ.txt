У нас есть логистическая система. СЕЙЧАС ЕДИНСТВЕННАЯ ЦЕЛЬ - СОЗДАТЬ ФРОНТЕНД КЛИЕНТА!




Миссия приложения
Для нейросети  добавление внешних проверок (fact-checking), temperature > 0, цепочки верификации (Chain-of-Verification), регулярная перекалибровка. 
ЕЩЕ ВАЖНЕЕ _ЦЕЛОСТНОСТЬ НАШЕГО ПРИЛОЖЕНИЯ И НАШ НАД НИМ КОНТРОЛЬ, ЕСЛИ В КОДЕ ЧТО ТО ЕСТЬ И МЫ ТЕБЯ ОБ ЭТОМ НЕ СПРАШИВАЕМ ЗНАЧИТ ЭТО ПОЯВИЛОСЬ В КОДЕ ПО НАшей ВОЛЕ
Когда описываешь метод - ВСЕГДА СВЕРХУ  ПИШИ ЕГО КЛАСС 
Данную логистическую систему мы создаем из двух соображений. Создать хорошее логистическое приложение и решить проблему с ошибкой.
Мы собираемся через него разыгрывать ситуацию когда сборщик собирает заказ, заказа нет и он вынужден обращатся в офисс, что бы офис связался с покупателем и уточнил продолжать ли собирать заказ. При этом у офиса должно быть возможность просматривать заказ. По сути клиент должен начинать транзакцию. Мы разыгрываем сдесь ошибку которая реальна произходит в другом приложении и предлогаем изящное решение: Транзакция открыта, сборщик посылает запрос в офис. И если офис принимает от клиента подтверждение на продолжение - транзакция закрывается и клиенту приходят только те товары, которые сборщик пробил до этого. При этом деньги возвращаются только за один товар о котором сборщик сообщил в офис, а все остальные товары которые он не успел пробить до возникновения ошибки - остаются на складе, хоть за них и заплатили деньги.  Клиент требует привезти ему весь товар. Поскольку транзакция закрылась раньше, нельзя гарантировать что оставшийся кроме отмененного товар, который ещё не прокликали, есть на складе. Соответсвенно офису нужно последовательно обзванивать несколько складов. И курьер или идёт по склада и собирает заказ или необходимо что бы курьеры оставляли 6а один склад все товары. Такой заказ везут час вместо обычных 15 минут. 
Пункт 1.1. Разыграть в нашем приложении эту реально существующую ситуацию с возникновением ошибки. То есть намеренно вызвать ошибку транзакции. 
Пункт1.2. Когда клиенту привозят нгеполный заказ, и не хватает оплаченных товаров - клиент связывается с офисом, офисс проверяет что эти товары не были пробиты. Далее если клиент настаивает на том что бы ему привезли екго недостоющии товары, а этих товаров нет на складе - офисс вынужден собирать товары по всем складам. То есть нам необходимо семулировать ситуацию, насколько не выгодно допускать эту ошибку. И потом уже давать решение.
Пункт 2.  Решение следующуе. ЗАкрывать транзакцию если одного товара нет и открывать другую транзакцию, сборщик после звонка должен опять прокликать все товары.Тут проблема как раз в том, что мы точно не знаем в чем ошибка. Если применялись разные подходы, а ошибка остается. Мне кажется лучше всего отменять старую транзакцию. И создавать новую с начальными данными старой транзакции. Сборщик просто должен все перепикать. При неизвестных системных ошибках проще и безопаснее "перезагрузить процесс", чем пытаться его починить. Это как перезапустить зависший компьютер вместо поиска конкретного б
То есть если цепочка. User зашел, Создал корзину отправил. Юсер вышел. Коллектор зашел отправил запрос в офис, вышел. ОФис зашел позвонил клиенту(симуляция) запрос колектору вышел. Колектор зашел отдал заказ вышел. Клиент зашел отправил вышел. (Симуляция клиент звонит в офис. Офис зашел и общается со сборщиком. Дальше решение миссии в приложение - заходы выходы офиса и сборщика.ага в коде.

Структура проекта: Kefir-React-App
Подробное описание архитектуры React-приложения с микросервисным подходом



IV. КЛЮЧЕВЫЕ ОСОБЕННОСТИ АРХИТЕКТУРЫ
Принципы организации
1.Модульность — каждый микросервис автономен
2.Переиспользуемость — общие компоненты в корне src/
3.Масштабируемость — легкое добавление новых микросервисов
4.Независимость — отдельная сборка и деплой каждого микросервиса
Взаимодействие между слоями
text
Клиентский браузер
        ↓
Nginx (прокси/статик)
        ↓
Фронтенд-микросервисы
        ↓
Общие компоненты (src/)
        ↓
Бэкенд-микросервисы (API)
Типичный поток данных
text
1. Микросервис загружается → public/index.html
2. Инициализируется React-приложение → src/index.js
3. Загружается корневой компонент → App.js
4. Подключаются необходимые сервисы → services/
5. Используются общие компоненты → src/components/
6. Выполняются API-запросы → services/api.js

